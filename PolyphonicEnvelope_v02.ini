[droid]
    ledbrightness = 0.5

[p2b8]
[p2b8]
[p10]

### external trigger in to start an envelope cascade
[copy]
	input = G2 * _cascade_silent
	output = _trig_ext
### initiate evalutaion of included contours after reboot
[nudge]
	minimum = 0
	maximum = 1
	amount = 1
	startvalue = 1
	buttondown = _trig_ext
	dontsave = 1
	output = _incl_ini
[copy]
	input = _sample_incl + _incl_ini
	output = _sample_incl_ini

### lfo for led animation
[lfo]
	hz = 2
#	level = 0.8 # use level to weaken the contrast of the flashing
	triangle = _state_lfo

### menu buttons
[buttongroup]
	button5 = B2.5
	button6 = B2.6
	button7 = B2.7
	button8 = B2.8
	led6 = L2.6
	led7 = L2.7
	led8 = L2.8
	buttonoutput5 = _menu5
	buttonoutput6 = _menu6
	buttonoutput7 = _menu7
	buttonoutput8 = _menu8
[copy]
	input = 1 - _menu8
	output = _menu8_off

[button]
	button = B2.5
	select = _menu5
	longpress = _menu5_longpress
[nudge]
	amount = 1
	minimum = 0
	maximum = 1
	wrap = 1
	buttonup = _menu5 * _menu5_longpress
	output = _submenu5_on
[copy]
	input = _menu5 * _submenu5_on
	output = _submenu5
[copy]
	input = 1 - _submenu5
	output = _submenu5_off
[copy]
	input = _menu5 * _submenu5_off
	output = _menu5_on
[buttongroup]
	select = _submenu5
	button1 = B2.1
	button2 = B2.2
	button3 = B2.3
	button4 = B2.4
	buttonoutput1 = _cycle1x
	buttonoutput2 = _cycle2x
	buttonoutput3 = _cycle3x
	buttonoutput4 = _cycle_random_on
[button]
	button = B2.4
	select = _cycle_random_on
	longpress = _cyclexx_toggle
[nudge]
	amount = 1
	minimum = 0
	maximum = 1
	wrap = 1
	buttonup = _cyclexx_toggle
	output = _cyclexx_on
[copy]
	input = _cyclexx_on * _cycle_random_on
	output = _cyclexx
[copy]
	input = _cyclexx * _state_lfo
	output = _cyclexx_lfo
[copy]
	input = 1 - _cyclexx
	output = _cyclexx_off
[copy]
	input = _cycle_random_on * _cyclexx_off
	output = _cycle_random

[buttongroup]
	select = _menu6
	button1 = B2.1
	button2 = B2.2
	button3 = B2.3
	button4 = B2.4
	minactive = 0
	maxactive = 4
	buttonoutput1 = _mod_cont1
	buttonoutput2 = _mod_cont2
	buttonoutput3 = _mod_cont3
	buttonoutput4 = _mod_cont4

[buttongroup]
	select = _menu7
	button1 = B2.1
	button2 = B2.2
	button3 = B2.3
	button4 = B2.4
	buttonoutput1 = _use_eoa
	buttonoutput2 = _use_eor
	buttonoutput3 = _use_eoh
	buttonoutput4 = _use_random
###
[buttongroup]
	select = _menu8
	button1 = B2.1
	button2 = B2.2
	button3 = B2.3
	button4 = B2.4
	buttonoutput1 = _dir_up_on
	buttonoutput2 = _dir_down_on
	buttonoutput3 = _dir_pendulum_on
	buttonoutput4 = _dir_random_on

### tilt factors attack
[pot]
	select = _menu8
	pot = P1.1
	notch = 0.1
	outputscale = 0.9
	bipolar = _tilt_attack_pot # ranging from -0.9 to +0.9
[compare]
	input = _tilt_attack_pot + I5
	compare = 0.9
	ifgreater = 0.9
	else = _tilt_attack_pot + I5
	output = _tilt_attack_limit
[compare]
	input = _tilt_attack_limit
	compare = -0.9
	ifless = -0.9
	else = _tilt_attack_limit
	output = _tilt_attack_raw
[math]
	input1 = _tilt_attack_raw + 1
	input2 = 4/3 # 1.333
	power = _attack_factor2
[math]
	input1 = _tilt_attack_raw + 1
	input2 = 8/3 # 2.666
	power = _attack_factor3
[math]
	input1 = _tilt_attack_raw + 1
	input2 = 12/3 # 4
	power = _attack_factor4
### tilt factors hold
[pot]
	select = _menu8
	pot = P1.2
	notch = 0.1
	outputscale = 0.9
	bipolar = _tilt_hold_pot
[compare]
	input = _tilt_hold_pot + I6
	compare = 0.9
	ifgreater = 0.9
	else = _tilt_hold_pot + I6
	output = _tilt_hold_limit
[compare]
	input = _tilt_hold_limit
	compare = -0.9
	ifless = -0.9
	else = _tilt_hold_limit
	output = _tilt_hold_raw
[math]
	input1 = _tilt_hold_raw + 1
	input2 = 4/3
	power = _hold_factor2
[math]
	input1 = _tilt_hold_raw + 1
	input2 = 8/3
	power = _hold_factor3
[math]
	input1 = _tilt_hold_raw + 1
	input2 = 12/3
	power = _hold_factor4
### tilt factors release
[pot]
	select = _menu8
	pot = P2.1
	notch = 0.1
	outputscale = 0.9
	bipolar = _tilt_release_pot
[compare]
	input = _tilt_release_pot + I7
	compare = 0.9
	ifgreater = 0.9
	else = _tilt_release_pot + I7
	output = _tilt_release_limit
[compare]
	input = _tilt_release_limit
	compare = -0.9
	ifless = -0.9
	else = _tilt_release_limit
	output = _tilt_release_raw
[math]
	input1 = _tilt_release_raw + 1
	input2 = 4/3
	power = _release_factor2
[math]
	input1 = _tilt_release_raw + 1
	input2 = 8/3
	power = _release_factor3
[math]
	input1 = _tilt_release_raw + 1
	input2 = 12/3
	power = _release_factor4
### tilt factors level
[pot]
	select = _menu8
	pot = P2.2
	notch = 0.1
	outputscale = 0.9
	bipolar = _tilt_level_pot
[compare]
	input = _tilt_level_pot + I8
	compare = 0.9
	ifgreater = 0.9
	else = _tilt_level_pot + I8
	output = _tilt_level_limit
[compare]
	input = _tilt_level_limit
	compare = -0.9
	ifless = -0.9
	else = _tilt_level_limit
	output = _tilt_level_raw
[math]
	input1 = _tilt_level_raw + 1
	input2 = 4/3
	power = _level_factor2
[math]
	input1 = _tilt_level_raw + 1
	input2 = 8/3
	power = _level_factor3
[math]
	input1 = _tilt_level_raw + 1
	input2 = 12/3
	power = _level_factor4

### led management
[mixer]
	input1 = _menu5_on * _incl_cont1_on
	input2 = _submenu5 * _cycle1x
	input3 = _menu6 * _mod_cont1
	input4 = _menu7 * _use_eoa
	input5 = _menu8 * _dir_up_on
	output = L2.1
[mixer]
	input1 = _menu5_on * _incl_cont2_on
	input2 = _submenu5 * _cycle2x
	input3 = _menu6 * _mod_cont2
	input4 = _menu7 * _use_eor
	input5 = _menu8 * _dir_down_on
	output = L2.2
[mixer]
	input1 = _menu5_on * _incl_cont3_on
	input2 = _submenu5 * _cycle3x
	input3 = _menu6 * _mod_cont3
	input4 = _menu7 * _use_eoh
	input5 = _menu8 * _dir_pendulum_on
	output = L2.3
[mixer]
	input1 = _menu5_on * _incl_cont4_on
	input2 = _submenu5 * _cycle_random
	input3 = _submenu5 * _cyclexx_lfo
	input4 = _menu6 * _mod_cont4
	input5 = _menu7 * _use_random
	input6 = _menu8 * _dir_random_on
	output = L2.4
[mixer]
	input1 = _menu5_on
	input2 = _submenu5 * _state_lfo
	output = L2.5

### evaluation of end of contour triggers
[mixer]
	input1 = _eocont_1
	input2 = _eocont_2
	input3 = _eocont_3
	input4 = _eocont_4
	output = _eocont

### count contours of one cascade
[nudge]
	clear = _cont_clear * _eoc_trig + _trig_ext
	minimum = 0
	maximum = _incl_sum * _pendulum_scaling # for pendulum mode set _incl_sum * 2
	amount = 1
	buttonup = _eocont
	dontsave = 1
	output = _contcount
[compare]
	input = _contcount
	compare = _incl_sum * _pendulum_scaling # for pendulum mode set _incl_sum * 2
	ifless = 1
	output = _cont_pass
[copy]
	input = 1 - _cont_pass
	output = _cont_clear
[copy]
	input = _eocont * _cont_pass
	output = _eocont_trig
[copy]
	input = _cont_clear * _eocont
	output = _eoc

### evaluate direction of contours within a cascade
[sample]
	input = _dir_up_on
	gate = _eoc + _cascade_silent
	output = _dir_up
[sample]
	input = _dir_down_on
	gate = _eoc + _cascade_silent
	output = _dir_down
[sample]
	input = _dir_pendulum_on
	gate = _eoc + _cascade_silent
	output = _dir_pendulum
[copy]
	input = _dir_pendulum + 1
	output = _pendulum_scaling

### separate pendulum direction into upward and downward phases
[compare]
	input = _contcount * _dir_pendulum
	compare = _incl_sum
	ifless = _dir_pendulum
	output = _dir_pendulum_up_on1
[compare]
	input = _contcount * _dir_pendulum
	compare = _incl_sum * _pendulum_scaling
	ifequal = _dir_pendulum
	output = _dir_pendulum_up_on2
[sample]
	input = _dir_pendulum_up_on1 + _dir_pendulum_up_on2
	sample = _eocont + _sample_incl_ini
	output = _dir_pendulum_up
[copy]
	input = _dir_up + _dir_pendulum_up
	output = _dir_up_apply
[compare]
	input = _contcount * _dir_pendulum
	compare = _incl_sum - 1
	ifgreater = _dir_pendulum
	output = _dir_pendulum_down_on1
[compare]
	input = _contcount * _dir_pendulum
	compare = _incl_sum * _pendulum_scaling
	ifless = _dir_pendulum
	output = _dir_pendulum_down_on2
[sample]
	input = _dir_pendulum_down_on1 * _dir_pendulum_down_on2
	sample = _eocont + _sample_incl_ini
	output = _dir_pendulum_down
[copy]
	input = _dir_down + _dir_pendulum_down
	output = _dir_down_apply
[nudge]
	clear = _dir_pendulum_down_clear
	minimum = 0
	maximum = 1
	amount = 1
	buttonup = _dir_pendulum_down
	output = _dir_pendulum_down_reset
[copy]
	input = _dir_pendulum_down_reset
	output = _dir_pendulum_down_clear

### random mode for envelope order
[sample]
	input = _dir_random_on
	gate = _eoc + _cascade_silent
	output = _dir_random
[random]
	clock = _eocont
	minimum = 1
	maximum = _incl_sum
	steps = _incl_sum
	output = _cont_random
[copy]
	input = _cont_random * _dir_random
	output = _add_random

### random mode for envelope triggers within a cascade
[random]
	clock = _cycle_clear * _eoc_trig + _trig_ext
	minimum = 1
	maximum = 3
	steps = 3
	output = _use_random_sel
[compare]
	input = _use_random_sel * _use_random
	compare = 1
	output = _use_random_eoa
[compare]
	input = _use_random_sel * _use_random
	compare = 2
	output = _use_random_eoh
[compare]
	input = _use_random_sel * _use_random
	compare = 3
	output = _use_random_eor
[sample]
	input = _use_eoa + _use_random_eoa
	gate = _eoc + _cascade_silent
	output = _use_eoa_on
[sample]
	input = _use_eoh + _use_random_eoh
	gate = _eoc + _cascade_silent
	output = _use_eoh_on
[sample]
	input = _use_eor + _use_random_eor
	gate = _eoc + _cascade_silent
	output = _use_eor_on

### random mode for number of cycles
[random]
	clock = _cycle_clear * _eoc_trig + _trig_ext
	minimum = 1
	maximum = 3
	steps = 3
	output = _cyclecount_random
### number of cycles
[mixer]
	input1 = _cycle1x * 1
	input2 = _cycle2x * 2
	input3 = _cycle3x * 3
	input4 = _cycle_random * _cyclecount_random
	output = _cyclecountmax
### trigger on/off management
[nudge]
	clear = _cycle_clear * _eoc_trig + _trig_ext
	minimum = 1
	maximum = _cyclecountmax
	amount = 1
	buttonup = _eoc_trig
	dontsave = 1
	output = _cyclecount
[compare]
	input = _cyclecount
	compare = _cyclecountmax
	ifless = 1
	output = _cycle_pass
[copy]
	input = 1 - _cycle_pass
	output = _cycle_clear
[copy]
	input = _cycle_pass + _cyclexx
	output = _cycle_on
[copy]
	input = _eoc * _cycle_on
	output = _eoc_trig
[mixer]
	input1 = _eocont_trig
	input2 = _eoc_trig
	input3 = _trig_ext
	output = _trigger
[copy]
	input = 1 - _trigger
	output = _trigger_inv

### evaluation of activated envelopes/contours	
[button]
	button = B2.1
	select = _menu5_on
	output = _incl_cont1_on
[sample]
	input = _incl_cont1_on
	gate = _eoc + _cascade_silent
	output = _incl_cont1
[button]
	button = B2.2
	select = _menu5_on
	output = _incl_cont2_on
[sample]
	input = _incl_cont2_on
	gate = _eoc + _cascade_silent
	output = _incl_cont2
[button]
	button = B2.3
	select = _menu5_on
	output = _incl_cont3_on
[sample]
	input = _incl_cont3_on
	gate = _eoc + _cascade_silent
	output = _incl_cont3
[button]
	button = B2.4
	select = _menu5_on
	output = _incl_cont4_on
[sample]
	input = _incl_cont4_on
	gate = _eoc + _cascade_silent
	output = _incl_cont4

### enable evaluation of included contours when all contours are deactivated
[logic]
	input1 = 1 - _incl_cont1_on
	input2 = 1 - _incl_cont2_on
	input3 = 1 - _incl_cont3_on
	input4 = 1 - _incl_cont4_on
	and = _sample_incl

### determine number of activated envelopes
[superjust]
	bypass = 1
	input1 = _incl_cont1 + _incl_cont2
	output1 = _sum12
	input2 = _incl_cont3 + _incl_cont4
	output2 = _sum34
	input3 = _sum12 + _sum34
	output3 = _incl_sum
[compare]
	input = _incl_sum
	compare = 0
	ifgreater = 1
	output = _incl_some
[compare]
	input = _incl_sum
	compare = 1
	output = _total_1
[compare]
	input = _incl_sum
	compare = 2
	output = _total_2
[compare]
	input = _incl_sum
	compare = 3
	output = _total_3
[compare]
	input = _incl_sum
	compare = 4
	output = _total_4
### trigger management for total 1 activated envelope
[copy]
	input = _trigger * _total_1
	output = _trigger_total_1
[superjust]
	input1 = _trigger_total_1 * _incl_cont1
	output1 = _1trig_1
	input2 = _trigger_total_1 * _incl_cont2
	output2 = _1trig_2
	input3 = _trigger_total_1 * _incl_cont3
	output3 = _1trig_3
	input4 = _trigger_total_1 * _incl_cont4
	output4 = _1trig_4
### trigger management for total 2 activated envelopes
[copy]
	input = _trigger * _total_2
	output = _trigger_total_2
[superjust]
	input1 = _incl_cont1 * _incl_cont2
	output1 = _incl_cont12
	input2 = _incl_cont1 * _incl_cont3
	output2 = _incl_cont13
	input3 = _incl_cont1 * _incl_cont4
	output3 = _incl_cont14
	input4 = _incl_cont2 * _incl_cont3
	output4 = _incl_cont23
	input5 = _incl_cont2 * _incl_cont4
	output5 = _incl_cont24
	input6 = _incl_cont3 * _incl_cont4
	output6 = _incl_cont34
[switch]
	input = _trigger_total_2 * _incl_cont12
	reset = _eoc + _dir_pendulum_down_reset
	offset = _dir_down_apply + _add_random
	output1 = _12trig_1
	output2 = _12trig_2
	forward = _eocont * _dir_up_apply 
	backward = _eocont * _dir_down_apply
[switch]
	input = _trigger_total_2 * _incl_cont13
	reset = _eoc + _dir_pendulum_down_reset
	offset = _dir_down_apply + _add_random
	output1 = _13trig_1
	output2 = _13trig_3
	forward = _eocont * _dir_up_apply 
	backward = _eocont * _dir_down_apply
[switch]
	input = _trigger_total_2 * _incl_cont14
	reset = _eoc + _dir_pendulum_down_reset
	offset = _dir_down_apply + _add_random
	output1 = _14trig_1
	output2 = _14trig_4
	forward = _eocont * _dir_up_apply 
	backward = _eocont * _dir_down_apply
[switch]
	input = _trigger_total_2 * _incl_cont23
	reset = _eoc + _dir_pendulum_down_reset
	offset = _dir_down_apply + _add_random
	output1 = _23trig_2
	output2 = _23trig_3
	forward = _eocont * _dir_up_apply 
	backward = _eocont * _dir_down_apply
[switch]
	input = _trigger_total_2 * _incl_cont24
	reset = _eoc + _dir_pendulum_down_reset
	offset = _dir_down_apply + _add_random
	output1 = _24trig_2
	output2 = _24trig_4
	forward = _eocont * _dir_up_apply 
	backward = _eocont * _dir_down_apply
[switch]
	input = _trigger_total_2 * _incl_cont34
	reset = _eoc + _dir_pendulum_down_reset
	offset = _dir_down_apply + _add_random
	output1 = _34trig_3
	output2 = _34trig_4
	forward = _eocont * _dir_up_apply 
	backward = _eocont * _dir_down_apply
### trigger management for total 3 activated envelopes
[copy]
	input = _trigger * _total_3
	output = _trigger_total_3
[superjust]
	input1 = _incl_cont12 * _incl_cont3
	output1 = _incl_cont123
	input2 = _incl_cont12 * _incl_cont4
	output2 = _incl_cont124
	input3 = _incl_cont13 * _incl_cont4
	output3 = _incl_cont134
	input4 = _incl_cont23 * _incl_cont4
	output4 = _incl_cont234
[switch]
	input = _trigger_total_3 * _incl_cont123
	reset = _eoc + _dir_pendulum_down_reset
	offset = _dir_down_apply * 2 + _add_random
	output1 = _123trig_1
	output2 = _123trig_3
	output3 = _123trig_2
	forward = _eocont * _dir_up_apply 
	backward = _eocont * _dir_down_apply
[switch]
	input = _trigger_total_3 * _incl_cont124
	reset = _eoc + _dir_pendulum_down_reset
	offset = _dir_down_apply * 2 + _add_random
	output1 = _124trig_1
	output2 = _124trig_4
	output3 = _124trig_2
	forward = _eocont * _dir_up_apply 
	backward = _eocont * _dir_down_apply
[switch]
	input = _trigger_total_3 * _incl_cont134
	reset = _eoc + _dir_pendulum_down_reset
	offset = _dir_down_apply * 2 + _add_random
	output1 = _134trig_1
	output2 = _134trig_4
	output3 = _134trig_3
	forward = _eocont * _dir_up_apply 
	backward = _eocont * _dir_down_apply
[switch]
	input = _trigger_total_3 * _incl_cont234
	reset = _eoc + _dir_pendulum_down_reset
	offset = _dir_down_apply * 2 + _add_random
	output1 = _234trig_2
	output2 = _234trig_4
	output3 = _234trig_3
	forward = _eocont * _dir_up_apply 
	backward = _eocont * _dir_down_apply
### trigger management for total 4 activated envelopes
[copy]
	input = _trigger * _total_4
	output = _trigger_total_4
[switch]
	input = _trigger_total_4
	reset = _eoc + _dir_pendulum_down_reset
	offset = _dir_down_apply * 3 + _add_random
	output1 = _4trig_1
	output2 = _4trig_4
	output3 = _4trig_3
	output4 = _4trig_2
	forward = _eocont * _dir_up_apply 
	backward = _eocont * _dir_down_apply

### gather trigger possibilities
[mixer]
	input1 = _1trig_1
	input2 = _12trig_1
	input3 = _13trig_1
	input4 = _14trig_1
	input5 = _123trig_1
	input6 = _124trig_1
	input7 = _134trig_1
	input8 = _4trig_1
	output = _trig_1
[mixer]
	input1 = _1trig_2
	input2 = _12trig_2
	input3 = _23trig_2
	input4 = _24trig_2
	input5 = _123trig_2
	input6 = _124trig_2
	input7 = _234trig_2
	input8 = _4trig_2
	output = _trig_2
[mixer]
	input1 = _1trig_3
	input2 = _13trig_3
	input3 = _23trig_3
	input4 = _34trig_3
	input5 = _123trig_3
	input6 = _134trig_3
	input7 = _234trig_3
	input8 = _4trig_3
	output = _trig_3
[mixer]
	input1 = _1trig_4
	input2 = _14trig_4
	input3 = _24trig_4
	input4 = _34trig_4
	input5 = _124trig_4
	input6 = _134trig_4
	input7 = _234trig_4
	input8 = _4trig_4
	output = _trig_4

### envelope 1
# pots for envelope 1 parameters
[pot]
	select = _mod_cont1 * _menu8_off
	pot = P1.1
	outputscale = 20
	output = _attack_1_pot
[compare]
	input = _attack_1_pot
	compare = 0.1 # limit attack time to keep cascades stable
	ifless = 0.1
	else = _attack_1_pot
	output = _attack_1
[pot]
	select = _mod_cont1 * _menu8_off
	pot = P1.2
	output = _hold_1_pot
[compare]
	input = _hold_1_pot
	compare = 0.08 # limit hold time to keep cascades stable
	ifless = 0.08
	else = _hold_1_pot
	output = _hold_1
[pot]
	select = _mod_cont1 * _menu8_off
	pot = P2.1
	output = _release_1
[pot]
	select = _mod_cont1 * _menu8_off
	pot = P2.2
	output = _level_1
# envelope 1 circuit
[contour]
	trigger = _trig_1
	attack = _attack_1
	hold = _hold_1
	release = _release_1
	level = _level_1
	startfromzero = 1
	output = _cont1_out
	endofattack = _eoa_1
	endofhold = _eoh_1
	endofrelease = _eor_1
# For every contour, allow only a single (i.e. the earliest) end-of-contour signal to be fired. This prevents confusion when switching between endofattack/endofhold/endofrelease.
[copy]
	input = 1 - _trig_1
	output = _trig_1_inv
[nudge]
	clear = _eocont_1_tmp * _trig_1_inv
	minimum = 0
	maximum = 1
	amount = 1
	buttonup = _trig_1
	dontsave = 1
	output = _cont1_open
[mixer]
	input1 = _eoa_1 * _use_eoa_on
	input2 = _eoh_1 * _use_eoh_on
	input3 = _eor_1 * _use_eor_on
	output = _eocont_1_tmp
[copy]
	input = _eocont_1_tmp * _cont1_open
	output = _eocont_1
### envelope 2
# pots for envelope 2 parameters
[pot]
	select = _mod_cont2 * _menu8_off
	pot = P1.1
	outputscale = 20
	output = _attack_2_pot
# include tilt function and limit net outcome
[compare]
	input = _attack_2_pot * _attack_factor2
	compare = 0.1
	ifless = 0.1
	else = _attack_2_pot * _attack_factor2
	output = _attack_2
[pot]
	select = _mod_cont2 * _menu8_off
	pot = P1.2
	output = _hold_2_pot
[compare]
	input = _hold_2_pot * _hold_factor2
	compare = 0.08
	ifless = 0.08
	else = _hold_2_pot * _hold_factor2
	output = _hold_2
[pot]
	select = _mod_cont2 * _menu8_off
	pot = P2.1
	output = _release_2
[pot]
	select = _mod_cont2 * _menu8_off
	pot = P2.2
	output = _level_2
# envelope 2 circuit
[contour]
	trigger = _trig_2
	attack = _attack_2
	hold = _hold_2
	release = _release_2 * _release_factor2
	level = _level_2 * _level_factor2
	startfromzero = 1
	output = _cont2_out
	endofattack = _eoa_2
	endofhold = _eoh_2
	endofrelease = _eor_2
[copy]
	input = 1 - _trig_2
	output = _trig_2_inv
[nudge]
	clear = _eocont_2_tmp * _trig_2_inv
	minimum = 0
	maximum = 1
	amount = 1
	buttonup = _trig_2
	dontsave = 1
	output = _cont2_open
[mixer]
	input1 = _eoa_2 * _use_eoa_on
	input2 = _eoh_2 * _use_eoh_on
	input3 = _eor_2 * _use_eor_on
	output = _eocont_2_tmp
[copy]
	input = _eocont_2_tmp * _cont2_open
	output = _eocont_2
### envelope 3
# pots for envelope 3 parameters
[pot]
	select = _mod_cont3 * _menu8_off
	pot = P1.1
	outputscale = 20
	output = _attack_3_pot
[compare]
	input = _attack_3_pot * _attack_factor3
	compare = 0.1
	ifless = 0.1
	else = _attack_3_pot * _attack_factor3
	output = _attack_3
[pot]
	select = _mod_cont3 * _menu8_off
	pot = P1.2
	output = _hold_3_pot
[compare]
	input = _hold_3_pot * _hold_factor3
	compare = 0.08
	ifless = 0.08
	else = _hold_3_pot * _hold_factor3
	output = _hold_3
[pot]
	select = _mod_cont3 * _menu8_off
	pot = P2.1
	output = _release_3
[pot]
	select = _mod_cont3 * _menu8_off
	pot = P2.2
	output = _level_3
# envelope 3 circuit
[contour]
	trigger = _trig_3
	attack = _attack_3
	hold = _hold_3
	release = _release_3 * _release_factor3
	level = _level_3 * _level_factor3
	startfromzero = 1
	output = _cont3_out
	endofattack = _eoa_3
	endofhold = _eoh_3
	endofrelease = _eor_3
[copy]
	input = 1 - _trig_3
	output = _trig_3_inv
[nudge]
	clear = _eocont_3_tmp * _trig_3_inv
	minimum = 0
	maximum = 1
	amount = 1
	buttonup = _trig_3
	dontsave = 1
	output = _cont3_open
[mixer]
	input1 = _eoa_3 * _use_eoa_on
	input2 = _eoh_3 * _use_eoh_on
	input3 = _eor_3 * _use_eor_on
	output = _eocont_3_tmp
[copy]
	input = _eocont_3_tmp * _cont3_open
	output = _eocont_3
### envelope 4
# pots for envelope 4 parameters
[pot]
	select = _mod_cont4 * _menu8_off
	pot = P1.1
	outputscale = 20
	output = _attack_4_pot
[compare]
	input = _attack_4_pot * _attack_factor4
	compare = 0.1
	ifless = 0.1
	else = _attack_4_pot * _attack_factor4
	output = _attack_4
[pot]
	select = _mod_cont4 * _menu8_off
	pot = P1.2
	output = _hold_4_pot
[compare]
	input = _hold_4_pot * _hold_factor4
	compare = 0.08
	ifless = 0.08
	else = _hold_4_pot * _hold_factor4
	output = _hold_4
[pot]
	select = _mod_cont4 * _menu8_off
	pot = P2.1
	output = _release_4
[pot]
	select = _mod_cont4 * _menu8_off
	pot = P2.2
	output = _level_4
# envelope 4 circuit
[contour]
	trigger = _trig_4
	attack = _attack_4
	hold = _hold_4
	release = _release_4 * _release_factor4
	level = _level_4 * _level_factor4
	startfromzero = 1
	output = _cont4_out
	endofattack = _eoa_4
	endofhold = _eoh_4
	endofrelease = _eor_4
[copy]
	input = 1 - _trig_4
	output = _trig_4_inv
[nudge]
	clear = _eocont_4_tmp * _trig_4_inv
	minimum = 0
	maximum = 1
	amount = 1
	buttonup = _trig_4
	dontsave = 1
	output = _cont4_open
[mixer]
	input1 = _eoa_4 * _use_eoa_on
	input2 = _eoh_4 * _use_eoh_on
	input3 = _eor_4 * _use_eor_on
	output = _eocont_4_tmp
[copy]
	input = _eocont_4_tmp * _cont4_open
	output = _eocont_4

### allow new external trigger only when cascade is currently not running
[nudge]
	minimum = 0
	maximum = 1
	amount = 1
	startvalue = 1
	buttondown = _trigger * _incl_some
	buttonup = _eoc * _trigger_inv + _sample_incl_ini
	dontsave = 1
	output = _cascade_silent

### output individual envelopes
[superjust]
	input1 = _cont1_out
	input2 = _cont2_out
	input3 = _cont3_out
	input4 = _cont4_out
	output1 = O1
	output2 = O2
	output3 = O3
	output4 = O4	
### output sum of envelopes
[mixer]
	input1 = _cont1_out
	input2 = _cont2_out
	input3 = _cont3_out
	input4 = _cont4_out
	output = O5

### optional output of envelope triggers
#[superjust]
#	input1 = _trig_1
#	input2 = _trig_2
#	input3 = _trig_3
#	input4 = _trig_4
#	output1 = G5
#	output2 = G6
#	output3 = G7
#	output4 = G8	

### optional output of envelope gates , lasting from begin of attack to end of hold
#[nudge]
#	minimum = 0
#	maximum = 1
#	amount = 1
#	buttonup = _trig_1
#	buttondown = _eoh_1 * _trig_1_inv
#	dontsave = 1
#	output = G5
#[nudge]
#	minimum = 0
#	maximum = 1
#	amount = 1
#	buttonup = _trig_2
#	buttondown = _eoh_2 * _trig_2_inv
#	dontsave = 1
#	output = G6
#[nudge]
#	minimum = 0
#	maximum = 1
#	amount = 1
#	buttonup = _trig_3
#	buttondown = _eoh_3 * _trig_3_inv
#	dontsave = 1
#	output = G7
#[nudge]
#	minimum = 0
#	maximum = 1
#	amount = 1
#	buttonup = _trig_4
#	buttondown = _eoh_4 * _trig_4_inv
#	dontsave = 1
#	output = G8
	
