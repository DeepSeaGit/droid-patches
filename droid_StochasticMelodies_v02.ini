[droid]
    ledbrightness = 0.5

[p2b8]
[p2b8]
[p10]

### convert input clock trigger to a 10V signal in order to use it as 0/1 multiplyer
[gatetool]
	inputtrigger = I1
	outputtrigger = _clock_ext
### start all internal sequencers per trigger in or midi controller
[copy]
	input = I2
	output = _reset
#[midiin]
#	start = _reset

# work with 2 clocks to avoid timing conflicts
[triggerdelay]
	input = _clock_ext
	delay = 0.002 # delay time in ms
	output = _clock
[lfo]
	hz = 2
	pulsewidth = 0.2
	offset = -1
	square = _lfo_sub
[lfo]
	hz = 8
	square = _lfo
[switch]
	input = _clock_ext
	reset = _reset
	output1 = _step16
	output2 = _step15
	output3 = _step14
	output4 = _step13
	output5 = _step12
	output6 = _step11
	output7 = _step10
	output8 = _step9
	output9 = _step8
	output10 = _step7
	output11 = _step6
	output12 = _step5
	output13 = _step4
	output14 = _step3
	output15 = _step2
	output16 = _step1
	forward = _clock_ext
# I use an independent algoquencer to get stable bar leds not affected by the length of the output algoquencers
[algoquencer]
	clock = _clock_ext
	reset = _reset
	barled1 = _barled1
	barled2 = _barled2
	barled3 = _barled3
	barled4 = _barled4
### menu control
[buttongroup]
	select = _sub_off
	button1 = B1.1
	button2 = B1.3
	button3 = B1.5
	button4 = B1.7
	button5 = B1.2
	button6 = B1.4
	buttonoutput1 = _menu1
	buttonoutput2 = _menu2
	buttonoutput3 = _menu3
	buttonoutput4 = _menu4
	buttonoutput5 = _chan1
[buttongroup]
	select = _chan1 * _sub_off
	minactive = 1
	maxactive = 1
	button1 = B2.1
	button2 = B2.2
	button3 = B2.3
	button4 = B2.4
	buttonoutput1 = _pitch_calc
	buttonoutput2 = _notelength_calc
	buttonoutput3 = _oct_calc
	buttonoutput4 = _cont
[buttongroup]
	select = _chan1 * _sub_off
	preset = _preset
	loadpreset = _load
	savepreset = _save
	minactive = 0
	maxactive = 4
	button1 = B2.5
	button2 = B2.6
	button3 = B2.7
	button4 = B2.8
	buttonoutput1 = _pitch_new_ini
	buttonoutput2 = _pattern_new_ini
	buttonoutput3 = _pitch2_new_ini
	buttonoutput4 = _pattern2_new_ini
### buttons for saving and loading presets
[buttongroup]
	select = _menu4
	button1 = B2.1
	button2 = B2.2
	button3 = B2.3
	button4 = B2.4
	button5 = B2.5
	button6 = B2.6
	button7 = B2.7
	button8 = B2.8
	led1 = _menu4_L21
	led2 = _menu4_L22
	led3 = _menu4_L23
	led4 = _menu4_L24
	led5 = _menu4_L25
	led6 = _menu4_L26
	led7 = _menu4_L27
	led8 = _menu4_L28
	value1 = 0
	value2 = 1
	value3 = 2
	value4 = 3
	value5 = 4
	value6 = 5
	value7 = 6
	value8 = 7
	output = _preset
	buttonpress = _load_ini
	longpress = _save
[contour] # animation for saving presets in menu8
	trigger = _save
	attack = 0
	release = 0
	hold = 2
	output = _save_on
[switch]
	input1 = _menu4_L21
	input2 = _menu4_L22
	input3 = _menu4_L23
	input4 = _menu4_L24
	input5 = _menu4_L25
	input6 = _menu4_L26
	input7 = _menu4_L27
	input8 = _menu4_L28
	offset = _preset
	output = _buttonhold
[copy]
	input = -2 * _buttonhold + 1
	output = _amplitude
[copy]
	input = _lfo * _amplitude
	output = _lfo_scaled
[switch]
	input = _save_on * _lfo_scaled
	offset = _preset
	output1 = _save_blink0
	output2 = _save_blink7
	output3 = _save_blink6
	output4 = _save_blink5
	output5 = _save_blink4
	output6 = _save_blink3
	output7 = _save_blink2
	output8 = _save_blink1
# load presets only at the end of a bar
[flipflop]
	clear = _load
	set = _load_ini
	output = _load_pass
[copy]
	input = _load_pass * _step16_load
	output = _load
[copy]
	input = _load_pass * 0.9
	output = _load_queue
[copy]
	input = _menu4 - _load_queue
	output = _load_queue_dim
### sub-menu control
[superjust]
	bypass = 1
	input1 = _chan1 * _sub_off
	output1 = _chan1_sub_off
	input2 = _chan1 * _pitch_calc
	output2 = _chan1_pitch_sub
	input3 = _chan1_pitch_sub * _sub_on
	output3 = _chan1_pitch_sub_on
	input4 = _chan1 * _oct_calc
	output4 = _chan1_oct_sub
	input5 = _chan1_oct_sub * _sub_on
	output5 = _chan1_oct_sub_on
[button]
	select = _chan1_sub_off
	button = B2.1
	states = 1
	output = _enter_pitch_sub_tmp
[triggerdelay]
	input = _enter_pitch_sub_tmp
	delay = 0.3
	output = _enter_pitch_sub
[button]
	select = _chan1_sub_off
	button = B2.3
	states = 1
	output = _enter_oct_sub_tmp
[triggerdelay]
	input = _enter_oct_sub_tmp
	delay = 0.3
	output = _enter_oct_sub
[button]
	select = _chan1_pitch_sub_on + _chan1_oct_sub_on
	button = B2.2
	states = 1
	output = _leave_sub_tmp
[triggerdelay]
	input = _leave_sub_tmp
	delay = 0.3
	output = _leave_sub
[flipflop]
	clear = _leave_sub
	set = _enter_pitch_sub + _enter_oct_sub
	output = _sub_on
[copy]
	input = 1 - _sub_on
	output = _sub_off
### menu for pitch pribability per note
[button]
	select = _chan1_pitch_sub_on
	button = B2.8
	output = _pitch_polysel
[copy]
	input = 1 - _pitch_polysel
	output = _pitch_polysel_inv
[buttongroup]
	select = _chan1_pitch_sub_on
	startbutton = 33 # 0 doesn´t work
	clear = _pitch_polysel_inv
	minactive = 0
	maxactive = _pitch_polysel * 11 + 1
	button1 = B1.3 # c
	button2 = B1.2 # cis
	button3 = B1.4 # d
	button4 = B2.1 # dis
	button5 = B2.3 # e
	button6 = B2.4 # f
	button7 = B1.5 # fis
	button8 = B1.7 # g
	button9 = B1.6 # gis
	button10 = B1.8 # a
	button11 = B2.5 # ais
	button12 = B2.7 # h
	buttonoutput1 = _c_prob2pot
	buttonoutput2 = _cis_prob2pot
	buttonoutput3 = _d_prob2pot
	buttonoutput4 = _dis_prob2pot
	buttonoutput5 = _e_prob2pot
	buttonoutput6 = _f_prob2pot
	buttonoutput7 = _fis_prob2pot
	buttonoutput8 = _g_prob2pot
	buttonoutput9 = _gis_prob2pot
	buttonoutput10 = _a_prob2pot
	buttonoutput11 = _ais_prob2pot
	buttonoutput12 = _h_prob2pot
[superjust]
	input1 = 1 - _c_prob2pot
	input2 = 1 - _cis_prob2pot
	input3 = 1 - _d_prob2pot
	input4 = 1 - _dis_prob2pot
	input5 = 1 - _e_prob2pot
	input6 = 1 - _f_prob2pot
	output1 = _c_prob2pot_inv
	output2 = _cis_prob2pot_inv
	output3 = _d_prob2pot_inv
	output4 = _dis_prob2pot_inv
	output5 = _e_prob2pot_inv
	output6 = _f_prob2pot_inv
[superjust]
	input1 = 1 - _fis_prob2pot
	input2 = 1 - _g_prob2pot
	input3 = 1 - _gis_prob2pot
	input4 = 1 - _a_prob2pot
	input5 = 1 - _ais_prob2pot
	input6 = 1 - _h_prob2pot
	output1 = _fis_prob2pot_inv
	output2 = _g_prob2pot_inv
	output3 = _gis_prob2pot_inv
	output4 = _a_prob2pot_inv
	output5 = _ais_prob2pot_inv
	output6 = _h_prob2pot_inv
[superjust]
	input1 = _c_prob2pot * _lfo_sub + _c_prob2pot_inv
	input2 = _cis_prob2pot * _lfo_sub + _cis_prob2pot_inv
	input3 = _d_prob2pot * _lfo_sub + _d_prob2pot_inv
	input4 = _dis_prob2pot * _lfo_sub + _dis_prob2pot_inv
	input5 = _e_prob2pot * _lfo_sub + _e_prob2pot_inv
	input6 = _f_prob2pot * _lfo_sub + _f_prob2pot_inv
	output1 = _c_prob2pot_led
	output2 = _cis_prob2pot_led
	output3 = _d_prob2pot_led
	output4 = _dis_prob2pot_led
	output5 = _e_prob2pot_led
	output6 = _f_prob2pot_led
[superjust]
	input1 = _fis_prob2pot * _lfo_sub + _fis_prob2pot_inv
	input2 = _g_prob2pot * _lfo_sub + _g_prob2pot_inv
	input3 = _gis_prob2pot * _lfo_sub + _gis_prob2pot_inv
	input4 = _a_prob2pot * _lfo_sub + _a_prob2pot_inv
	input5 = _ais_prob2pot * _lfo_sub + _ais_prob2pot_inv
	input6 = _h_prob2pot * _lfo_sub + _h_prob2pot_inv
	output1 = _fis_prob2pot_led
	output2 = _g_prob2pot_led
	output3 = _gis_prob2pot_led
	output4 = _a_prob2pot_led
	output5 = _ais_prob2pot_led
	output6 = _h_prob2pot_led
[superjust]
	input1 = _c_prob2pot_led * _chan1_pitch_sub_on
	input2 = _cis_prob2pot_led * _chan1_pitch_sub_on
	input3 = _d_prob2pot_led * _chan1_pitch_sub_on
	input4 = _dis_prob2pot_led * _chan1_pitch_sub_on
	input5 = _e_prob2pot_led * _chan1_pitch_sub_on
	input6 = _f_prob2pot_led * _chan1_pitch_sub_on
	output1 = _c_prob2pot_led_on
	output2 = _cis_prob2pot_led_on
	output3 = _d_prob2pot_led_on
	output4 = _dis_prob2pot_led_on
	output5 = _e_prob2pot_led_on
	output6 = _f_prob2pot_led_on
[superjust]
	input1 = _fis_prob2pot_led * _chan1_pitch_sub_on
	input2 = _g_prob2pot_led * _chan1_pitch_sub_on
	input3 = _gis_prob2pot_led * _chan1_pitch_sub_on
	input4 = _a_prob2pot_led * _chan1_pitch_sub_on
	input5 = _ais_prob2pot_led * _chan1_pitch_sub_on
	input6 = _h_prob2pot_led * _chan1_pitch_sub_on
	output1 = _fis_prob2pot_led_on
	output2 = _g_prob2pot_led_on
	output3 = _gis_prob2pot_led_on
	output4 = _a_prob2pot_led_on
	output5 = _ais_prob2pot_led_on
	output6 = _h_prob2pot_led_on
### menu for octave bias per note
[button]
	select = _chan1_oct_sub_on
	button = B2.8
	output = _oct_polysel
[copy]
	input = 1 - _oct_polysel
	output = _oct_polysel_inv
[buttongroup]
	select = _chan1_oct_sub_on
	startbutton = 33 # 0 doesn´t work
	clear = _oct_polysel_inv
	minactive = 0
	maxactive = _oct_polysel * 11 + 1
	button1 = B1.3 # c
	button2 = B1.2 # cis
	button3 = B1.4 # d
	button4 = B2.1 # dis
	button5 = B2.3 # e
	button6 = B2.4 # f
	button7 = B1.5 # fis
	button8 = B1.7 # g
	button9 = B1.6 # gis
	button10 = B1.8 # a
	button11 = B2.5 # ais
	button12 = B2.7 # h
	buttonoutput1 = _c_bias2pot
	buttonoutput2 = _cis_bias2pot
	buttonoutput3 = _d_bias2pot
	buttonoutput4 = _dis_bias2pot
	buttonoutput5 = _e_bias2pot
	buttonoutput6 = _f_bias2pot
	buttonoutput7 = _fis_bias2pot
	buttonoutput8 = _g_bias2pot
	buttonoutput9 = _gis_bias2pot
	buttonoutput10 = _a_bias2pot
	buttonoutput11 = _ais_bias2pot
	buttonoutput12 = _h_bias2pot
[superjust]
	input1 = 1 - _c_bias2pot
	input2 = 1 - _cis_bias2pot
	input3 = 1 - _d_bias2pot
	input4 = 1 - _dis_bias2pot
	input5 = 1 - _e_bias2pot
	input6 = 1 - _f_bias2pot
	output1 = _c_bias2pot_inv
	output2 = _cis_bias2pot_inv
	output3 = _d_bias2pot_inv
	output4 = _dis_bias2pot_inv
	output5 = _e_bias2pot_inv
	output6 = _f_bias2pot_inv
[superjust]
	input1 = 1 - _fis_bias2pot
	input2 = 1 - _g_bias2pot
	input3 = 1 - _gis_bias2pot
	input4 = 1 - _a_bias2pot
	input5 = 1 - _ais_bias2pot
	input6 = 1 - _h_bias2pot
	output1 = _fis_bias2pot_inv
	output2 = _g_bias2pot_inv
	output3 = _gis_bias2pot_inv
	output4 = _a_bias2pot_inv
	output5 = _ais_bias2pot_inv
	output6 = _h_bias2pot_inv
[superjust]
	input1 = _c_bias2pot * _lfo_sub + _c_bias2pot_inv
	input2 = _cis_bias2pot * _lfo_sub + _cis_bias2pot_inv
	input3 = _d_bias2pot * _lfo_sub + _d_bias2pot_inv
	input4 = _dis_bias2pot * _lfo_sub + _dis_bias2pot_inv
	input5 = _e_bias2pot * _lfo_sub + _e_bias2pot_inv
	input6 = _f_bias2pot * _lfo_sub + _f_bias2pot_inv
	output1 = _c_bias2pot_led
	output2 = _cis_bias2pot_led
	output3 = _d_bias2pot_led
	output4 = _dis_bias2pot_led
	output5 = _e_bias2pot_led
	output6 = _f_bias2pot_led
[superjust]
	input1 = _fis_bias2pot * _lfo_sub + _fis_bias2pot_inv
	input2 = _g_bias2pot * _lfo_sub + _g_bias2pot_inv
	input3 = _gis_bias2pot * _lfo_sub + _gis_bias2pot_inv
	input4 = _a_bias2pot * _lfo_sub + _a_bias2pot_inv
	input5 = _ais_bias2pot * _lfo_sub + _ais_bias2pot_inv
	input6 = _h_bias2pot * _lfo_sub + _h_bias2pot_inv
	output1 = _fis_bias2pot_led
	output2 = _g_bias2pot_led
	output3 = _gis_bias2pot_led
	output4 = _a_bias2pot_led
	output5 = _ais_bias2pot_led
	output6 = _h_bias2pot_led
[superjust]
	input1 = _c_bias2pot_led * _chan1_oct_sub_on
	input2 = _cis_bias2pot_led * _chan1_oct_sub_on
	input3 = _d_bias2pot_led * _chan1_oct_sub_on
	input4 = _dis_bias2pot_led * _chan1_oct_sub_on
	input5 = _e_bias2pot_led * _chan1_oct_sub_on
	input6 = _f_bias2pot_led * _chan1_oct_sub_on
	output1 = _c_bias2pot_led_on
	output2 = _cis_bias2pot_led_on
	output3 = _d_bias2pot_led_on
	output4 = _dis_bias2pot_led_on
	output5 = _e_bias2pot_led_on
	output6 = _f_bias2pot_led_on
[superjust]
	input1 = _fis_bias2pot_led * _chan1_oct_sub_on
	input2 = _g_bias2pot_led * _chan1_oct_sub_on
	input3 = _gis_bias2pot_led * _chan1_oct_sub_on
	input4 = _a_bias2pot_led * _chan1_oct_sub_on
	input5 = _ais_bias2pot_led * _chan1_oct_sub_on
	input6 = _h_bias2pot_led * _chan1_oct_sub_on
	output1 = _fis_bias2pot_led_on
	output2 = _g_bias2pot_led_on
	output3 = _gis_bias2pot_led_on
	output4 = _a_bias2pot_led_on
	output5 = _ais_bias2pot_led_on
	output6 = _h_bias2pot_led_on
# solo buttons
[button]
	button = B2.8
	select = _menu3
	states = 1
	led = _solo_led
	output = _soloplay
[flipflop]
	clear = _soloplay_init
	set = _soloplay
	output = _soloplay_trig # short trigger lasting only 1 internal patch cycle. This minimizes conflicts with the usual probabilities for note selection.
[copy]
	input = _soloplay_trig
	output = _soloplay_init
[copy]
	input = 1 - _soloplay_trig
	output = _soloplay_trig_inv
[button]
	button = B2.1
	select = _menu3
	states = 1
	output = _assign1_gate
[button]
	button = B2.2
	select = _menu3
	states = 1
	output = _assign2_gate
[button]
	button = B2.3
	select = _menu3
	states = 1
	output = _assign3_gate
[button]
	button = B2.4
	select = _menu3
	states = 1
	output = _assign4_gate
[button]
	button = B2.5
	select = _menu3
	states = 1
	output = _assign5_gate
[button]
	button = B2.6
	select = _menu3
	states = 1
	output = _assign6_gate
[button]
	button = B2.7
	select = _menu3
	states = 1
	output = _assign7_gate
[mixer]
	input1 = _assign1_gate
	input2 = _assign2_gate
	input3 = _assign3_gate
	input4 = _assign4_gate
	input5 = _assign5_gate
	input6 = _assign6_gate
	input7 = _assign7_gate
	maximum = _gate_assign
[copy]
	input = 1 - _gate_assign
	output = _gate_assign_inv
[copy]
	input = _soloplay + _gate_assign
	output = _soloplay_any
[pot]
	pot = P3.1
	select = _menu3 * _assign1_gate
	discrete = 12
	outputscale = 0.1/12
	output = _assign1_pitch
[pot]
	pot = P3.1
	select = _menu3 * _assign2_gate
	discrete = 12
	outputscale = 0.1/12
	output = _assign2_pitch
[pot]
	pot = P3.1
	select = _menu3 * _assign3_gate
	discrete = 12
	outputscale = 0.1/12
	output = _assign3_pitch
[pot]
	pot = P3.1
	select = _menu3 * _assign4_gate
	discrete = 12
	outputscale = 0.1/12
	output = _assign4_pitch
[pot]
	pot = P3.1
	select = _menu3 * _assign5_gate
	discrete = 12
	outputscale = 0.1/12
	output = _assign5_pitch
[pot]
	pot = P3.1
	select = _menu3 * _assign6_gate
	discrete = 12
	outputscale = 0.1/12
	output = _assign6_pitch
[pot]
	pot = P3.1
	select = _menu3 * _assign7_gate
	discrete = 12
	outputscale = 0.1/12
	output = _assign7_pitch
[mixer]
	input1 = _assign1_pitch * _assign1_gate
	input2 = _assign2_pitch * _assign2_gate
	input3 = _assign3_pitch * _assign3_gate
	input4 = _assign4_pitch * _assign4_gate
	input5 = _assign5_pitch * _assign5_gate
	input6 = _assign6_pitch * _assign6_gate
	input7 = _assign7_pitch * _assign7_gate
	output = _pitch_assign_oct1
# determine octave for assign buttons
[copy]
	input = _pitch_assign_oct1 + 0.1
	output = _pitch_assign_oct2
[copy]
	input = _pitch_assign_oct1 + 0.2
	output = _pitch_assign_oct3
[math]
	input = _pitch_assign_oct1 + _solo_center_neg
	amount = _pitch_assign_diff1
[math]
	input = _pitch_assign_oct2 + _solo_center_neg
	amount = _pitch_assign_diff2
[math]
	input = _pitch_assign_oct3 + _solo_center_neg
	amount = _pitch_assign_diff3
[compare]
	input = 0.1/12 + _pitch_assign_diff1
	compare = _pitch_assign_diff2
	ifless = 1
	output = _pitch_assign_near1
[compare]
	input = 0.1/12 + _pitch_assign_diff2
	compare = _pitch_assign_diff3
	ifless = 1 - _pitch_assign_near1
	output = _pitch_assign_near2
[logic]
	input1 = 1 - _pitch_assign_near1
	input2 = 1 - _pitch_assign_near2
	and = _pitch_assign_near3
[mixer]
	input1 = _pitch_assign_oct1 * _pitch_assign_near1 + 0.3 # output range 3V-6V
	input2 = _pitch_assign_oct2 * _pitch_assign_near2
	input3 = _pitch_assign_oct3 * _pitch_assign_near3
	output = _pitch_assign_tmp
[copy]
	input = _pitch_assign_tmp * _gate_assign
	output = _pitch_assign
### menu 1 (menu 1 in description pdf)
[button]
	button = B2.1
	select = _menu1
	states = 1
	output = _mute_toggle
[button]
	button = B2.2
	select = _menu1
	states = 1
	output = _unmute
[button]
	button = B2.3
	select = _menu1
	states = 1
	output = _mute2_toggle
[button]
	button = B2.4
	select = _menu1
	states = 1
	output = _unmute2
### menu 2 (menu 3 in description pdf)
[buttongroup]
	select = _menu2
	preset = _preset
	loadpreset = _load
	savepreset = _save
	button1 = B2.1
	button2 = B2.3
	button3 = B2.5
	button4 = B2.7
	led1 = _fillorder_0
	led2 = _fillorder_1
	led3 = _fillorder_2
	led4 = _fillorder_3
	value1 = 0
	value2 = 1
	value3 = 2
	value4 = 3
	output = _fillorder
[buttongroup]
	select = _menu2
	preset = _preset
	loadpreset = _load
	savepreset = _save
	button1 = B2.2
	button2 = B2.4
	button3 = B2.6
	button4 = B2.8
	led1 = _branches_0
	led2 = _branches_1
	led3 = _branches_2
	led4 = _branches_3
	value1 = 0
	value2 = 1
	value3 = 2
	value4 = 3
	output = _algo1_branches

### LED management
[superjust]
	input1 = _c_prob_pot * 0.98 + 0.02 # scale output to 0.02-1 for dimmed leds
	input2 = _cis_prob_pot * 0.98 + 0.02
	input3 = _d_prob_pot * 0.98 + 0.02
	input4 = _dis_prob_pot * 0.98 + 0.02
	input5 = _e_prob_pot * 0.98 + 0.02
	input6 = _f_prob_pot * 0.98 + 0.02
	output1 = _c_prob_pot_led
	output2 = _cis_prob_pot_led
	output3 = _d_prob_pot_led
	output4 = _dis_prob_pot_led
	output5 = _e_prob_pot_led
	output6 = _f_prob_pot_led
[superjust]
	input1 = _fis_prob_pot * 0.98 + 0.02
	input2 = _g_prob_pot * 0.98 + 0.02
	input3 = _gis_prob_pot * 0.98 + 0.02
	input4 = _a_prob_pot * 0.98 + 0.02
	input5 = _ais_prob_pot * 0.98 + 0.02
	input6 = _h_prob_pot * 0.98 + 0.02
	output1 = _fis_prob_pot_led
	output2 = _g_prob_pot_led
	output3 = _gis_prob_pot_led
	output4 = _a_prob_pot_led
	output5 = _ais_prob_pot_led
	output6 = _h_prob_pot_led
[superjust]
	input1 = _c_bias_pot * 0.327 + 0.02 # for 4-state leds: 0.98/3=0.32666)
	input2 = _cis_bias_pot * 0.327 + 0.02
	input3 = _d_bias_pot * 0.327 + 0.02
	input4 = _dis_bias_pot * 0.327 + 0.02
	input5 = _e_bias_pot * 0.327 + 0.02
	input6 = _f_bias_pot * 0.327 + 0.02
	output1 = _c_bias_pot_led
	output2 = _cis_bias_pot_led
	output3 = _d_bias_pot_led
	output4 = _dis_bias_pot_led
	output5 = _e_bias_pot_led
	output6 = _f_bias_pot_led
[superjust]
	input1 = _fis_bias_pot * 0.327 + 0.02
	input2 = _g_bias_pot * 0.327 + 0.02
	input3 = _gis_bias_pot * 0.327 + 0.02
	input4 = _a_bias_pot * 0.327 + 0.02
	input5 = _ais_bias_pot * 0.327 + 0.02
	input6 = _h_bias_pot * 0.327 + 0.02
	output1 = _fis_bias_pot_led
	output2 = _g_bias_pot_led
	output3 = _gis_bias_pot_led
	output4 = _a_bias_pot_led
	output5 = _ais_bias_pot_led
	output6 = _h_bias_pot_led
[copy]
	input = _menu1
	output = L1.1
[mixer]
	input1 = _chan1 * _sub_off
	input2 = _cis_prob2pot_led_on * _cis_prob_pot_led
	input3 = _cis_bias2pot_led_on * _cis_bias_pot_led
	input4 = _barled1 * _sub_off
	output = L1.2
[mixer]
	input1 = _menu2
	input2 = _c_prob2pot_led_on * _c_prob_pot_led
	input3 = _c_bias2pot_led_on * _c_bias_pot_led
	output = L1.3
[mixer]
	input1 = _d_prob2pot_led_on * _d_prob_pot_led
	input2 = _d_bias2pot_led_on * _d_bias_pot_led
	input3 = _barled2 * _sub_off
	output = L1.4
[mixer]
	input1 = _menu3
	input2 = _fis_prob2pot_led_on * _fis_prob_pot_led
	input3 = _fis_bias2pot_led_on * _fis_bias_pot_led
	output = L1.5
[mixer]
	input1 = _gis_prob2pot_led_on * _gis_prob_pot_led
	input2 = _gis_bias2pot_led_on * _gis_bias_pot_led
	input3 = _barled3 * _sub_off
	output = L1.6
[mixer]
	input1 = _g_prob2pot_led_on * _g_prob_pot_led
	input2 = _g_bias2pot_led_on * _g_bias_pot_led
	input3 = _menu4
	output = L1.7
[mixer]
	input1 = _a_prob2pot_led_on * _a_prob_pot_led
	input2 = _a_bias2pot_led_on * _a_bias_pot_led
	input3 = _barled4 * _sub_off
	output = L1.8
[mixer]
	input1 = _pitch_calc * _chan1_sub_off
	input2 = _fillorder_0 * _menu2
	input3 = _dis_prob2pot_led_on * _dis_prob_pot_led
	input4 = _dis_bias2pot_led_on * _dis_bias_pot_led
	input5 = _menu1 * _muteled
	input6 = _assign1_gate
	input7 = _menu4_L21 * _load_queue_dim + _save_blink0
	output = L2.1
[mixer]
	input1 = _notelength_calc * _chan1_sub_off
	input2 = _branches_0 * _menu2
	input3 = _menu1 * _unmuteled
	input4 = _assign2_gate
	input5 = _menu4_L22 * _load_queue_dim + _save_blink1
	output = L2.2
[mixer]
	input1 = _oct_calc * _chan1_sub_off
	input2 = _fillorder_1 * _menu2
	input3 = _e_prob2pot_led_on * _e_prob_pot_led
	input4 = _e_bias2pot_led_on * _e_bias_pot_led
	input5 = _menu1 * _muteled2
	input6 = _assign3_gate
	input7 = _menu4_L23 * _load_queue_dim + _save_blink2
	output = L2.3
[mixer]
	input1 = _cont * _chan1_sub_off
	input2 = _branches_1 * _menu2
	input3 = _f_prob2pot_led_on * _f_prob_pot_led
	input4 = _f_bias2pot_led_on * _f_bias_pot_led
	input5 = _menu1 * _unmuteled2
	input6 = _assign4_gate
	input7 = _menu4_L24 * _load_queue_dim + _save_blink3
	output = L2.4
[mixer]
	input1 = _pitch_new_queue_dim * _chan1_sub_off
	input2 = _fillorder_2 * _menu2
	input3 = _ais_prob2pot_led_on * _ais_prob_pot_led
	input4 = _ais_bias2pot_led_on * _ais_bias_pot_led
	input5 = _assign5_gate
	input6 = _menu4_L25 * _load_queue_dim + _save_blink4
	input7 = _menu1 * _set_transp_down
	output = L2.5
[mixer]
	input1 = _pattern_new_queue_dim * _chan1_sub_off
	input2 = _branches_2 * _menu2
	input3 = _assign6_gate
	input4 = _menu4_L26 * _load_queue_dim + _save_blink5
	input5 = _menu1 * _set_transp_up
	output = L2.6
[mixer]
	input1 = _assign7_gate
	input2 = _fillorder_3 * _menu2
	input3 = _h_prob2pot_led_on * _h_prob_pot_led
	input4 = _h_bias2pot_led_on * _h_bias_pot_led
	input5 = _menu1 * _set_length1
	input6 = _pitch2_new_queue_dim * _chan1_sub_off
	input7 = _menu4_L27 * _load_queue_dim + _save_blink6
	output = L2.7
[mixer]
	input1 = _solo_led
	input2 = _branches_3 * _menu2
	input3 = _pitch_polysel * _chan1_pitch_sub_on
	input4 = _menu1 * _set_length2
	input5 = _pattern2_new_queue_dim * _chan1_sub_off
	input6 = _menu4_L28 * _load_queue_dim + _save_blink7
	input7 = _oct_polysel * _chan1_oct_sub_on
	output = L2.8
### menu 1 fuctions
# algo1 length
[triggerdelay]
	clock = _clock
	input = _load # _load trigger is already delayed by 0.25 duty cycle
	delay = 0.5
	output = _load_del
[button]
	button = B2.7
	select = _menu1
	states = 1
	negated = _set_length1_inv
	output = _set_length1
[pot]
	pot = P2.2
	select = _menu1 * _set_length1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	discrete = 16
	output = _algo1_length_pot
[sample]
	input = _algo1_length_pot + 1
	sample = _set_length1_inv * _step16_del + _load_del
	output = _algo1_length
# algo2 length
[button]
	button = B2.8
	select = _menu1
	states = 1
	negated = _set_length2_inv
	output = _set_length2
[pot]
	pot = P2.2
	select = _menu1 * _set_length2
	preset = _preset
	loadpreset = _load
	savepreset = _save
	discrete = 16
	output = _algo2_length_pot
[sample]
	input = _algo2_length_pot + 1
	sample = _set_length2_inv * _step16_del + _load_del
	output = _algo2_length

# toggle between free/loop modes for pitches and patterns only at the end of a bar
# pitch channel 1
[triggerdelay]
	clock = _clock_ext
	input = _step16
	delay = 0.5
	output = _step16_del
[triggerdelay]
	clock = _clock_ext
	input = _step16
	delay = 0.25
	output = _step16_load
[flipflop]
	clear = _pitch_new
	set = _pitch_new_ini
	output = _pitch_new_pass
[superjust]
	bypass = 1
	input1 = _pitch_new_pass * _step16_del
	output1 = _pitch_new
	input2 = _pitch_new_pass * 0.9
	output2 = _pitch_new_queue
	input3 = _pitch_new_ini - _pitch_new_queue
	output3 = _pitch_new_queue_dim
	input4 = 1 - _pitch_new_ini
	output4 = _pitch_new_ini_inv
[compare]
	input = _pitch_new_ini * _pitch_new_queue_dim
	compare = 1
	ifequal = 1
	output = _pitch_new_apply_tmp
[flipflop]
	clear = _pitch_new_ini_inv * _step16_del
	set = _pitch_new_apply_tmp
	output = _pitch_new_apply
[copy]
	input = _clock_ext * _pitch_new_apply
	output = _pitch_trig
# pitch channel 2
[flipflop]
	clear = _pitch2_new
	set = _pitch2_new_ini
	output = _pitch2_new_pass
[superjust]
	bypass = 1
	input1 = _pitch2_new_pass * _step16_del
	output1 = _pitch2_new
	input2 = _pitch2_new_pass * 0.9
	output2 = _pitch2_new_queue
	input3 = _pitch2_new_ini - _pitch2_new_queue
	output3 = _pitch2_new_queue_dim
	input4 = 1 - _pitch2_new_ini
	output4 = _pitch2_new_ini_inv
[compare]
	input = _pitch2_new_ini * _pitch2_new_queue_dim
	compare = 1
	ifequal = 1
	output = _pitch2_new_apply_tmp
[flipflop]
	clear = _pitch2_new_ini_inv * _step16_del
	set = _pitch2_new_apply_tmp
	output = _pitch2_new_apply
[copy]
	input = _clock_ext * _pitch2_new_apply
	output = _pitch2_trig
# merge pitch triggers to be sent to algorithm
[mixer]
	input1 = _pitch_trig
	input2 = _pitch2_trig
	maximum = _pitch_trig_any
# pattern channel 1
[flipflop]
	clear = _pattern_new
	set = _pattern_new_ini
	output = _pattern_new_pass
[superjust]
	bypass = 1
	input1 = _pattern_new_pass * _step16_del
	output1 = _pattern_new
	input2 = _pattern_new_pass * 0.9
	output2 = _pattern_new_queue
	input3 = _pattern_new_ini - _pattern_new_queue
	output3 = _pattern_new_queue_dim
	input4 = 1 - _pattern_new_ini
	output4 = _pattern_new_ini_inv
[compare]
	input = _pattern_new_ini * _pattern_new_queue_dim
	compare = 1
	ifequal = 1
	output = _pattern_new_apply_tmp
[flipflop]
	clear = _pattern_new_ini_inv * _step16_del
	set = _pattern_new_apply_tmp
	output = _pattern_new_apply
# pattern channel 2
[flipflop]
	clear = _pattern2_new
	set = _pattern2_new_ini
	output = _pattern2_new_pass
[superjust]
	bypass = 1
	input1 = _pattern2_new_pass * _step16_del
	output1 = _pattern2_new
	input2 = _pattern2_new_pass * 0.9
	output2 = _pattern2_new_queue
	input3 = _pattern2_new_ini - _pattern2_new_queue
	output3 = _pattern2_new_queue_dim
	input4 = 1 - _pattern2_new_ini
	output4 = _pattern2_new_ini_inv
[compare]
	input = _pattern2_new_ini * _pattern2_new_queue_dim
	compare = 1
	ifequal = 1
	output = _pattern2_new_apply_tmp
[flipflop]
	clear = _pattern2_new_ini_inv * _step16_del
	set = _pattern2_new_apply_tmp
	output = _pattern2_new_apply
# triggers for selection of pattern and note duration
[superjust]
	input1 = _step1 * _pattern_new_apply
	output1 = _pattern_trig
	input2 = _clock_ext * _pattern_new_apply
	output2 = _notelength_trig
	input3 = _step1 * _pattern2_new_apply
	output3 = _pattern2_trig
	input4 = _clock_ext * _pattern2_new_apply
	output4 = _notelength2_trig
[mixer]
	input1 = _notelength_trig
	input2 = _notelength2_trig
	maximum = _notelength_trig_any
### pitch selection for solo mode
# select center pitch for solo over a range over 3 octaves (c to c) = 3x12+1 = 25 semitones
[pot]
	pot = P1.1
	select = _menu3
	outputscale = 0.3 # solo center ranges over 3 octaves
	output = _solo_center
[pot]
	pot = P2.1
	select = _menu3
	discrete = 11
	output = _solo_spread_pot
[copy]
	input = _solo_spread_pot + 1
	output = _solo_spread
[copy]
	input = _solo_center * -1
	output = _solo_center_neg
# C solo
[math]
	input = 0.0/12 + _solo_center_neg
	amount = _c1_diff_tmp
[compare]
	input = _c1_diff_tmp * 100
	compare = _solo_spread
	ifless = _c1_diff_tmp * 100
	else = _solo_spread
	output = _c1_diff
[math]
	input1 = _solo_spread - _c1_diff
	input2 = _solo_spread
	quotient = _c1_prob_fac
[math]
	input = 1.2/12 + _solo_center_neg
	amount = _c2_diff_tmp
[compare]
	input = _c2_diff_tmp * 100
	compare = _solo_spread
	ifless = _c2_diff_tmp * 100
	else = _solo_spread
	output = _c2_diff
[math]
	input1 = _solo_spread - _c2_diff
	input2 = _solo_spread
	quotient = _c2_prob_fac
[math]
	input = 2.4/12 + _solo_center_neg
	amount = _c3_diff_tmp
[compare]
	input = _c3_diff_tmp * 100
	compare = _solo_spread
	ifless = _c3_diff_tmp * 100
	else = _solo_spread
	output = _c3_diff
[math]
	input1 = _solo_spread - _c3_diff
	input2 = _solo_spread
	quotient = _c3_prob_fac
[math]
	input = 3.6/12 + _solo_center_neg
	amount = _c4_diff_tmp
[compare]
	input = _c4_diff_tmp * 100
	compare = _solo_spread
	ifless = _c4_diff_tmp * 100
	else = _solo_spread
	output = _c4_diff
[math]
	input1 = _solo_spread - _c4_diff
	input2 = _solo_spread
	quotient = _c4_prob_fac
[mixer]
	input1 = _c1_prob_fac * _soloplay_trig + _soloplay_trig_inv
	input2 = _c2_prob_fac * _soloplay_trig
	input3 = _c3_prob_fac * _soloplay_trig
	input4 = _c4_prob_fac * _soloplay_trig
	output = _c_prob_fac
# CIS solo
[math]
	input = 0.1/12 + _solo_center_neg
	amount = _cis1_diff_tmp
[compare]
	input = _cis1_diff_tmp * 100
	compare = _solo_spread
	ifless = _cis1_diff_tmp * 100
	else = _solo_spread
	output = _cis1_diff
[math]
	input1 = _solo_spread - _cis1_diff
	input2 = _solo_spread
	quotient = _cis1_prob_fac
[math]
	input = 1.3/12 + _solo_center_neg
	amount = _cis2_diff_tmp
[compare]
	input = _cis2_diff_tmp * 100
	compare = _solo_spread
	ifless = _cis2_diff_tmp * 100
	else = _solo_spread
	output = _cis2_diff
[math]
	input1 = _solo_spread - _cis2_diff
	input2 = _solo_spread
	quotient = _cis2_prob_fac
[math]
	input = 2.5/12 + _solo_center_neg
	amount = _cis3_diff_tmp
[compare]
	input = _cis3_diff_tmp * 100
	compare = _solo_spread
	ifless = _cis3_diff_tmp * 100
	else = _solo_spread
	output = _cis3_diff
[math]
	input1 = _solo_spread - _cis3_diff
	input2 = _solo_spread
	quotient = _cis3_prob_fac
[mixer]
	input1 = _cis1_prob_fac * _soloplay_trig + _soloplay_trig_inv
	input2 = _cis2_prob_fac * _soloplay_trig
	input3 = _cis3_prob_fac * _soloplay_trig
	output = _cis_prob_fac
# D solo
[math]
	input = 0.2/12 + _solo_center_neg
	amount = _d1_diff_tmp
[compare]
	input = _d1_diff_tmp * 100
	compare = _solo_spread
	ifless = _d1_diff_tmp * 100
	else = _solo_spread
	output = _d1_diff
[math]
	input1 = _solo_spread - _d1_diff
	input2 = _solo_spread
	quotient = _d1_prob_fac
[math]
	input = 1.4/12 + _solo_center_neg
	amount = _d2_diff_tmp
[compare]
	input = _d2_diff_tmp * 100
	compare = _solo_spread
	ifless = _d2_diff_tmp * 100
	else = _solo_spread
	output = _d2_diff
[math]
	input1 = _solo_spread - _d2_diff
	input2 = _solo_spread
	quotient = _d2_prob_fac
[math]
	input = 2.6/12 + _solo_center_neg
	amount = _d3_diff_tmp
[compare]
	input = _d3_diff_tmp * 100
	compare = _solo_spread
	ifless = _d3_diff_tmp * 100
	else = _solo_spread
	output = _d3_diff
[math]
	input1 = _solo_spread - _d3_diff
	input2 = _solo_spread
	quotient = _d3_prob_fac
[mixer]
	input1 = _d1_prob_fac * _soloplay_trig + _soloplay_trig_inv
	input2 = _d2_prob_fac * _soloplay_trig
	input3 = _d3_prob_fac * _soloplay_trig
	output = _d_prob_fac
# DIS solo
[math]
	input = 0.3/12 + _solo_center_neg
	amount = _dis1_diff_tmp
[compare]
	input = _dis1_diff_tmp * 100
	compare = _solo_spread
	ifless = _dis1_diff_tmp * 100
	else = _solo_spread
	output = _dis1_diff
[math]
	input1 = _solo_spread - _dis1_diff
	input2 = _solo_spread
	quotient = _dis1_prob_fac
[math]
	input = 1.5/12 + _solo_center_neg
	amount = _dis2_diff_tmp
[compare]
	input = _dis2_diff_tmp * 100
	compare = _solo_spread
	ifless = _dis2_diff_tmp * 100
	else = _solo_spread
	output = _dis2_diff
[math]
	input1 = _solo_spread - _dis2_diff
	input2 = _solo_spread
	quotient = _dis2_prob_fac
[math]
	input = 2.7/12 + _solo_center_neg
	amount = _dis3_diff_tmp
[compare]
	input = _dis3_diff_tmp * 100
	compare = _solo_spread
	ifless = _dis3_diff_tmp * 100
	else = _solo_spread
	output = _dis3_diff
[math]
	input1 = _solo_spread - _dis3_diff
	input2 = _solo_spread
	quotient = _dis3_prob_fac
[mixer]
	input1 = _dis1_prob_fac * _soloplay_trig + _soloplay_trig_inv
	input2 = _dis2_prob_fac * _soloplay_trig
	input3 = _dis3_prob_fac * _soloplay_trig
	output = _dis_prob_fac
# E solo
[math]
	input = 0.4/12 + _solo_center_neg
	amount = _e1_diff_tmp
[compare]
	input = _e1_diff_tmp * 100
	compare = _solo_spread
	ifless = _e1_diff_tmp * 100
	else = _solo_spread
	output = _e1_diff
[math]
	input1 = _solo_spread - _e1_diff
	input2 = _solo_spread
	quotient = _e1_prob_fac
[math]
	input = 1.6/12 + _solo_center_neg
	amount = _e2_diff_tmp
[compare]
	input = _e2_diff_tmp * 100
	compare = _solo_spread
	ifless = _e2_diff_tmp * 100
	else = _solo_spread
	output = _e2_diff
[math]
	input1 = _solo_spread - _e2_diff
	input2 = _solo_spread
	quotient = _e2_prob_fac
[math]
	input = 2.8/12 + _solo_center_neg
	amount = _e3_diff_tmp
[compare]
	input = _e3_diff_tmp * 100
	compare = _solo_spread
	ifless = _e3_diff_tmp * 100
	else = _solo_spread
	output = _e3_diff
[math]
	input1 = _solo_spread - _e3_diff
	input2 = _solo_spread
	quotient = _e3_prob_fac
[mixer]
	input1 = _e1_prob_fac * _soloplay_trig + _soloplay_trig_inv
	input2 = _e2_prob_fac * _soloplay_trig
	input3 = _e3_prob_fac * _soloplay_trig
	output = _e_prob_fac
# F solo
[math]
	input = 0.5/12 + _solo_center_neg
	amount = _f1_diff_tmp
[compare]
	input = _f1_diff_tmp * 100
	compare = _solo_spread
	ifless = _f1_diff_tmp * 100
	else = _solo_spread
	output = _f1_diff
[math]
	input1 = _solo_spread - _f1_diff
	input2 = _solo_spread
	quotient = _f1_prob_fac
[math]
	input = 1.7/12 + _solo_center_neg
	amount = _f2_diff_tmp
[compare]
	input = _f2_diff_tmp * 100
	compare = _solo_spread
	ifless = _f2_diff_tmp * 100
	else = _solo_spread
	output = _f2_diff
[math]
	input1 = _solo_spread - _f2_diff
	input2 = _solo_spread
	quotient = _f2_prob_fac
[math]
	input = 2.9/12 + _solo_center_neg
	amount = _f3_diff_tmp
[compare]
	input = _f3_diff_tmp * 100
	compare = _solo_spread
	ifless = _f3_diff_tmp * 100
	else = _solo_spread
	output = _f3_diff
[math]
	input1 = _solo_spread - _f3_diff
	input2 = _solo_spread
	quotient = _f3_prob_fac
[mixer]
	input1 = _f1_prob_fac * _soloplay_trig + _soloplay_trig_inv
	input2 = _f2_prob_fac * _soloplay_trig
	input3 = _f3_prob_fac * _soloplay_trig
	output = _f_prob_fac
# FIS solo
[math]
	input = 0.6/12 + _solo_center_neg
	amount = _fis1_diff_tmp
[compare]
	input = _fis1_diff_tmp * 100
	compare = _solo_spread
	ifless = _fis1_diff_tmp * 100
	else = _solo_spread
	output = _fis1_diff
[math]
	input1 = _solo_spread - _fis1_diff
	input2 = _solo_spread
	quotient = _fis1_prob_fac
[math]
	input = 1.8/12 + _solo_center_neg
	amount = _fis2_diff_tmp
[compare]
	input = _fis2_diff_tmp * 100
	compare = _solo_spread
	ifless = _fis2_diff_tmp * 100
	else = _solo_spread
	output = _fis2_diff
[math]
	input1 = _solo_spread - _fis2_diff
	input2 = _solo_spread
	quotient = _fis2_prob_fac
[math]
	input = 3.0/12 + _solo_center_neg
	amount = _fis3_diff_tmp
[compare]
	input = _fis3_diff_tmp * 100
	compare = _solo_spread
	ifless = _fis3_diff_tmp * 100
	else = _solo_spread
	output = _fis3_diff
[math]
	input1 = _solo_spread - _fis3_diff
	input2 = _solo_spread
	quotient = _fis3_prob_fac
[mixer]
	input1 = _fis1_prob_fac * _soloplay_trig + _soloplay_trig_inv
	input2 = _fis2_prob_fac * _soloplay_trig
	input3 = _fis3_prob_fac * _soloplay_trig
	output = _fis_prob_fac
# G solo
[math]
	input = 0.7/12 + _solo_center_neg
	amount = _g1_diff_tmp
[compare]
	input = _g1_diff_tmp * 100
	compare = _solo_spread
	ifless = _g1_diff_tmp * 100
	else = _solo_spread
	output = _g1_diff
[math]
	input1 = _solo_spread - _g1_diff
	input2 = _solo_spread
	quotient = _g1_prob_fac
[math]
	input = 1.9/12 + _solo_center_neg
	amount = _g2_diff_tmp
[compare]
	input = _g2_diff_tmp * 100
	compare = _solo_spread
	ifless = _g2_diff_tmp * 100
	else = _solo_spread
	output = _g2_diff
[math]
	input1 = _solo_spread - _g2_diff
	input2 = _solo_spread
	quotient = _g2_prob_fac
[math]
	input = 3.1/12 + _solo_center_neg
	amount = _g3_diff_tmp
[compare]
	input = _g3_diff_tmp * 100
	compare = _solo_spread
	ifless = _g3_diff_tmp * 100
	else = _solo_spread
	output = _g3_diff
[math]
	input1 = _solo_spread - _g3_diff
	input2 = _solo_spread
	quotient = _g3_prob_fac
[mixer]
	input1 = _g1_prob_fac * _soloplay_trig + _soloplay_trig_inv
	input2 = _g2_prob_fac * _soloplay_trig
	input3 = _g3_prob_fac * _soloplay_trig
	output = _g_prob_fac
# GIS solo
[math]
	input = 0.8/12 + _solo_center_neg
	amount = _gis1_diff_tmp
[compare]
	input = _gis1_diff_tmp * 100
	compare = _solo_spread
	ifless = _gis1_diff_tmp * 100
	else = _solo_spread
	output = _gis1_diff
[math]
	input1 = _solo_spread - _gis1_diff
	input2 = _solo_spread
	quotient = _gis1_prob_fac
[math]
	input = 2.0/12 + _solo_center_neg
	amount = _gis2_diff_tmp
[compare]
	input = _gis2_diff_tmp * 100
	compare = _solo_spread
	ifless = _gis2_diff_tmp * 100
	else = _solo_spread
	output = _gis2_diff
[math]
	input1 = _solo_spread - _gis2_diff
	input2 = _solo_spread
	quotient = _gis2_prob_fac
[math]
	input = 3.2/12 + _solo_center_neg
	amount = _gis3_diff_tmp
[compare]
	input = _gis3_diff_tmp * 100
	compare = _solo_spread
	ifless = _gis3_diff_tmp * 100
	else = _solo_spread
	output = _gis3_diff
[math]
	input1 = _solo_spread - _gis3_diff
	input2 = _solo_spread
	quotient = _gis3_prob_fac
[mixer]
	input1 = _gis1_prob_fac * _soloplay_trig + _soloplay_trig_inv
	input2 = _gis2_prob_fac * _soloplay_trig
	input3 = _gis3_prob_fac * _soloplay_trig
	output = _gis_prob_fac
# A solo
[math]
	input = 0.9/12 + _solo_center_neg
	amount = _a1_diff_tmp
[compare]
	input = _a1_diff_tmp * 100
	compare = _solo_spread
	ifless = _a1_diff_tmp * 100
	else = _solo_spread
	output = _a1_diff
[math]
	input1 = _solo_spread - _a1_diff
	input2 = _solo_spread
	quotient = _a1_prob_fac
[math]
	input = 2.1/12 + _solo_center_neg
	amount = _a2_diff_tmp
[compare]
	input = _a2_diff_tmp * 100
	compare = _solo_spread
	ifless = _a2_diff_tmp * 100
	else = _solo_spread
	output = _a2_diff
[math]
	input1 = _solo_spread - _a2_diff
	input2 = _solo_spread
	quotient = _a2_prob_fac
[math]
	input = 3.3/12 + _solo_center_neg
	amount = _a3_diff_tmp
[compare]
	input = _a3_diff_tmp * 100
	compare = _solo_spread
	ifless = _a3_diff_tmp * 100
	else = _solo_spread
	output = _a3_diff
[math]
	input1 = _solo_spread - _a3_diff
	input2 = _solo_spread
	quotient = _a3_prob_fac
[mixer]
	input1 = _a1_prob_fac * _soloplay_trig + _soloplay_trig_inv
	input2 = _a2_prob_fac * _soloplay_trig
	input3 = _a3_prob_fac * _soloplay_trig
	output = _a_prob_fac
# AIS solo
[math]
	input = 1.0/12 + _solo_center_neg
	amount = _ais1_diff_tmp
[compare]
	input = _ais1_diff_tmp * 100
	compare = _solo_spread
	ifless = _ais1_diff_tmp * 100
	else = _solo_spread
	output = _ais1_diff
[math]
	input1 = _solo_spread - _ais1_diff
	input2 = _solo_spread
	quotient = _ais1_prob_fac
[math]
	input = 2.2/12 + _solo_center_neg
	amount = _ais2_diff_tmp
[compare]
	input = _ais2_diff_tmp * 100
	compare = _solo_spread
	ifless = _ais2_diff_tmp * 100
	else = _solo_spread
	output = _ais2_diff
[math]
	input1 = _solo_spread - _ais2_diff
	input2 = _solo_spread
	quotient = _ais2_prob_fac
[math]
	input = 3.4/12 + _solo_center_neg
	amount = _ais3_diff_tmp
[compare]
	input = _ais3_diff_tmp * 100
	compare = _solo_spread
	ifless = _ais3_diff_tmp * 100
	else = _solo_spread
	output = _ais3_diff
[math]
	input1 = _solo_spread - _ais3_diff
	input2 = _solo_spread
	quotient = _ais3_prob_fac
[mixer]
	input1 = _ais1_prob_fac * _soloplay_trig + _soloplay_trig_inv
	input2 = _ais2_prob_fac * _soloplay_trig
	input3 = _ais3_prob_fac * _soloplay_trig
	output = _ais_prob_fac
# H solo
[math]
	input = 1.1/12 + _solo_center_neg
	amount = _h1_diff_tmp
[compare]
	input = _h1_diff_tmp * 100
	compare = _solo_spread
	ifless = _h1_diff_tmp * 100
	else = _solo_spread
	output = _h1_diff
[math]
	input1 = _solo_spread - _h1_diff
	input2 = _solo_spread
	quotient = _h1_prob_fac
[math]
	input = 2.3/12 + _solo_center_neg
	amount = _h2_diff_tmp
[compare]
	input = _h2_diff_tmp * 100
	compare = _solo_spread
	ifless = _h2_diff_tmp * 100
	else = _solo_spread
	output = _h2_diff
[math]
	input1 = _solo_spread - _h2_diff
	input2 = _solo_spread
	quotient = _h2_prob_fac
[math]
	input = 3.5/12 + _solo_center_neg
	amount = _h3_diff_tmp
[compare]
	input = _h3_diff_tmp * 100
	compare = _solo_spread
	ifless = _h3_diff_tmp * 100
	else = _solo_spread
	output = _h3_diff
[math]
	input1 = _solo_spread - _h3_diff
	input2 = _solo_spread
	quotient = _h3_prob_fac
[mixer]
	input1 = _h1_prob_fac * _soloplay_trig + _soloplay_trig_inv
	input2 = _h2_prob_fac * _soloplay_trig
	input3 = _h3_prob_fac * _soloplay_trig
	output = _h_prob_fac

### pitch probabilities
[copy]
	input = _chan1_pitch_sub + _menu3
	output = _chan1_pitch_pots
[pot]
	pot = P2.2 # C
	select = _c_prob2pot * _chan1_pitch_pots
	output = _c_prob_pot
[pot]
	pot = P2.2 # CIS
	select = _cis_prob2pot * _chan1_pitch_pots
	output = _cis_prob_pot
[pot]
	pot = P2.2 # D
	select = _d_prob2pot * _chan1_pitch_pots
	output = _d_prob_pot
[pot]
	pot = P2.2 # DIS
	select = _dis_prob2pot * _chan1_pitch_pots
	output = _dis_prob_pot
[pot]
	pot = P2.2 # E
	select = _e_prob2pot * _chan1_pitch_pots
	output = _e_prob_pot
[pot]
	pot = P2.2 # F
	select = _f_prob2pot * _chan1_pitch_pots
	output = _f_prob_pot
[pot]
	pot = P2.2 # FIS
	select = _fis_prob2pot * _chan1_pitch_pots
	output = _fis_prob_pot
[pot]
	pot = P2.2 # G
	select = _g_prob2pot * _chan1_pitch_pots
	output = _g_prob_pot
[pot]
	pot = P2.2 # GIS
	select = _gis_prob2pot * _chan1_pitch_pots
	output = _gis_prob_pot
[pot]
	pot = P2.2 # A
	select = _a_prob2pot * _chan1_pitch_pots
	output = _a_prob_pot
[pot]
	pot = P2.2 # AIS
	select = _ais_prob2pot * _chan1_pitch_pots
	output = _ais_prob_pot
[pot]
	pot = P2.2 # H
	select = _h_prob2pot * _chan1_pitch_pots
	output = _h_prob_pot
# adjust pitch probabilities by solo factors
[superjust]
	input1 = _c_prob_pot * _c_prob_fac
	input2 = _cis_prob_pot * _cis_prob_fac
	input3 = _d_prob_pot * _d_prob_fac
	input4 = _dis_prob_pot * _dis_prob_fac
	input5 = _e_prob_pot * _e_prob_fac
	input6 = _f_prob_pot * _f_prob_fac
	output1 = _c_prob
	output2 = _cis_prob
	output3 = _d_prob
	output4 = _dis_prob
	output5 = _e_prob
	output6 = _f_prob
[superjust]
	input1 = _fis_prob_pot * _fis_prob_fac
	input2 = _g_prob_pot * _g_prob_fac
	input3 = _gis_prob_pot * _gis_prob_fac
	input4 = _a_prob_pot * _a_prob_fac
	input5 = _ais_prob_pot * _ais_prob_fac
	input6 = _h_prob_pot * _h_prob_fac
	output1 = _fis_prob
	output2 = _g_prob
	output3 = _gis_prob
	output4 = _a_prob
	output5 = _ais_prob
	output6 = _h_prob
[mixer]
	input1 = _c_prob
	input2 = _cis_prob
	input3 = _d_prob
	input4 = _dis_prob
	input5 = _e_prob
	input6 = _f_prob
	output = _pitch_prob_sum1_tmp
[mixer]
	input1 = _fis_prob
	input2 = _g_prob
	input3 = _gis_prob
	input4 = _a_prob
	input5 = _ais_prob
	input6 = _h_prob
	output = _pitch_prob_sum2_tmp
[compare]
	input = _pitch_prob_sum1_tmp + _pitch_prob_sum2_tmp
	compare = 0
	ifequal = 1
	else = _pitch_prob_sum1_tmp + _pitch_prob_sum2_tmp
	output = _pitch_prob_sum
# calculate probability distributions for serial bernulli gates
# This is the math behind it:
# A probability setting of
# 0.2 for event A
# 0.6 for event B
# 0.3 for event C
# would look like this:
# sum = 0.2 + 0.6 + 0.3
#[bernoulli]
#	input = _trig
#	distribution = 0.2 / sum
#	output1 = _A_sel
#	output2 = _A_rej
#[bernoulli]
#	input = _A_rej
#	distribution = 0.6 / sum / (1-0.2/sum)
#	output1 = _B_sel
#	output2 = _B_rej
#[bernoulli]
#	input = _B_rej
#	distribution = 0.3 / sum / (1-0.2/sum-0.6/sum)
#	output1 = _C_sel
#	output2 = _C_rej
[superjust]
	bypass = 1
	input1 = _pitch_prob_sum
	output1 = _c_prob_den # denominator
	input2 = _c_prob_den - _c_prob
	output2 = _cis_prob_den
	input3 = _cis_prob_den - _cis_prob
	output3 = _d_prob_den
	input4 = _d_prob_den - _d_prob
	output4 = _dis_prob_den
	input5 = _dis_prob_den - _dis_prob
	output5 = _e_prob_den
	input6 = _e_prob_den - _e_prob
	output6 = _f_prob_den
[superjust]
	bypass = 1
	input1 = _f_prob_den - _f_prob
	output1 = _fis_prob_den
	input2 = _fis_prob_den - _fis_prob
	output2 = _g_prob_den
	input3 = _g_prob_den - _g_prob
	output3 = _gis_prob_den
	input4 = _gis_prob_den - _gis_prob
	output4 = _a_prob_den
	input5 = _a_prob_den - _a_prob
	output5 = _ais_prob_den
	input6 = _ais_prob_den - _ais_prob
	output6 = _h_prob_den
[math]
	input1 = _c_prob
	input2 = _c_prob_den
	quotient = _c_dist
[bernoulli]
	input = _pitch_trig_any + _soloplay_trig
#	distribution = _c_prob / _c_prob_den
	distribution = _c_dist
	output1 = _c_sel
	output2 = _c_rej
[math]
	input1 = _cis_prob
	input2 = _cis_prob_den
	quotient = _cis_dist
[bernoulli]
	input = _c_rej
	distribution = _cis_dist
	output1 = _cis_sel
	output2 = _cis_rej
[math]
	input1 = _d_prob
	input2 = _d_prob_den
	quotient = _d_dist
[bernoulli]
	input = _cis_rej
	distribution = _d_dist
	output1 = _d_sel
	output2 = _d_rej
[math]
	input1 = _dis_prob
	input2 = _dis_prob_den
	quotient = _dis_dist
[bernoulli]
	input = _d_rej
	distribution = _dis_dist
	output1 = _dis_sel
	output2 = _dis_rej
[math]
	input1 = _e_prob
	input2 = _e_prob_den
	quotient = _e_dist
[bernoulli]
	input = _dis_rej
	distribution = _e_dist
	output1 = _e_sel
	output2 = _e_rej
[math]
	input1 = _f_prob
	input2 = _f_prob_den
	quotient = _f_dist
[bernoulli]
	input = _e_rej
	distribution = _f_dist
	output1 = _f_sel
	output2 = _f_rej
[math]
	input1 = _fis_prob
	input2 = _fis_prob_den
	quotient = _fis_dist
[bernoulli]
	input = _f_rej
	distribution = _fis_dist
	output1 = _fis_sel
	output2 = _fis_rej
[math]
	input1 = _g_prob
	input2 = _g_prob_den
	quotient = _g_dist
[bernoulli]
	input = _fis_rej
	distribution = _g_dist
	output1 = _g_sel
	output2 = _g_rej
[math]
	input1 = _gis_prob
	input2 = _gis_prob_den
	quotient = _gis_dist
[bernoulli]
	input = _g_rej
	distribution = _gis_dist
	output1 = _gis_sel
	output2 = _gis_rej
[math]
	input1 = _a_prob
	input2 = _a_prob_den
	quotient = _a_dist
[bernoulli]
	input = _gis_rej
	distribution = _a_dist
	output1 = _a_sel
 	output2 = _a_rej
[math]
	input1 = _ais_prob
	input2 = _ais_prob_den
	quotient = _ais_dist
[bernoulli]
	input = _a_rej
	distribution = _ais_dist
	output1 = _ais_sel
 	output2 = _ais_rej
[math]
	input1 = _h_prob
	input2 = _h_prob_den
	quotient = _h_dist
[bernoulli]
	input = _ais_rej
	distribution = _h_dist
	output1 = _h_sel

# determine octave for solo pitch
[mixer]
	input1 = _c_sel * _c1_prob_fac
	input2 = _cis_sel * _cis1_prob_fac
	input3 = _d_sel * _d1_prob_fac
	input4 = _dis_sel * _dis1_prob_fac
	input5 = _e_sel * _e1_prob_fac
	input6 = _f_sel * _f1_prob_fac
	output = _m1_prob_fac1
[mixer]
	input1 = _fis_sel * _fis1_prob_fac
	input2 = _g_sel * _g1_prob_fac
	input3 = _gis_sel * _gis1_prob_fac
	input4 = _a_sel * _a1_prob_fac
	input5 = _ais_sel * _ais1_prob_fac
	input6 = _h_sel * _h1_prob_fac
	output = _m1_prob_fac2
[mixer]
	input1 = _m1_prob_fac1 * _soloplay_trig
	input2 = _m1_prob_fac2 * _soloplay_trig
	output = _m1_prob_fac
[mixer]
	input1 = _c_sel * _c2_prob_fac
	input2 = _cis_sel * _cis2_prob_fac
	input3 = _d_sel * _d2_prob_fac
	input4 = _dis_sel * _dis2_prob_fac
	input5 = _e_sel * _e2_prob_fac
	input6 = _f_sel * _f2_prob_fac
	output = _0_prob_fac1
[mixer]
	input1 = _fis_sel * _fis2_prob_fac
	input2 = _g_sel * _g2_prob_fac
	input3 = _gis_sel * _gis2_prob_fac
	input4 = _a_sel * _a2_prob_fac
	input5 = _ais_sel * _ais2_prob_fac
	input6 = _h_sel * _h2_prob_fac
	output = _0_prob_fac2
[mixer]
	input1 = _0_prob_fac1 * _soloplay_trig
	input2 = _0_prob_fac2 * _soloplay_trig
	output = _0_prob_fac
[mixer]
	input1 = _c_sel * _c3_prob_fac
	input2 = _cis_sel * _cis3_prob_fac
	input3 = _d_sel * _d3_prob_fac
	input4 = _dis_sel * _dis3_prob_fac
	input5 = _e_sel * _e3_prob_fac
	input6 = _f_sel * _f3_prob_fac
	output = _p1_prob_fac1
[mixer]
	input1 = _fis_sel * _fis3_prob_fac
	input2 = _g_sel * _g3_prob_fac
	input3 = _gis_sel * _gis3_prob_fac
	input4 = _a_sel * _a3_prob_fac
	input5 = _ais_sel * _ais3_prob_fac
	input6 = _h_sel * _h3_prob_fac
	output = _p1_prob_fac2
[mixer]
	input1 = _p1_prob_fac1 * _soloplay_trig
	input2 = _p1_prob_fac2 * _soloplay_trig
	output = _p1_prob_fac
[copy]
	input = _c_sel * _c4_prob_fac
	output = _p2_prob

### octave bias for individual notes
[pot]
	pot = P2.2
	select = _c_bias2pot * _chan1_oct_sub
	discrete = 4
	startvalue = 0
	output = _c_bias_pot
[pot]
	pot = P2.2
	select = _cis_bias2pot * _chan1_oct_sub
	discrete = 4
	startvalue = 0
	output = _cis_bias_pot
[pot]
	pot = P2.2
	select = _d_bias2pot * _chan1_oct_sub
	discrete = 4
	startvalue = 0
	output = _d_bias_pot
[pot]
	pot = P2.2
	select = _dis_bias2pot * _chan1_oct_sub
	discrete = 4
	startvalue = 0
	output = _dis_bias_pot
[pot]
	pot = P2.2
	select = _e_bias2pot * _chan1_oct_sub
	discrete = 4
	startvalue = 0
	output = _e_bias_pot
[pot]
	pot = P2.2
	select = _f_bias2pot * _chan1_oct_sub
	discrete = 4
	startvalue = 0
	output = _f_bias_pot
[pot]
	pot = P2.2
	select = _fis_bias2pot * _chan1_oct_sub
	discrete = 4
	startvalue = 0
	output = _fis_bias_pot
[pot]
	pot = P2.2
	select = _g_bias2pot * _chan1_oct_sub
	discrete = 4
	startvalue = 0
	output = _g_bias_pot
[pot]
	pot = P2.2
	select = _gis_bias2pot * _chan1_oct_sub
	discrete = 4
	startvalue = 0
	output = _gis_bias_pot
[pot]
	pot = P2.2
	select = _a_bias2pot * _chan1_oct_sub
	discrete = 4
	startvalue = 0
	output = _a_bias_pot
[pot]
	pot = P2.2
	select = _ais_bias2pot * _chan1_oct_sub
	discrete = 4
	startvalue = 0
	output = _ais_bias_pot
[pot]
	pot = P2.2
	select = _h_bias2pot * _chan1_oct_sub
	discrete = 4
	startvalue = 0
	output = _h_bias_pot
[superjust]
	input1 = _c_bias_pot - 2
	input2 = _cis_bias_pot - 2
	input3 = _d_bias_pot - 2
	input4 = _dis_bias_pot - 2
	input5 = _e_bias_pot - 2
	input6 = _f_bias_pot - 2
	output1 = _c_bias
	output2 = _cis_bias
	output3 = _d_bias
	output4 = _dis_bias
	output5 = _e_bias
	output6 = _f_bias
[superjust]
	input1 = _fis_bias_pot - 2
	input2 = _g_bias_pot - 2
	input3 = _gis_bias_pot - 2
	input4 = _a_bias_pot - 2
	input5 = _ais_bias_pot - 2
	input6 = _h_bias_pot - 2
	output1 = _fis_bias
	output2 = _g_bias
	output3 = _gis_bias
	output4 = _a_bias
	output5 = _ais_bias
	output6 = _h_bias
[mixer]
	input1 = _c_sel * _c_bias
	input2 = _cis_sel * _cis_bias
	input3 = _d_sel * _d_bias
	input4 = _dis_sel * _dis_bias
	input5 = _e_sel * _e_bias
	input6 = _f_sel * _f_bias
	output = _oct_bias1
[mixer]
	input1 = _fis_sel * _fis_bias
	input2 = _g_sel * _g_bias
	input3 = _gis_sel * _gis_bias
	input4 = _a_sel * _a_bias
	input5 = _ais_sel * _ais_bias
	input6 = _h_sel * _h_bias
	output = _oct_bias2
[copy]
	input = _oct_bias1 + _oct_bias2
	output = _oct_bias_tmp
[compare]
	input = _soloplay_trig
	compare = 1
	ifequal = -2
	else = _oct_bias_tmp
	output = _oct_bias
[compare]
	input = _oct_bias
	compare = -2
	ifequal = 1
	output = _no_bias
[compare]
	input = _oct_bias
	compare = -1
	ifequal = 1
	output = _m1_bias
[compare]
	input = _oct_bias
	compare = 0
	ifequal = 1
	output = _0_bias
[compare]
	input = _oct_bias
	compare = 1
	ifequal = 1
	output = _p1_bias
[superjust]
	input1 = 1 - _m1_bias
	input2 = 1 - _0_bias
	input3 = 1 - _p1_bias
	input4 = 1 - _no_bias
	output1 = _m1_bias_inv
	output2 = _0_bias_inv
	output3 = _p1_bias_inv
	output4 = _no_bias_inv
### set global octave probabilities
[pot]
	pot = P1.1
	select = _oct_calc * _chan1
	output = _m1_prob_pot
[pot]
	pot = P2.1
	select = _oct_calc * _chan1
	output = _0_prob_pot
[pot]
	pot = P3.1
	select = _oct_calc * _chan1
	output = _p1_prob_pot
# correct global octave probabilities to account for octave bias
# note: if a solo button is triggered, any octave bias is set to 0 (see above)
[superjust]
	input1 = _m1_prob_pot * _soloplay_trig_inv + _m1_prob_fac
	output1 = _m1_prob
	input2 = _0_prob_pot * _soloplay_trig_inv + _0_prob_fac
	output2 = _0_prob
	input3 = _p1_prob_pot * _soloplay_trig_inv + _p1_prob_fac
	output3 = _p1_prob
[mixer]
	input1 = _m1_prob
	input2 = _0_prob
	input3 = _p1_prob
	output = _oct_prob_sum_tmp
[mixer]
	input1 = _m1_prob * _m1_bias
	input2 = _0_prob * _0_bias
	input3 = _p1_prob * _p1_bias
	output = _oct_prob_sub
[copy]
	input = _oct_prob_sum_tmp - _oct_prob_sub
	output = _oct_prob_sum_sub
[copy]
	input = _oct_prob_sum_sub * 3 # the global octave probabilities that are not the bias octave are only allowed to be max 1/4 of bias octave
	output = _oct_prob_bias_tmp1
[compare]
	input = _oct_prob_bias_tmp1
	compare = _oct_prob_sub
	ifgreater = _oct_prob_bias_tmp1
	else = _oct_prob_sub
	output = _oct_prob_bias_tmp2
[compare]
	input = _oct_prob_bias_tmp2
	compare = 0
	ifequal = _no_bias_inv
	else = _oct_prob_bias_tmp2
	output = _oct_prob_bias
[superjust]
	input1 = _m1_prob * _m1_bias_inv
	input2 = _0_prob * _0_bias_inv
	input3 = _p1_prob * _p1_bias_inv
	output1 = _m1_prob_bias_tmp
	output2 = _0_prob_bias_tmp
	output3 = _p1_prob_bias_tmp
[superjust]
	input1 = _oct_prob_bias * _m1_bias + _m1_prob_bias_tmp
	input2 = _oct_prob_bias * _0_bias + _0_prob_bias_tmp
	input3 = _oct_prob_bias * _p1_bias + _p1_prob_bias_tmp
	output1 = _m1_prob_bias
	output2 = _0_prob_bias
	output3 = _p1_prob_bias
[mixer]
	input1 = _m1_prob_bias
	input2 = _0_prob_bias
	input3 = _p1_prob_bias
	input4 = _p2_prob * _soloplay_trig
	output = _oct_prob_bias_sum_tmp
[compare]
	input = _oct_prob_bias_sum_tmp
	compare = 0
	ifequal = 1
	else = _oct_prob_bias_sum_tmp
	output = _oct_prob_bias_sum
# algorithm to select octave
[superjust]
	bypass = 1
	input1 = _oct_prob_bias_sum
	output1 = _m1_prob_den
	input2 = _m1_prob_den - _m1_prob_bias
	output2 = _p1_prob_den
	input3 = _p1_prob_den - _p1_prob_bias
	output3 = _p2_prob_den
[math]
	input1 = _m1_prob_bias
	input2 = _m1_prob_den
	quotient = _m1_dist
[bernoulli]
	input = _pitch_trig_any + _soloplay_trig
	distribution = _m1_dist
	output1 = _m1_sel
	output2 = _m1_rej
[math]
	input1 = _p1_prob_bias
	input2 = _p1_prob_den
	quotient = _p1_dist
[bernoulli]
	input = _m1_rej
	distribution = _p1_dist
	output1 = _p1_sel
	output2 = _p1_rej
[math]
	input1 = _p2_prob * _soloplay_trig
	input2 = _p2_prob_den
	quotient = _p2_dist
[bernoulli]
	input = _p1_rej
	distribution = _p2_dist
	output1 = _p2_sel
[mixer]
	input1 = _m1_sel * -0.1
	input2 = _p1_sel * 0.1
	input3 = _p2_sel * 0.2
	output = _oct_sel_tmp
[sample]
	input = _oct_sel_tmp
	sample = _pitch_trig_any + _soloplay_trig
	output = _oct_sel
# apply selected octave
[superjust]
	input1 = 0/12 + _oct_sel
	input2 = 0.1/12 + _oct_sel
	input3 = 0.2/12 + _oct_sel
	input4 = 0.3/12 + _oct_sel
	input5 = 0.4/12 + _oct_sel
	input6 = 0.5/12 + _oct_sel
	output1 = _c_pitch
	output2 = _cis_pitch
	output3 = _d_pitch
	output4 = _dis_pitch
	output5 = _e_pitch
	output6 = _f_pitch
[superjust]
	input1 = 0.6/12 + _oct_sel
	input2 = 0.7/12 + _oct_sel
	input3 = 0.8/12 + _oct_sel
	input4 = 0.9/12 + _oct_sel
	input5 = 1.0/12 + _oct_sel
	input6 = 1.1/12 + _oct_sel
	output1 = _fis_pitch
	output2 = _g_pitch
	output3 = _gis_pitch
	output4 = _a_pitch
	output5 = _ais_pitch
	output6 = _h_pitch
[mixer]
	input1 = _c_sel * _c_pitch
	input2 = _cis_sel * _cis_pitch
	input3 = _d_sel * _d_pitch
	input4 = _dis_sel * _dis_pitch
	input5 = _e_sel * _e_pitch
	input6 = _f_sel * _f_pitch
	output = _pitch_sel1_tmp
[mixer]
	input1 = _fis_sel * _fis_pitch
	input2 = _g_sel * _g_pitch
	input3 = _gis_sel * _gis_pitch
	input4 = _a_sel * _a_pitch
	input5 = _ais_sel * _ais_pitch
	input6 = _h_sel * _h_pitch
	output = _pitch_sel2_tmp
[copy]
	input = _pitch_sel1_tmp + _pitch_sel2_tmp
	output = _pitch_sel_tmp
# add 4V for default octave
[copy]
	input = _pitch_sel_tmp + 0.4
	output = _pitch_sel
[sample]
	input = _pitch_sel * _gate_assign_inv + _pitch_assign
	sample = _soloplay_any
	output = _pitch_solo_tmp
# add semitones from transposition
[copy]
	input = _pitch_solo_tmp + _transp
	output = _pitch_solo
# map the pitches of each algoquencer step to virtual pots to keep them over a power cycle and to save them in presets
### algo1 pitch
[pot]
	select = 0
	pot = P1.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _pitch_trig * _step1
	startvalue = _pitch_sel
	output = _pitch_step1
[pot]
	select = 0
	pot = P1.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _pitch_trig * _step2
	startvalue = _pitch_sel
	output = _pitch_step2
[pot]
	select = 0
	pot = P1.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _pitch_trig * _step3
	startvalue = _pitch_sel
	output = _pitch_step3
[pot]
	select = 0
	pot = P1.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _pitch_trig * _step4
	startvalue = _pitch_sel
	output = _pitch_step4
[pot]
	select = 0
	pot = P1.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _pitch_trig * _step5
	startvalue = _pitch_sel
	output = _pitch_step5
[pot]
	select = 0
	pot = P1.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _pitch_trig * _step6
	startvalue = _pitch_sel
	output = _pitch_step6
[pot]
	select = 0
	pot = P1.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _pitch_trig * _step7
	startvalue = _pitch_sel
	output = _pitch_step7
[pot]
	select = 0
	pot = P1.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _pitch_trig * _step8
	startvalue = _pitch_sel
	output = _pitch_step8
[pot]
	select = 0
	pot = P1.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _pitch_trig * _step9
	startvalue = _pitch_sel
	output = _pitch_step9
[pot]
	select = 0
	pot = P1.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _pitch_trig * _step10
	startvalue = _pitch_sel
	output = _pitch_step10
[pot]
	select = 0
	pot = P1.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _pitch_trig * _step11
	startvalue = _pitch_sel
	output = _pitch_step11
[pot]
	select = 0
	pot = P1.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _pitch_trig * _step12
	startvalue = _pitch_sel
	output = _pitch_step12
[pot]
	select = 0
	pot = P1.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _pitch_trig * _step13
	startvalue = _pitch_sel
	output = _pitch_step13
[pot]
	select = 0
	pot = P1.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _pitch_trig * _step14
	startvalue = _pitch_sel
	output = _pitch_step14
[pot]
	select = 0
	pot = P1.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _pitch_trig * _step15
	startvalue = _pitch_sel
	output = _pitch_step15
[pot]
	select = 0
	pot = P1.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _pitch_trig * _step16
	startvalue = _pitch_sel
	output = _pitch_step16
[pot]
	pot = P2.1
	select = _menu2
	preset = _preset
	loadpreset = _load
	savepreset = _save
	output = _algo1_fills
[pot]
	pot = P3.1
	select = _menu2
	preset = _preset
	loadpreset = _load
	savepreset = _save
	notch = 0.1
	output = _algo1_offbeats
[pot]
	pot = P3.2
	select = _menu2
	preset = _preset
	loadpreset = _load
	savepreset = _save
	notch = 0.1
	output = _algo1_distribution
# chan 1 dejavu/morph parameters
[pot]
	pot = P3.4
	select = 1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	notch = 0.1
	ledgauge = on
	lefthalfinv = _algo1_dejavu
	righthalf = _algo1_morph
[pot]
	pot = P3.3
	select = 1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	notch = 0.1
	ledgauge = on
	output = _algo1_activity
[algoquencer]
 	clock = _clock
	reset = _reset + _load
#	reset = _reset
	preset = _preset
	loadpreset = _load
	savepreset = _save
	reroll = _pattern_trig
	length = _algo1_length
	trigger = _algo1_trig
	muteled = _muteled
	unmuteled = _unmuteled
	mutebutton = _mute_toggle
	unmutebutton = _unmute
	activity = _algo1_activity
	branches = _algo1_branches
	fills = _algo1_fills
	fillorder = _fillorder
	dejavu = _algo1_dejavu
	morphs = _algo1_morph
	offbeats = _algo1_offbeats
	distribution = _algo1_distribution
	pitch1 = _pitch_step1
	pitch2 = _pitch_step2
	pitch3 = _pitch_step3
	pitch4 = _pitch_step4
	pitch5 = _pitch_step5
	pitch6 = _pitch_step6
	pitch7 = _pitch_step7
	pitch8 = _pitch_step8
	pitch9 = _pitch_step9
	pitch10 = _pitch_step10
	pitch11 = _pitch_step11
	pitch12 = _pitch_step12
	pitch13 = _pitch_step13
	pitch14 = _pitch_step14
	pitch15 = _pitch_step15
	pitch16 = _pitch_step16
	pitch = _pitch_out
[sample]
	input = _pitch_out + _transp
	gate = _no_gate
	output = _pitch_gate
### algo2 pitch
[pot]
	select = 0
	pot = P2.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _pitch2_trig * _step1
	startvalue = _pitch_sel
	output = _pitch2_step1
[pot]
	select = 0
	pot = P2.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _pitch2_trig * _step2
	startvalue = _pitch_sel
	output = _pitch2_step2
[pot]
	select = 0
	pot = P2.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _pitch2_trig * _step3
	startvalue = _pitch_sel
	output = _pitch2_step3
[pot]
	select = 0
	pot = P2.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _pitch2_trig * _step4
	startvalue = _pitch_sel
	output = _pitch2_step4
[pot]
	select = 0
	pot = P2.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _pitch2_trig * _step5
	startvalue = _pitch_sel
	output = _pitch2_step5
[pot]
	select = 0
	pot = P2.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _pitch2_trig * _step6
	startvalue = _pitch_sel
	output = _pitch2_step6
[pot]
	select = 0
	pot = P2.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _pitch2_trig * _step7
	startvalue = _pitch_sel
	output = _pitch2_step7
[pot]
	select = 0
	pot = P2.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _pitch2_trig * _step8
	startvalue = _pitch_sel
	output = _pitch2_step8
[pot]
	select = 0
	pot = P2.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _pitch2_trig * _step9
	startvalue = _pitch_sel
	output = _pitch2_step9
[pot]
	select = 0
	pot = P2.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _pitch2_trig * _step10
	startvalue = _pitch_sel
	output = _pitch2_step10
[pot]
	select = 0
	pot = P2.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _pitch2_trig * _step11
	startvalue = _pitch_sel
	output = _pitch2_step11
[pot]
	select = 0
	pot = P2.1
	clear = _pitch2_trig * _step12
	startvalue = _pitch_sel
	output = _pitch2_step12
[pot]
	select = 0
	pot = P2.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _pitch2_trig * _step13
	startvalue = _pitch_sel
	output = _pitch2_step13
[pot]
	select = 0
	pot = P2.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _pitch2_trig * _step14
	startvalue = _pitch_sel
	output = _pitch2_step14
[pot]
	select = 0
	pot = P2.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _pitch2_trig * _step15
	startvalue = _pitch_sel
	output = _pitch2_step15
[pot]
	select = 0
	pot = P2.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _pitch2_trig * _step16
	startvalue = _pitch_sel
	output = _pitch2_step16
[pot]
	pot = P3.6
	select = 1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	notch = 0.1
	ledgauge = on
	lefthalfinv = _algo2_dejavu
	righthalf = _algo2_morph
[pot]
	pot = P3.5
	select = 1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	notch = 0.1
	ledgauge = on
	output = _algo2_activity
[algoquencer]
 	clock = _clock
	reset = _reset + _load
#	reset = _reset
	preset = _preset
	loadpreset = _load
	savepreset = _save
	reroll = _pattern2_trig
	length = _algo2_length
	trigger = _algo2_trig
	muteled = _muteled2
	unmuteled = _unmuteled2
	mutebutton = _mute2_toggle
	unmutebutton = _unmute2
	activity = _algo2_activity
	branches = _algo1_branches
	fills = _algo1_fills
	fillorder = _fillorder
	dejavu = _algo2_dejavu
	morphs = _algo2_morph
	offbeats = _algo1_offbeats
	distribution = _algo1_distribution
	pitch1 = _pitch2_step1
	pitch2 = _pitch2_step2
	pitch3 = _pitch2_step3
	pitch4 = _pitch2_step4
	pitch5 = _pitch2_step5
	pitch6 = _pitch2_step6
	pitch7 = _pitch2_step7
	pitch8 = _pitch2_step8
	pitch9 = _pitch2_step9
	pitch10 = _pitch2_step10
	pitch11 = _pitch2_step11
	pitch12 = _pitch2_step12
	pitch13 = _pitch2_step13
	pitch14 = _pitch2_step14
	pitch15 = _pitch2_step15
	pitch16 = _pitch2_step16
	pitch = _pitch2_out
[sample]
	input = _pitch2_out + _transp
	gate = _no_gate2
	output = _pitch2_gate

### note length probabilitities
[pot]
	pot = P1.1
	select = _notelength_calc * _chan1_sub_off
	output = _16th_prob
[pot]
	pot = P1.2
	select = _notelength_calc * _chan1_sub_off
	output = _8th_prob
[pot]
	pot = P2.1
	select = _notelength_calc * _chan1_sub_off
	output = _quarter_prob
[pot]
	pot = P2.2
	select = _notelength_calc * _chan1_sub_off
	output = _half_prob
[pot]
	pot = P3.1
	select = _notelength_calc * _chan1_sub_off
	output = _whole_prob
[mixer]
	input1 = _16th_prob
	input2 = _8th_prob
	input3 = _quarter_prob
	input4 = _half_prob
	input5 = _whole_prob
	output = _notelength_prob_sum_tmp
[compare]
	input = _notelength_prob_sum_tmp
	compare = 0
	ifequal = 1
	else = _notelength_prob_sum_tmp
	output = _notelength_prob_sum
[superjust]
	bypass = 1
	input1 = _notelength_prob_sum
	output1 = _8th_prob_den # denominator
	input2 = _8th_prob_den - _8th_prob
	output2 = _quarter_prob_den
	input3 = _quarter_prob_den - _quarter_prob
	output3 = _half_prob_den
	input4 = _half_prob_den - _half_prob
	output4 = _whole_prob_den
[math]
	input1 = _8th_prob
	input2 = _8th_prob_den
	quotient = _8th_dist
[bernoulli]
	input = _notelength_trig_any
	distribution = _8th_dist
	output1 = _8th_sel
	output2 = _8th_rej
[math]
	input1 = _quarter_prob
	input2 = _quarter_prob_den
	quotient = _quarter_dist
[bernoulli]
	input = _8th_rej
	distribution = _quarter_dist
	output1 = _quarter_sel
	output2 = _quarter_rej
[math]
	input1 = _half_prob
	input2 = _half_prob_den
	quotient = _half_dist
[bernoulli]
	input = _quarter_rej
	distribution = _half_dist
	output1 = _half_sel
	output2 = _half_rej
[math]
	input1 = _whole_prob
	input2 = _whole_prob_den
	quotient = _whole_dist
[bernoulli]
	input = _half_rej
	distribution = _whole_dist
	output1 = _whole_sel
	output2 = _16th_sel # The last probability item in this serial chain has always a probability of 1. I use this to set the default note length to 16th.
[mixer]
	input1 = _16th_sel * 1
	input2 = _8th_sel * 2
	input3 = _quarter_sel * 4
	input4 = _half_sel * 8
	input5 = _whole_sel * 16
	output = _notelength_sel_tmp
[copy]
	input = _notelength_sel_tmp * 0.01
	output = _notelength_sel
# map selected note durations for each algoquencer step to virtual pots for safing
[pot]
	select = 0
	pot = P1.2
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _notelength_trig * _step1
	startvalue = _notelength_sel
	output = _notelength_step1
[pot]
	select = 0
	pot = P1.2
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _notelength_trig * _step2
	startvalue = _notelength_sel
	output = _notelength_step2
[pot]
	select = 0
	pot = P1.2
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _notelength_trig * _step3
	startvalue = _notelength_sel
	output = _notelength_step3
[pot]
	select = 0
	pot = P1.2
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _notelength_trig * _step4
	startvalue = _notelength_sel
	output = _notelength_step4
[pot]
	select = 0
	pot = P1.2
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _notelength_trig * _step5
	startvalue = _notelength_sel
	output = _notelength_step5
[pot]
	select = 0
	pot = P1.2
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _notelength_trig * _step6
	startvalue = _notelength_sel
	output = _notelength_step6
[pot]
	select = 0
	pot = P1.2
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _notelength_trig * _step7
	startvalue = _notelength_sel
	output = _notelength_step7
[pot]
	select = 0
	pot = P1.2
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _notelength_trig * _step8
	startvalue = _notelength_sel
	output = _notelength_step8
[pot]
	select = 0
	pot = P1.2
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _notelength_trig * _step9
	startvalue = _notelength_sel
	output = _notelength_step9
[pot]
	select = 0
	pot = P1.2
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _notelength_trig * _step10
	startvalue = _notelength_sel
	output = _notelength_step10
[pot]
	select = 0
	pot = P1.2
	clear = _notelength_trig * _step11
	startvalue = _notelength_sel
	output = _notelength_step11
[pot]
	select = 0
	pot = P1.2
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _notelength_trig * _step12
	startvalue = _notelength_sel
	output = _notelength_step12
[pot]
	select = 0
	pot = P1.2
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _notelength_trig * _step13
	startvalue = _notelength_sel
	output = _notelength_step13
[pot]
	select = 0
	pot = P1.2
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _notelength_trig * _step14
	startvalue = _notelength_sel
	output = _notelength_step14
[pot]
	select = 0
	pot = P1.2
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _notelength_trig * _step15
	startvalue = _notelength_sel
	output = _notelength_step15
[pot]
	select = 0
	pot = P1.2
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _notelength_trig * _step16
	startvalue = _notelength_sel
	output = _notelength_step16
[algoquencer]
	clock = _clock
	reset = _reset
	length = _algo1_length
	pitch1 = _notelength_step1
	pitch2 = _notelength_step2
	pitch3 = _notelength_step3
	pitch4 = _notelength_step4
	pitch5 = _notelength_step5
	pitch6 = _notelength_step6
	pitch7 = _notelength_step7
	pitch8 = _notelength_step8
	pitch9 = _notelength_step9
	pitch10 = _notelength_step10
	pitch11 = _notelength_step11
	pitch12 = _notelength_step12
	pitch13 = _notelength_step13
	pitch14 = _notelength_step14
	pitch15 = _notelength_step15
	pitch16 = _notelength_step16
	pitch = _notelength_seq
# algo1 gates
[sample]
	input = _notelength_seq * 100
	sample = _algo1_trig * _no_gate
	output = _notelength
[compare]
	input = _pitch_prob_sum1_tmp + _pitch_prob_sum2_tmp
	compare = 0
	ifgreater = 1
	output = _notes_selected
[mixer]
	input1 = _notes_selected
	input2 = _pitch_new_ini_inv
	maximum = _algo1_trig_pass
[flipflop]
	clear = _no_gate
	set = _algo1_trig * _algo1_trig_pass
	output = _algo1_gate_on
[nudge]
	clear = _no_gate
	minimum = 0
	maximum = _notelength
	amount = 1
	buttonup = _clock * _algo1_gate_on
	dontsave = 1
	output = _algo1_gate_count
[compare]
	input = _algo1_gate_count
	compare = _notelength
	ifequal = 0
	else = 1
	output = _gatecontinue
[compare]
	input = _gatelength_pot + I3
	compare = 0.47
	precision = 0.43
	ifless = 0.03
	ifgreater = 0.9
	else = _gatelength_pot + I3
	output = _gatelength_duty
[clocktool]
	clock = _clock
	dutycycle = _gatelength_duty
	output = _gatelength
[mixer]
	input1 = _gatelength * _algo1_gate_on
	input2 = _gatecontinue * _algo1_gate_on
	maximum = _algo1_gate
### Mix outputs of algo1 and solo
[mixer]
	input1 = _algo1_gate
	input2 = _soloplay_any
	maximum = _algo1_gate_sum
[gatetool]
	inputtrigger = _algo1_gate_sum
	outputtrigger = _algo1_gate_trig
[copy]
	input = _pitch_solo * _soloplay_any
	output = _pitch_solo_sum
[copy]
	input = 1 - _soloplay_any
	output = _soloplay_any_inv
[sample]
	input = _pitch_gate * _soloplay_any_inv + _pitch_solo_sum
	sample = _algo1_gate_trig + _soloplay_any
	output = _pitch_final
### map note durations of algo2 to pots for safing
[pot]
	select = 0
	pot = P2.2
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _notelength2_trig * _step1
	startvalue = _notelength_sel
	output = _notelength2_step1
[pot]
	select = 0
	pot = P2.2
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _notelength2_trig * _step2
	startvalue = _notelength_sel
	output = _notelength2_step2
[pot]
	select = 0
	pot = P2.2
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _notelength2_trig * _step3
	startvalue = _notelength_sel
	output = _notelength2_step3
[pot]
	select = 0
	pot = P2.2
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _notelength2_trig * _step4
	startvalue = _notelength_sel
	output = _notelength2_step4
[pot]
	select = 0
	pot = P2.2
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _notelength2_trig * _step5
	startvalue = _notelength_sel
	output = _notelength2_step5
[pot]
	select = 0
	pot = P2.2
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _notelength2_trig * _step6
	startvalue = _notelength_sel
	output = _notelength2_step6
[pot]
	select = 0
	pot = P2.2
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _notelength2_trig * _step7
	startvalue = _notelength_sel
	output = _notelength2_step7
[pot]
	select = 0
	pot = P2.2
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _notelength2_trig * _step8
	startvalue = _notelength_sel
	output = _notelength2_step8
[pot]
	select = 0
	pot = P2.2
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _notelength2_trig * _step9
	startvalue = _notelength_sel
	output = _notelength2_step9
[pot]
	select = 0
	pot = P2.2
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _notelength2_trig * _step10
	startvalue = _notelength_sel
	output = _notelength2_step10
[pot]
	select = 0
	pot = P2.2
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _notelength2_trig * _step11
	startvalue = _notelength_sel
	output = _notelength2_step11
[pot]
	select = 0
	pot = P2.2
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _notelength2_trig * _step12
	startvalue = _notelength_sel
	output = _notelength2_step12
[pot]
	select = 0
	pot = P2.2
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _notelength2_trig * _step13
	startvalue = _notelength_sel
	output = _notelength2_step13
[pot]
	select = 0
	pot = P2.2
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _notelength2_trig * _step14
	startvalue = _notelength_sel
	output = _notelength2_step14
[pot]
	select = 0
	pot = P2.2
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _notelength2_trig * _step15
	startvalue = _notelength_sel
	output = _notelength2_step15
[pot]
	select = 0
	pot = P2.2
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _notelength2_trig * _step16
	startvalue = _notelength_sel
	output = _notelength2_step16
[algoquencer]
	clock = _clock
	reset = _reset
	length = _algo2_length
	pitch1 = _notelength2_step1
	pitch2 = _notelength2_step2
	pitch3 = _notelength2_step3
	pitch4 = _notelength2_step4
	pitch5 = _notelength2_step5
	pitch6 = _notelength2_step6
	pitch7 = _notelength2_step7
	pitch8 = _notelength2_step8
	pitch9 = _notelength2_step9
	pitch10 = _notelength2_step10
	pitch11 = _notelength2_step11
	pitch12 = _notelength2_step12
	pitch13 = _notelength2_step13
	pitch14 = _notelength2_step14
	pitch15 = _notelength2_step15
	pitch16 = _notelength2_step16
	pitch = _notelength2_seq
# algo2 gates
[sample]
	input = _notelength2_seq * 100
	sample = _algo2_trig * _no_gate2
	output = _notelength2
[mixer]
	input1 = _notes_selected
	input2 = _pitch2_new_ini_inv
	maximum = _algo2_trig_pass
[flipflop]
	clear = _no_gate2
	set = _algo2_trig * _algo2_trig_pass
	output = _algo2_gate_on
[nudge]
	clear = _no_gate2
	minimum = 0
	maximum = _notelength2
	amount = 1
	buttonup = _clock * _algo2_gate_on
	dontsave = 1
	output = _algo2_gate_count
[compare]
	input = _algo2_gate_count
	compare = _notelength2
	ifequal = 0
	else = 1
	output = _gatecontinue2
### optional gate length for algo2
#[compare]
#	input = _gatelength2_pot + I4
#	compare = 0.47
#	precision = 0.43
#	ifless = 0.03
#	ifgreater = 0.9
#	else = _gatelength2_pot + I4
#	output = _gatelength2_duty
#[clocktool]
#	clock = _clock
#	dutycycle = _gatelength2_duty
#	output = _gatelength2
###
[mixer]
	input1 = _gatelength * _algo2_gate_on
#	input1 = _gatelength2 * _algo2_gate_on
	input2 = _gatecontinue2 * _algo2_gate_on
	maximum = _algo2_gate
###
[copy]
	input = 1 - _algo1_gate
	output = _no_gate
[copy]
	input = 1 - _algo2_gate
	output = _no_gate2

### envelope parameters
[pot]
	select = _cont * _chan1
	pot = P1.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	output = _attack
[pot]
	select = _cont * _chan1
	pot = P2.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	output = _decay
[pot]
	select = _cont * _chan1
	pot = P1.2
	preset = _preset
	loadpreset = _load
	savepreset = _save
	output = _sustain
[pot]
	select = _cont * _chan1
	pot = P2.2
	preset = _preset
	loadpreset = _load
	savepreset = _save
	output = _release
[pot]
	select = _cont * _chan1
	pot = P3.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	output = _gatelength_pot
### optional gate length for algo2
#[pot]
#	select = _cont * _chan1
#	pot = P3.2
#	preset = _preset
#	loadpreset = _load
#	savepreset = _save
#	output = _gatelength2_pot

### transposition up/down
[button]
	button = B2.5
	select = _menu1
	states = 1
	negated = _set_transp_down_inv
	output = _set_transp_down
[pot]
	pot = P2.2
	select = _menu1 * _set_transp_down
	preset = _preset
	loadpreset = _load
	savepreset = _save
	discrete = 13
	outputscale = 0.1/12
	output = _transp_down_pot
[button]
	button = B2.6
	select = _menu1
	states = 1
	negated = _set_transp_up_inv
	output = _set_transp_up
[pot]
	pot = P2.2
	select = _menu1 * _set_transp_up
	preset = _preset
	loadpreset = _load
	savepreset = _save
	discrete = 13
	outputscale = 0.1/12
	output = _transp_up_pot
[mixer]
	input1 = _set_transp_down_inv
	input2 = _set_transp_up_inv
	minimum = _set_transp_inv
[sample]
	input = _transp_down_pot * -1 + _transp_up_pot
	gate = _set_transp_inv * _step16_del + _load_del
	output = _transp

### output envelopes
[contour]
	gate = _algo1_gate_sum
	startfromzero = 1
	attack = _attack
	decay = _decay
	sustain = _sustain
	release = _release
	output = _algo1_gateout_sum
[contour]
	gate = _algo1_gate
	startfromzero = 1
	attack = _attack
	decay = _decay
	sustain = _sustain
	release = _release
	output = _algo1_gateout
[contour]
	gate = _soloplay_any
	startfromzero = 1
	attack = _attack
	decay = _decay
	sustain = _sustain
	release = _release
	output = _solo_gateout
[contour]
	gate = _algo2_gate
	startfromzero = 1
	attack = _attack
	decay = _decay
	sustain = _sustain
	release = _release
	output = _algo2_gateout
[superjust]
	bypass = 1
	input1 = _algo1_gateout_sum
	output1 = O5
	input2 = _pitch_final
	output2 = O6
	input3 = _algo1_gateout
	output3 = O1
	input4 = _pitch_gate
	output4 = O2
	input5 = _solo_gateout
	output5 = O7
	input6 = _pitch_solo
	output6 = O8
	input7 = _algo2_gateout
	output7 = O3
	input8 = _pitch2_gate
	output8 = O4

## optional midi output
#[midiout]
#	channel = 15
#	pitch1 = _pitch2_gate # send gates here instead of envelopes
#	gate1 = _algo2_gate
#[midiout]
#	channel = 8
#	pitch1 = _pitch_solo
#	gate1 = _soloplay_any # send gates here instead of envelopes
