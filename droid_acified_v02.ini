[droid]
    ledbrightness = 0.5

[p2b8]
[p2b8]
[p10]

### accent level low (level high = 1.0)
[copy]
	input = 0.5
	output = _gatelength_low
[copy]
	input = 0.5
	output = _acc_level_low

### start all internal sequencers per midi controller
#[midiin]
#	start = _reset
# or use cv input for reset
[copy]
	input = I2
	output = _reset

### declare pots and buttons
[pot]
	pot = P1.1 # global activity parameter
	notch = 0.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	ledgauge = on
	output = _global_activity_tmp
[copy]
	input = _global_activity_tmp - 0.5
	output = _global_activity
[pot]
	pot = P1.2 # global gate length parameter
	outputscale = 0.5
	preset = _preset
	loadpreset = _load
	savepreset = _save
	ledgauge = on
	output = _gatelength_P12
[pot]
	pot = P2.1 # global fills parameter
	outputscale = 0.5
	preset = _preset
	loadpreset = _load
	savepreset = _save
	ledgauge = on
	output = _global_fills

[compare]
	input = _menu4_L26
	compare = 0
	output = _select_P22_1
[compare]
	input = _menu4_L26
	compare = 1
	output = _select_P22_2
[pot]
	pot = P2.2 # distribution of gate lengths (left = more short gates, right = more long gates)
	select = _select_P22_1
	ledgauge = 0.9
	preset = _preset
	loadpreset = _load
	savepreset = _save
	output = _gate_activity
[pot]
	pot = P2.2 # density of steps with accents (left = less accent steps, right = more accent steps)
	select = _select_P22_2
	ledgauge = 0.35
	preset = _preset
	loadpreset = _load
	savepreset = _save
	output = _accent_activity

[pot]
	pot = P3.1 # global offbeats parameter
	notch = 0.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	ledgauge = on
	output = _global_offbeats
[pot]
	pot = P3.2 # global distribution parameter
	notch = 0.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	ledgauge = on
	output = _global_distribution
[pot]
	pot = P3.3 # channel 1 activity
	notch = 0.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	ledgauge = 0.65
	output = _algo1_activity
[pot]
	pot = P3.4 # channel 1 dejavu/morph parameters
	notch = 0.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	ledgauge = 0.5
	lefthalfinv = _algo1_dejavu
	righthalf = _algo1_morph
[pot]
	pot = P3.5 # channel 2 activity
	notch = 0.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	ledgauge = 0.65
	output = _algo2_activity
[pot]
	pot = P3.6 # channel 2 dejavu/morph parameters
	notch = 0.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	ledgauge = 0.5
	lefthalfinv = _algo2_dejavu
	righthalf = _algo2_morph
[pot]
	pot = P3.7 # channel 3 activity
	notch = 0.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	ledgauge = 0.65
	output = _algo3_activity
[pot]
	pot = P3.8 # channel 3 dejavu/morph parameters
	notch = 0.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	ledgauge = 0.5
	lefthalfinv = _algo3_dejavu
	righthalf = _algo3_morph
[pot]
	pot = P3.9 # channel 4 activity
	notch = 0.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	ledgauge = 0.65
	output = _algo4_activity
[pot]
	pot = P3.10 # channel 4 dejavu/morph parameters
	notch = 0.1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	ledgauge = 0.5
	lefthalfinv = _algo4_dejavu
	righthalf = _algo4_morph

### leds of individual parameters (2nd p2b8) follow the 6 menus (1st p2b8)
[mixer]
	input1 = _menu1_L21 * _menu1
	input2 = _menu2_L21_dim * _menu2_piano_off
	input3 = _menu3_L21_blink * _menu3_semitrans_off
	input4 = _menu4_L21 * _menu4
	input5 = _menu5_L21 * L1.5
	input6 = _menu6_L21 * _submenu6_off
	input7 = _slide1 * _submenu6_on
	input8 = _menu8_L21 * _menu8_led + _save_blink0
	maximum = _allmenus_L21
[mixer]
	input1 =  _piano1_L21 + _piano2_L21
	input2 =  _piano3_L21 + _piano4_L21
	input3 = _menu3_semitrans_down * _semitrans_down_led21_dim
	input4 = _menu3_semitrans_up * _semitrans_up_led21_dim
	input5 = _channel1_inactive_dim * _menu1
	input6 = _algo1_gate_active * _menu4
	input7 = _allmenus_L21
	maximum = L2.1

[mixer]
	input1 = _menu1_L22 * _menu1
	input2 = _menu2_L22 * L1.2
	input3 = _menu3_L22_blink * _menu3_semitrans_off
	input4 = _gatelength_reroll * _menu4
	input5 = _menu5_L22 * L1.5 + _channel1_show_blink
 	input6 = _menu6_L22 * _submenu6_off
	input7 = _menu8_L22 * _menu8_led + _save_blink1
	maximum = _allmenus_L22
[mixer]
	input1 = _piano1_toggle_led
	input2 = _piano1_L22 + _piano2_L22
	input3 = _piano3_L22 + _piano4_L22
	input4 = _menu3_semitrans_down * _semitrans_down_led22_dim
	input5 = _menu3_semitrans_up * _semitrans_up_led22_dim
	input6 = _menu4_gatelength_dim
	input7 = _allmenus_L22
	maximum = L2.2

[mixer]
	input1 = _menu1_L23 * _menu1
	input2 = _menu2_L23_dim * _menu2_piano_off
	input3 = _menu3_L23 * L1.3
	input4 = _menu4_L23 * _menu4
	input5 = _menu5_L23 * L1.5
	input6 = _menu6_L23 * _submenu6_off
	input7 = _slide2 * _submenu6_on
	input8 = _menu8_L23 * _menu8_led + _save_blink2
	maximum = _allmenus_L23
[mixer]
	input1 =  _piano1_L23 + _piano2_L23
	input2 =  _piano3_L23 + _piano4_L23
	input3 = _menu3_semitrans_down * _semitrans_down_led23_dim
	input4 = _menu3_semitrans_up * _semitrans_up_led23_dim
	input5 = _channel2_inactive_dim * _menu1
	input6 = _algo2_gate_active * _menu4
	input7 = _allmenus_L23
	maximum = L2.3

[mixer]
	input1 = _menu1_L24 * _menu1
	input2 = _menu3_L24 * L1.3
	input3 = _accent_reroll * _menu4
	input4 = _menu5_L24 * L1.5 + _channel2_show_blink
	input5 = _menu6_L24 * _submenu6_off
	input6 = _menu8_L24 * _menu8_led + _save_blink3
	maximum = _allmenus_L24
[mixer]
	input1 =  _piano2_toggle_led
	input2 =  _piano1_L24 + _piano2_L24
	input3 =  _piano3_L24 + _piano4_L24
	input4 = _menu3_semitrans_down * _semitrans_down_led24_dim
	input5 = _menu3_semitrans_up * _semitrans_up_led24_dim
	input6 = _menu4_accent_dim
	input7 = _allmenus_L24
	maximum = L2.4

[mixer]
	input1 = _menu1_L25 * _menu1
	input2 = _menu2_L25_dim * _menu2_piano_off
	input3 = _menu4_L25 * _menu4
	input4 = _menu5_L25 * L1.5
	input5 = _menu6_L25 * _submenu6_off
	input6 = _slide3 * _submenu6_on
	input7 = _menu8_L25 * _menu8_led + _save_blink4
	input8 = _semitrans_down_blink
	maximum = _allmenus_L25
[mixer]
	input1 =  _piano1_L25 + _piano2_L25
	input2 =  _piano3_L25 + _piano4_L25
	input3 = _menu3_semitrans_down * _semitrans_down_led25_dim
	input4 = _menu3_semitrans_up * _semitrans_up_led25_dim
	input5 =  _semitrans_down_toggle_led
	input6 = _channel3_inactive_dim * _menu1
	input7 = _algo3_gate_active * _menu4
	input8 = _allmenus_L25
	maximum = L2.5

[mixer]
	input1 = _menu1_L26 * _menu1
	input2 = _menu4_L26_dim * _menu4
	input3 = _menu5_L26 * L1.5 + _channel3_show_blink
	input4 = _menu6_L26 * _submenu6_off
	input5 = _menu8_L26 * _menu8_led + _save_blink5
	input6 = _semitrans_up_blink
	maximum = _allmenus_L26
[mixer]
	input1 =  _piano3_toggle_led
	input2 =  _piano1_L26 + _piano2_L26
	input3 =  _piano3_L26 + _piano4_L26
	input4 = _menu3_semitrans_down * _semitrans_down_led26_dim
	input5 = _menu3_semitrans_up * _semitrans_up_led26_dim
	input6 =  _semitrans_up_toggle_led
	input7 = _allmenus_L26
	maximum = L2.6

[mixer]
	input1 = _menu1_L27 * _menu1
	input2 = _menu2_L27_dim * _menu2_piano_off
	input3 = _rotate_backward_led
	input4 = _menu4_L27 * _menu4
	input5 = _menu5_L27 * L1.5
	input6 = _menu6_L27 * _submenu6_off
	input7 = _slide4 * _submenu6_on
	input8 = _menu8_L27 * _menu8_led + _save_blink6
	maximum = _allmenus_L27
[mixer]
	input1 =  _piano1_L27 + _piano2_L27
	input2 =  _piano3_L27 + _piano4_L27
	input3 = _menu3_semitrans_down * _semitrans_down_led27_dim
	input4 = _menu3_semitrans_up * _semitrans_up_led27_dim
	input5 = _rotate_triggerdelay0 * _menu3_semitrans_off
	input6 = _channel4_inactive_dim * _menu1
	input7 = _algo4_gate_active * _menu4
	input8 = _allmenus_L27
	maximum = L2.7

[mixer]
	input1 = _menu1_L28 * _menu1
	input2 = _menu2_L28 * L1.2
	input3 = _rotate_forward_led
	input4 = _menu4_L28 * _menu4
	input5 = _menu5_L28 * L1.5 + _channel4_show_blink
 	input6 = _menu6_L28 * _submenu6_off
	input7 = _menu8_L28 * _menu8_led + _save_blink7
	maximum = _allmenus_L28
[mixer]
	input1 = _menu3_semitrans_down * _semitrans_down_led28_dim
	input2 = _menu3_semitrans_up * _semitrans_up_led28_dim
	input3 =  _piano4_toggle_led
	input4 = _allmenus_L28
	maximum = L2.8

### button group for menus 1-6
[buttongroup]
	button1 = B1.1
	button2 = B1.2
	button3 = B1.3
	button4 = B1.4
	button5 = B1.5
	button6 = B1.6
	button8 = B1.8
	led3 = L1.3
	led5 = L1.5
	buttonoutput1 = _menu1
	buttonoutput2 = _menu2
#	buttonoutput3 = _menu3
	buttonoutput4 = _menu4
#	buttonoutput5 = _menu5
	buttonoutput6 = _menu6
	buttonoutput8 = _menu8
	buttonpress = _menus_buttonpress
	longpress = _menus_longpress

### Long press of B1.1 triggers a global clear of all algo sequences and random seeds. Useful after initialization of the patch, as the algoquencers will automatically load some random sequences. After initialization though, the entire state of the patch is saved to the droid memory and loaded after reboot. 
[button]
	button = B1.1
	longpress = _clear
[contour]
	trigger = _clear
	attack = 0
	release = 0
	hold = 2
	output = _clear_on
[lfo]
	# animation
	hz = 8
	square = _lfo
[copy]
	input = _clear_on * _lfo
	inverted = _clear_blink
[copy]
	input = _menu1 * _clear_blink
	output = L1.1

### in menu1 also show progressing barleds
[mixer]
	input1 = _menu2
	input2 = _barled1 * _menu1
	maximum = L1.2
[mixer]
	input1 = _menu4
	input2 = _barled2 * _menu1
	output = L1.4

[compare] # animation for sub-menu 6
	input = _submenu6
	compare = 2
	ifequal = _state_lfo
	else = 1
	output = _submenu6_lfo
[mixer]
	input1 = _menu6 * _submenu6_lfo
	input2 = _barled3 * _menu1
	output = L1.6

### leds for save/load menu
[copy]
	input = _menu8 * _menus_buttonpress
	output = _menu8_buttonpress
[copy]
	input = _menu8
	inverted = _menu8_inv
[triggerdelay]
	input = _menu8_buttonpress * _menu8_off
	delay = 0.3
	output = _menu8_activate
[switch]
	reset = _menu8_inv # This is a gate signal, but the rising edge works fine for reset.
	input1 = 0
	input2 = 1
	forward = _menu8_activate
	output = _menu8_on
[copy]
	input = _menu8_on
	inverted = _menu8_off
[button]
	button = B1.8
	select = _menu8 * _menu8_on
	offvalue = 0.1
	output = _menu8_dim_button
[copy]
	input = _menu8_dim_button * _menu8
	output = _menu8_dim
[mixer]
	input1 = _menu8_dim
	input2 = _barled4 * _menu1
	output = L1.8
[compare]
	input = _menu8_dim
	compare = 1.0
	precision = 0.05
	output = _bank1
[compare]
	input = _menu8_dim
	compare = 0.1
	precision = 0.05
	output = _bank2

### global mute button
[button]
	button = B1.7
	states = 1
	output = _global_mute
[switch]
	# defining the global mute states on/off
	input1 = 1
	input2 = 0
	forward = _global_mute + _global_mute_switch
	output = _global_mute_state_on
[copy]
	input = _global_mute_state_on
	inverted = _global_mute_state_off
[copy]
	# global mute trigger to switch individual channels on/off
	input = _global_mute * _global_mute_state_on
	output = _global_mute_trigger_on
[copy]
	input = _global_mute * _global_mute_state_off
	output = _global_mute_trigger_off
[mixer]
	# adjustment of global mute led when all channels get manually unmuted
	input1 = _menu1_L21 * _global_mute_state_on
 	input2 = _menu1_L23 * _global_mute_state_on
	input3 = _menu1_L25 * _global_mute_state_on
	input4 = _menu1_L27 * _global_mute_state_on
	maximum = L1.7
[compare]
	# sending a trigger to also adjust the global mute state
	input = L1.7
	compare = _global_mute_state_off
	output = _global_mute_switch_off
[mixer]
	# adjustment of global mute led when all channels get manually muted
	input1 = _menu1_L21_inv * _global_mute_state_off
 	input2 = _menu1_L23_inv * _global_mute_state_off
	input3 = _menu1_L25_inv * _global_mute_state_off
	input4 = _menu1_L27_inv * _global_mute_state_off
	maximum = _all_channels_muted
[copy]
	input = _all_channels_muted
	inverted = L1.7
[compare]
	# sending a trigger to also adjust the global mute state
	input = L1.7
	compare = _global_mute_state_off
	output = _global_mute_switch_on
[mixer]
	# combining both triggers to finally adjust the global mute state
	input1 = _global_mute_switch_on
	input2 = _global_mute_switch_off
	output = _global_mute_switch

### buttons for muting individual channels
# channel 1
[button]
	button = B2.1
	select = _menu1
	states = 1
	output = _algo1_mute
[button]
	button = B2.2
	select = _menu1
	states = 1
	output = _algo1_unmute
[mixer]
	input1 = _algo1_mute
	input2 = _global_mute_trigger_on * _menu1_L21_inv
	input3 = _global_mute_trigger_off * _menu1_L21
	output = _algo1_mute_toggle

# channel 2
[button]
	button = B2.3
	select = _menu1
	states = 1
	output = _algo2_mute
[button]
	button = B2.4
	select = _menu1
	states = 1
	output = _algo2_unmute
[mixer]
	input1 = _algo2_mute
	input2 = _global_mute_trigger_on * _menu1_L23_inv
	input3 = _global_mute_trigger_off * _menu1_L23
	output = _algo2_mute_toggle

# channel 3
[button]
	button = B2.5
	select = _menu1
	states = 1
	output = _algo3_mute
[button]
	button = B2.6
	select = _menu1
	states = 1
	output = _algo3_unmute
[mixer]
	input1 = _algo3_mute
	input2 = _global_mute_trigger_on * _menu1_L25_inv
	input3 = _global_mute_trigger_off * _menu1_L25
	output = _algo3_mute_toggle

# channel 4
[button]
	button = B2.7
	select = _menu1
	states = 1
	output = _algo4_mute
[button]
	button = B2.8
	select = _menu1
	states = 1
	output = _algo4_unmute
[mixer]
	input1 = _algo4_mute
	input2 = _global_mute_trigger_on * _menu1_L27_inv
	input3 = _global_mute_trigger_off * _menu1_L27
	output = _algo4_mute_toggle

### buttons to set channel priority
[button]
	button = B1.2
	select = _menu2
	states = 1
	output = _menu2_reset
	
# channel 1 prio
[random]
	clock = _random_prio_trigger
	minimum = 1 * _random_prio_on
	maximum = 4 * _random_prio_on
	steps = 4
	output = _random1_prio
[button]
	button = B2.1
	select = _menu2_piano_off
	preset = _preset
	loadpreset = _load
	savepreset = _save
	states = 4
	value1 = 4 * _random_prio_off + _random1_prio
	value2 = 3 * _random_prio_off + _random1_prio
	value3 = 2 * _random_prio_off + _random1_prio
	value4 = 1 * _random_prio_off + _random1_prio
	output = _channel1_prio_tmp
[superjust]
	# adjust led brightness
	bypass = 1
	input1 = _channel1_prio_tmp - 1
	output1 = _channel1_prio_minus1
	input2 = _channel1_prio_minus1 / 3
	output2 = _channel1_prio_map
	input3 = _channel1_prio_map * _channel1_prio_map
	output3 = _menu2_L21_dim

# channel 2 prio
[random]
	clock = _random_prio_trigger
	minimum = 1 * _random_prio_on
	maximum = 4 * _random_prio_on
	steps = 4
	output = _random2_prio
[button]
	button = B2.3
	select = _menu2_piano_off
	preset = _preset
	loadpreset = _load
	savepreset = _save
	states = 4
	value1 = 4 * _random_prio_off + _random2_prio
	value2 = 3 * _random_prio_off + _random2_prio
	value3 = 2 * _random_prio_off + _random2_prio
	value4 = 1 * _random_prio_off + _random2_prio
	output = _channel2_prio_tmp
[superjust]
	bypass = 1
	input1 = _channel2_prio_tmp - 1
	output1 = _channel2_prio_minus1
	input2 = _channel2_prio_minus1 / 3
	output2 = _channel2_prio_map
	input3 = _channel2_prio_map * _channel2_prio_map
	output3 = _menu2_L23_dim

# channel 3 prio
[random]
	clock = _random_prio_trigger
	minimum = 1 * _random_prio_on
	maximum = 4 * _random_prio_on
	steps = 4
	output = _random3_prio
[button]
	button = B2.5
	select = _menu2_piano_off
	preset = _preset
	loadpreset = _load
	savepreset = _save
	states = 4
	value1 = 4 * _random_prio_off + _random3_prio
	value2 = 3 * _random_prio_off + _random3_prio
	value3 = 2 * _random_prio_off + _random3_prio
	value4 = 1 * _random_prio_off + _random3_prio
	output = _channel3_prio_tmp
[superjust]
	bypass = 1
	input1 = _channel3_prio_tmp - 1
	output1 = _channel3_prio_minus1
	input2 = _channel3_prio_minus1 / 3
	output2 = _channel3_prio_map
	input3 = _channel3_prio_map * _channel3_prio_map
	output3 = _menu2_L25_dim

# channel4 prio
[random]
	clock = _random_prio_trigger
	minimum = 1 * _random_prio_on
	maximum = 4 * _random_prio_on
	steps = 4
	output = _random4_prio
[button]
	button = B2.7
	select = _menu2_piano_off
	preset = _preset
	loadpreset = _load
	savepreset = _save
	states = 4
	value1 = 4 * _random_prio_off + _random4_prio
	value2 = 3 * _random_prio_off + _random4_prio
	value3 = 2 * _random_prio_off + _random4_prio
	value4 = 1 * _random_prio_off + _random4_prio
	output = _channel4_prio_tmp
[superjust]
	bypass = 1
	input1 = _channel4_prio_tmp - 1
	output1 = _channel4_prio_minus1
	input2 = _channel4_prio_minus1 / 3
	output2 = _channel4_prio_map
	input3 = _channel4_prio_map * _channel4_prio_map
	output3 = _menu2_L27_dim

# asure that if some channels share the same priority, these are prioritized by their channel number: channel 1 has highest prio, channel 4 has lowest prio
[superjust]
	input1 = _channel1_prio_tmp * 4 - 1
	input2 = _channel2_prio_tmp * 4 - 2
	input3 = _channel3_prio_tmp * 4 - 3
	input4 = _channel4_prio_tmp * 4 - 4
	output1 = _channel1_prio
	output2 = _channel2_prio
	output3 = _channel3_prio
	output4 = _channel4_prio
	
### buttons to select notes 1-4 by emulating a piano roll
# select note 1
[button]
	button = B2.2
	select = _menu2_piano_off
	states = 1
	led = _piano1_toggle_led_tmp
	output = _piano1_toggle_tmp
[copy]
	input = _piano1_toggle_led_tmp * 0.25
	output = _piano1_toggle_led
[triggerdelay]
	input = _piano1_toggle_tmp
	delay = 0.3
	output = _piano1_toggle
[switch]
	reset = _menu2_reset
	input1 = 0
	input2 = 1
	forward = _piano1_toggle
	output = _piano1_on
[copy]
	input = _piano1_on
	inverted = _piano1_off

# channel1 switch between the lower and upper parts of the piano roll
[button]
	button = B2.8
	select = _menu2 * _piano1_on
	output = _piano1_CtoF
[copy]
	input = _piano1_CtoF
	inverted = _piano1_GtoC
[copy]
	input = _menu2 * _piano1_on
	output = _menu2_piano1_on

# channel1 button to set the octave: 3V +/-1V
[button]
	button = B2.2
	select = _menu2_piano1_on * _piano1_CtoF
	preset = _preset
	loadpreset = _load
	savepreset = _save
	states = 3
	value1 = 0.2
	value2 = 0.3
	value3 = 0.4
	output = _piano1_octave

# channel1 buttons for piano roll
[buttongroup]
	select = _menu2_piano1_on * _piano1_CtoF
	preset = _preset
	loadpreset = _load
	savepreset = _save
	minactive = _piano1_CtoF_off # Once a note has been chosen in the CtoF or GtoC parts, it stays on until I manually either turn it off again or chose another note in that part. Which of the parts will finally be audible is decided by the latest note selection. Now e.g. when the 2nd part is audible and I change the piano view to the 1st part, all leds are turned dark (later in the patch), even though one note in that part might be on in the background because it has been chosen earlier. If I would like to choose this note again, a button press would rather deactivate this note as long as minactive would be 0. Therefore, to asure that a reselection of a note will not turn that note off, I set minactive temporarily to 1. This changes back to 0 as soon as I press any button in that part of the piano, to also enable complete deselction (all notes off in both parts of the channel).
	button1 = B2.1
	button2 = B2.4
	button3 = B2.3
	button4 = B2.6
	button5 = B2.5
	button6 = B2.7
	led1 = _piano1_CtoF_led1
	led2 = _piano1_CtoF_led2
	led3 = _piano1_CtoF_led3
	led4 = _piano1_CtoF_led4
	led5 = _piano1_CtoF_led5
	led6 = _piano1_CtoF_led6
	value1 = _piano1_octave # C3?
	value2 = 0.1 / 12 + _piano1_octave
	value3 = 0.2 / 12 + _piano1_octave
	value4 = 0.3 / 12 + _piano1_octave
	value5 = 0.4 / 12 + _piano1_octave
	value6 = 0.5 / 12 + _piano1_octave
	output = _pitch1_CtoF
	buttonpress = _piano1_CtoF_press
[buttongroup]
	select = _menu2_piano1_on * _piano1_GtoC
	preset = _preset
	loadpreset = _load
	savepreset = _save
	minactive = _piano1_CtoF_on
	button1 = B2.2
	button2 = B2.1
	button3 = B2.4
	button4 = B2.3
	button5 = B2.6
	button6 = B2.5
	button7 = B2.7
	led1 = _piano1_GtoC_led1
	led2 = _piano1_GtoC_led2
	led3 = _piano1_GtoC_led3
	led4 = _piano1_GtoC_led4
	led5 = _piano1_GtoC_led5
	led6 = _piano1_GtoC_led6
	led7 = _piano1_GtoC_led7
	value1 = 0.6 / 12 + _piano1_octave # C3?
	value2 = 0.7 / 12 + _piano1_octave
	value3 = 0.8 / 12 + _piano1_octave
	value4 = 0.9 / 12 + _piano1_octave
	value5 = 1.0 / 12 + _piano1_octave
	value6 = 1.1 / 12 + _piano1_octave
	value7 = 1.2 / 12 + _piano1_octave
	output = _pitch1_GtoC
	buttonpress = _piano1_GtoC_press
[mixer]
	input1 = _piano1_CtoF_press * _piano1_CtoF_off
	input2 = _piano1_GtoC_press * _piano1_CtoF_on
	output = _piano1_buttonpress
[button]
	button = _piano1_buttonpress
	preset = _preset
	loadpreset = _load
	savepreset = _save
	led = _piano1_CtoF_on
[copy]
	input = _piano1_CtoF_on
	inverted = _piano1_CtoF_off
[mixer]
	# route the latest note selection to the channel pitch
	input1 = _pitch1_CtoF * _piano1_CtoF_on
	input2 = _pitch1_GtoC * _piano1_CtoF_off
	output = _channel1_pitch
[compare]
	# If no note has been chosen, the channel is deactivated and therefore not affected by the local/global mute buttons. An inactive channel is indicated in the mute menu (menu1) by a dimmed led, reminding you that if you cannot hear any notes from this channel, it is not related to priority or activity settings.
	input = _channel1_pitch
	compare = 0
	ifequal = 0
	else = 1
	output = _channel1_active
[copy]
	input = _channel1_active
	inverted = _channel1_inactive
[copy]
	input = _channel1_inactive * 0.05
	output = _channel1_inactive_dim

[superjust]
	bypass = 1
	input1 = _piano1_GtoC_led1 * _piano1_CtoF_off + 0.1
	output1 = _piano1_GtoC_L22_tmp
	input2 = _piano1_GtoC_L22_tmp * _piano1_GtoC
	output2 = _piano1_L22_tmp
	input3 = _piano1_L22_tmp * _menu2_piano1_on
	output3 = _piano1_L22
	input4 = _piano1_CtoF_led1 * _piano1_CtoF_on + 0.1
	output4 = _piano1_CtoF_L21_tmp
	input5 = _piano1_GtoC_led2 * _piano1_CtoF_off + 0.1
	output5 = _piano1_GtoC_L21_tmp
	input6 = _piano1_CtoF_led3 * _piano1_CtoF_on + 0.1
	output6 = _piano1_CtoF_L23_tmp
	input7 = _piano1_GtoC_led4 * _piano1_CtoF_off + 0.1
	output7 = _piano1_GtoC_L23_tmp
[superjust]
	bypass = 1
	input1 = _piano1_CtoF_led2 * _piano1_CtoF_on + 0.1
	output1 = _piano1_CtoF_L24_tmp
	input2 = _piano1_GtoC_led3 * _piano1_CtoF_off + 0.1
	output2 = _piano1_GtoC_L24_tmp
	input3 = _piano1_CtoF_led5 * _piano1_CtoF_on + 0.1
	output3 = _piano1_CtoF_L25_tmp
	input4 = _piano1_GtoC_led6 * _piano1_CtoF_off + 0.1
	output4 = _piano1_GtoC_L25_tmp
	input5 = _piano1_CtoF_led4 * _piano1_CtoF_on + 0.1
	output5 = _piano1_CtoF_L26_tmp
	input6 = _piano1_GtoC_led5 * _piano1_CtoF_off + 0.1
	output6 = _piano1_GtoC_L26_tmp
	input7 = _piano1_CtoF_led6 * _piano1_CtoF_on + 0.1
	output7 = _piano1_CtoF_L27_tmp
	input8 = _piano1_GtoC_led7 * _piano1_CtoF_off + 0.1
	output8 = _piano1_GtoC_L27_tmp
[mixer]
	input1 = _piano1_CtoF_L21_tmp * _piano1_CtoF
	input2 = _piano1_GtoC_L21_tmp * _piano1_GtoC
	maximum = _piano1_L21_tmp
[mixer]
	input1 = _piano1_CtoF_L23_tmp * _piano1_CtoF
	input2 = _piano1_GtoC_L23_tmp * _piano1_GtoC
	maximum = _piano1_L23_tmp
[mixer]
	input1 = _piano1_CtoF_L24_tmp * _piano1_CtoF
	input2 = _piano1_GtoC_L24_tmp * _piano1_GtoC
	maximum = _piano1_L24_tmp
[mixer]
	input1 = _piano1_CtoF_L25_tmp * _piano1_CtoF
	input2 = _piano1_GtoC_L25_tmp * _piano1_GtoC
	maximum = _piano1_L25_tmp
[mixer]
	input1 = _piano1_CtoF_L26_tmp * _piano1_CtoF
	input2 = _piano1_GtoC_L26_tmp * _piano1_GtoC
	maximum = _piano1_L26_tmp
[mixer]
	input1 = _piano1_CtoF_L27_tmp * _piano1_CtoF
	input2 = _piano1_GtoC_L27_tmp * _piano1_GtoC
	maximum = _piano1_L27_tmp
[superjust]
	bypass = 1
	input1 = _piano1_L21_tmp * _menu2_piano1_on
	output1 = _piano1_L21
	input2 = _piano1_L23_tmp * _menu2_piano1_on
	output2 = _piano1_L23
	input3 = _piano1_L24_tmp * _menu2_piano1_on
	output3 = _piano1_L24
	input4 = _piano1_L25_tmp * _menu2_piano1_on
	output4 = _piano1_L25
	input5 = _piano1_L26_tmp * _menu2_piano1_on
	output5 = _piano1_L26
	input6 = _piano1_L27_tmp * _menu2_piano1_on
	output6 = _piano1_L27

# select note 2
[button]
	button = B2.4
	select = _menu2_piano_off
	states = 1
	led = _piano2_toggle_led_tmp
	output = _piano2_toggle_tmp
[copy]
	input = _piano2_toggle_led_tmp * 0.25
	output = _piano2_toggle_led
[triggerdelay]
	input = _piano2_toggle_tmp
	delay = 0.3
	output = _piano2_toggle
[switch]
	reset = _menu2_reset
	input1 = 0
	input2 = 1
	forward = _piano2_toggle
	output = _piano2_on
[copy]
	input = _piano2_on
	inverted = _piano2_off

# channel2 switch between the lower and upper parts of the piano roll
[button]
	button = B2.8
	select = _menu2 * _piano2_on
	output = _piano2_CtoF
[copy]
	input = _piano2_CtoF
	inverted = _piano2_GtoC
[copy]
	input = _menu2 * _piano2_on
	output = _menu2_piano2_on

# channel2 button to set the octave: 3V +/-1V
[button]
	button = B2.2
	select = _menu2_piano2_on * _piano2_CtoF
	preset = _preset
	loadpreset = _load
	savepreset = _save
	states = 3
	value1 = 0.2
	value2 = 0.3
	value3 = 0.4
	output = _piano2_octave

# channel2 buttons for piano roll
[buttongroup]
	select = _menu2_piano2_on * _piano2_CtoF
	preset = _preset
	loadpreset = _load
	savepreset = _save
	minactive = _piano2_CtoF_off
	button1 = B2.1
	button2 = B2.4
	button3 = B2.3
	button4 = B2.6
	button5 = B2.5
	button6 = B2.7
	led1 = _piano2_CtoF_led1
	led2 = _piano2_CtoF_led2
	led3 = _piano2_CtoF_led3
	led4 = _piano2_CtoF_led4
	led5 = _piano2_CtoF_led5
	led6 = _piano2_CtoF_led6
	value1 = _piano2_octave
	value2 = 0.1 / 12 + _piano2_octave
	value3 = 0.2 / 12 + _piano2_octave
	value4 = 0.3 / 12 + _piano2_octave
	value5 = 0.4 / 12 + _piano2_octave
	value6 = 0.5 / 12 + _piano2_octave
	output = _pitch2_CtoF
	buttonpress = _piano2_CtoF_press
[buttongroup]
	select = _menu2_piano2_on * _piano2_GtoC
	preset = _preset
	loadpreset = _load
	savepreset = _save
	minactive = _piano2_CtoF_on
	button1 = B2.2
	button2 = B2.1
	button3 = B2.4
	button4 = B2.3
	button5 = B2.6
	button6 = B2.5
	button7 = B2.7
	led1 = _piano2_GtoC_led1
	led2 = _piano2_GtoC_led2
	led3 = _piano2_GtoC_led3
	led4 = _piano2_GtoC_led4
	led5 = _piano2_GtoC_led5
	led6 = _piano2_GtoC_led6
	led7 = _piano2_GtoC_led7
	value1 = 0.6 / 12 + _piano2_octave
	value2 = 0.7 / 12 + _piano2_octave
	value3 = 0.8 / 12 + _piano2_octave
	value4 = 0.9 / 12 + _piano2_octave
	value5 = 1.0 / 12 + _piano2_octave
	value6 = 1.1 / 12 + _piano2_octave
	value7 = 1.2 / 12 + _piano2_octave
	output = _pitch2_GtoC
	buttonpress = _piano2_GtoC_press
[mixer]
	input1 = _piano2_CtoF_press * _piano2_CtoF_off
	input2 = _piano2_GtoC_press * _piano2_CtoF_on
	output = _piano2_buttonpress
[button]
	button = _piano2_buttonpress
	preset = _preset
	loadpreset = _load
	savepreset = _save
	led = _piano2_CtoF_on
[copy]
	input = _piano2_CtoF_on
	inverted = _piano2_CtoF_off
[mixer]
	# route the latest note selection to the channel pitch
	input1 = _pitch2_CtoF * _piano2_CtoF_on
	input2 = _pitch2_GtoC * _piano2_CtoF_off
	output = _channel2_pitch
[compare]
	input = _channel2_pitch
	compare = 0
	ifequal = 0
	else = 1
	output = _channel2_active
[copy]
	input = _channel2_active
	inverted = _channel2_inactive
[copy]
	input = _channel2_inactive * 0.05
	output = _channel2_inactive_dim

[superjust]
	bypass = 1
	input1 = _piano2_GtoC_led1 * _piano2_CtoF_off + 0.1
	output1 = _piano2_GtoC_L22_tmp
	input2 = _piano2_GtoC_L22_tmp * _piano2_GtoC
	output2 = _piano2_L22_tmp
	input3 = _piano2_L22_tmp * _menu2_piano2_on
	output3 = _piano2_L22
	input4 = _piano2_CtoF_led1 * _piano2_CtoF_on + 0.1
	output4 = _piano2_CtoF_L21_tmp
	input5 = _piano2_GtoC_led2 * _piano2_CtoF_off + 0.1
	output5 = _piano2_GtoC_L21_tmp
	input6 = _piano2_CtoF_led3 * _piano2_CtoF_on + 0.1
	output6 = _piano2_CtoF_L23_tmp
	input7 = _piano2_GtoC_led4 * _piano2_CtoF_off + 0.1
	output7 = _piano2_GtoC_L23_tmp
[superjust]
	bypass = 1
	input1 = _piano2_CtoF_led2 * _piano2_CtoF_on + 0.1
	output1 = _piano2_CtoF_L24_tmp
	input2 = _piano2_GtoC_led3 * _piano2_CtoF_off + 0.1
	output2 = _piano2_GtoC_L24_tmp
	input3 = _piano2_CtoF_led5 * _piano2_CtoF_on + 0.1
	output3 = _piano2_CtoF_L25_tmp
	input4 = _piano2_GtoC_led6 * _piano2_CtoF_off + 0.1
	output4 = _piano2_GtoC_L25_tmp
	input5 = _piano2_CtoF_led4 * _piano2_CtoF_on + 0.1
	output5 = _piano2_CtoF_L26_tmp
	input6 = _piano2_GtoC_led5 * _piano2_CtoF_off + 0.1
	output6 = _piano2_GtoC_L26_tmp
	input7 = _piano2_CtoF_led6 * _piano2_CtoF_on + 0.1
	output7 = _piano2_CtoF_L27_tmp
	input8 = _piano2_GtoC_led7 * _piano2_CtoF_off + 0.1
	output8 = _piano2_GtoC_L27_tmp
[mixer]
	input1 = _piano2_CtoF_L21_tmp * _piano2_CtoF
	input2 = _piano2_GtoC_L21_tmp * _piano2_GtoC
	maximum = _piano2_L21_tmp
[mixer]
	input1 = _piano2_CtoF_L23_tmp * _piano2_CtoF
	input2 = _piano2_GtoC_L23_tmp * _piano2_GtoC
	maximum = _piano2_L23_tmp
[mixer]
	input1 = _piano2_CtoF_L24_tmp * _piano2_CtoF
	input2 = _piano2_GtoC_L24_tmp * _piano2_GtoC
	maximum = _piano2_L24_tmp
[mixer]
	input1 = _piano2_CtoF_L25_tmp * _piano2_CtoF
	input2 = _piano2_GtoC_L25_tmp * _piano2_GtoC
	maximum = _piano2_L25_tmp
[mixer]
	input1 = _piano2_CtoF_L26_tmp * _piano2_CtoF
	input2 = _piano2_GtoC_L26_tmp * _piano2_GtoC
	maximum = _piano2_L26_tmp
[mixer]
	input1 = _piano2_CtoF_L27_tmp * _piano2_CtoF
	input2 = _piano2_GtoC_L27_tmp * _piano2_GtoC
	maximum = _piano2_L27_tmp
[superjust]
	bypass = 1
	input1 = _piano2_L21_tmp * _menu2_piano2_on
	output1 = _piano2_L21
	input2 = _piano2_L23_tmp * _menu2_piano2_on
	output2 = _piano2_L23
	input3 = _piano2_L24_tmp * _menu2_piano2_on
	output3 = _piano2_L24
	input4 = _piano2_L25_tmp * _menu2_piano2_on
	output4 = _piano2_L25
[superjust]
	bypass = 1
	input1 = _piano2_L26_tmp * _menu2_piano2_on
	output1 = _piano2_L26
	input2 = _piano2_L27_tmp * _menu2_piano2_on
	output2 = _piano2_L27

# select note 3
[button]
	button = B2.6
	select = _menu2_piano_off
	states = 1
	led = _piano3_toggle_led_tmp
	output = _piano3_toggle_tmp
[copy]
	input = _piano3_toggle_led_tmp * 0.25
	output = _piano3_toggle_led
[triggerdelay]
	input = _piano3_toggle_tmp
	delay = 0.3
	output = _piano3_toggle
[switch]
	reset = _menu2_reset
	input1 = 0
	input2 = 1
	forward = _piano3_toggle
	output = _piano3_on
[copy]
	input = _piano3_on
	inverted = _piano3_off

# channel3 switch between the lower and upper parts of the piano roll
[button]
	button = B2.8
	select = _menu2 * _piano3_on
	output = _piano3_CtoF
[copy]
	input = _piano3_CtoF
	inverted = _piano3_GtoC
[copy]
	input = _menu2 * _piano3_on
	output = _menu2_piano3_on

# channel3 button to set the octave: 3V +/-1V
[button]
	button = B2.2
	select = _menu2_piano3_on * _piano3_CtoF
	preset = _preset
	loadpreset = _load
	savepreset = _save
	states = 3
	value1 = 0.2
	value2 = 0.3
	value3 = 0.4
	output = _piano3_octave

# channel3 buttons for piano roll
[buttongroup]
	select = _menu2_piano3_on * _piano3_CtoF
	preset = _preset
	loadpreset = _load
	savepreset = _save
	minactive = _piano3_CtoF_off
	button1 = B2.1
	button2 = B2.4
	button3 = B2.3
	button4 = B2.6
	button5 = B2.5
	button6 = B2.7
	led1 = _piano3_CtoF_led1
	led2 = _piano3_CtoF_led2
	led3 = _piano3_CtoF_led3
	led4 = _piano3_CtoF_led4
	led5 = _piano3_CtoF_led5
	led6 = _piano3_CtoF_led6
	value1 = _piano3_octave
	value2 = 0.1 / 12 + _piano3_octave
	value3 = 0.2 / 12 + _piano3_octave
	value4 = 0.3 / 12 + _piano3_octave
	value5 = 0.4 / 12 + _piano3_octave
	value6 = 0.5 / 12 + _piano3_octave
	output = _pitch3_CtoF
	buttonpress = _piano3_CtoF_press
[buttongroup]
	select = _menu2_piano3_on * _piano3_GtoC
	preset = _preset
	loadpreset = _load
	savepreset = _save
	minactive = _piano3_CtoF_on
	button1 = B2.2
	button2 = B2.1
	button3 = B2.4
	button4 = B2.3
	button5 = B2.6
	button6 = B2.5
	button7 = B2.7
	led1 = _piano3_GtoC_led1
	led2 = _piano3_GtoC_led2
	led3 = _piano3_GtoC_led3
	led4 = _piano3_GtoC_led4
	led5 = _piano3_GtoC_led5
	led6 = _piano3_GtoC_led6
	led7 = _piano3_GtoC_led7
	value1 = 0.6 / 12 + _piano3_octave
	value2 = 0.7 / 12 + _piano3_octave
	value3 = 0.8 / 12 + _piano3_octave
	value4 = 0.9 / 12 + _piano3_octave
	value5 = 1.0 / 12 + _piano3_octave
	value6 = 1.1 / 12 + _piano3_octave
	value7 = 1.2 / 12 + _piano3_octave
	output = _pitch3_GtoC
	buttonpress = _piano3_GtoC_press
[mixer]
	input1 = _piano3_CtoF_press * _piano3_CtoF_off
	input2 = _piano3_GtoC_press * _piano3_CtoF_on
	output = _piano3_buttonpress
[button]
	button = _piano3_buttonpress
	preset = _preset
	loadpreset = _load
	savepreset = _save
	led = _piano3_CtoF_on
[copy]
	input = _piano3_CtoF_on
	inverted = _piano3_CtoF_off
[mixer]
	# route the latest note selection to the channel pitch
	input1 = _pitch3_CtoF * _piano3_CtoF_on
	input2 = _pitch3_GtoC * _piano3_CtoF_off
	output = _channel3_pitch
[compare]
	input = _channel3_pitch
	compare = 0
	ifequal = 0
	else = 1
	output = _channel3_active
[copy]
	input = _channel3_active
	inverted = _channel3_inactive
[copy]
	input = _channel3_inactive * 0.05
	output = _channel3_inactive_dim

[superjust]
	bypass = 1
	input1 = _piano3_GtoC_led1 * _piano3_CtoF_off + 0.1
	output1 = _piano3_GtoC_L22_tmp
	input2 = _piano3_GtoC_L22_tmp * _piano3_GtoC
	output2 = _piano3_L22_tmp
	input3 = _piano3_L22_tmp * _menu2_piano3_on
	output3 = _piano3_L22
	input4 = _piano3_CtoF_led1 * _piano3_CtoF_on + 0.1
	output4 = _piano3_CtoF_L21_tmp
	input5 = _piano3_GtoC_led2 * _piano3_CtoF_off + 0.1
	output5 = _piano3_GtoC_L21_tmp
	input6 = _piano3_CtoF_led3 * _piano3_CtoF_on + 0.1
	output6 = _piano3_CtoF_L23_tmp
	input7 = _piano3_GtoC_led4 * _piano3_CtoF_off + 0.1
	output7 = _piano3_GtoC_L23_tmp
[superjust]
	bypass = 1
	input1 = _piano3_CtoF_led2 * _piano3_CtoF_on + 0.1
	output1 = _piano3_CtoF_L24_tmp
	input2 = _piano3_GtoC_led3 * _piano3_CtoF_off + 0.1
	output2 = _piano3_GtoC_L24_tmp
	input3 = _piano3_CtoF_led5 * _piano3_CtoF_on + 0.1
	output3 = _piano3_CtoF_L25_tmp
	input4 = _piano3_GtoC_led6 * _piano3_CtoF_off + 0.1
	output4 = _piano3_GtoC_L25_tmp
	input5 = _piano3_CtoF_led4 * _piano3_CtoF_on + 0.1
	output5 = _piano3_CtoF_L26_tmp
	input6 = _piano3_GtoC_led5 * _piano3_CtoF_off + 0.1
	output6 = _piano3_GtoC_L26_tmp
	input7 = _piano3_CtoF_led6 * _piano3_CtoF_on + 0.1
	output7 = _piano3_CtoF_L27_tmp
	input8 = _piano3_GtoC_led7 * _piano3_CtoF_off + 0.1
	output8 = _piano3_GtoC_L27_tmp
[mixer]
	input1 = _piano3_CtoF_L21_tmp * _piano3_CtoF
	input2 = _piano3_GtoC_L21_tmp * _piano3_GtoC
	maximum = _piano3_L21_tmp
[mixer]
	input1 = _piano3_CtoF_L23_tmp * _piano3_CtoF
	input2 = _piano3_GtoC_L23_tmp * _piano3_GtoC
	maximum = _piano3_L23_tmp
[mixer]
	input1 = _piano3_CtoF_L24_tmp * _piano3_CtoF
	input2 = _piano3_GtoC_L24_tmp * _piano3_GtoC
	maximum = _piano3_L24_tmp
[mixer]
	input1 = _piano3_CtoF_L25_tmp * _piano3_CtoF
	input2 = _piano3_GtoC_L25_tmp * _piano3_GtoC
	maximum = _piano3_L25_tmp
[mixer]
	input1 = _piano3_CtoF_L26_tmp * _piano3_CtoF
	input2 = _piano3_GtoC_L26_tmp * _piano3_GtoC
	maximum = _piano3_L26_tmp
[mixer]
	input1 = _piano3_CtoF_L27_tmp * _piano3_CtoF
	input2 = _piano3_GtoC_L27_tmp * _piano3_GtoC
	maximum = _piano3_L27_tmp
[superjust]
	bypass = 1
	input1 = _piano3_L21_tmp * _menu2_piano3_on
	output1 = _piano3_L21
	input2 = _piano3_L23_tmp * _menu2_piano3_on
	output2 = _piano3_L23
	input3 = _piano3_L24_tmp * _menu2_piano3_on
	output3 = _piano3_L24
	input4 = _piano3_L25_tmp * _menu2_piano3_on
	output4 = _piano3_L25
[superjust]
	bypass = 1
	input1 = _piano3_L26_tmp * _menu2_piano3_on
	output1 = _piano3_L26
	input2 = _piano3_L27_tmp * _menu2_piano3_on
	output2 = _piano3_L27

# select note 4
[button]
	button = B2.8
	select = _menu2_piano_off
	states = 1
	led = _piano4_toggle_led_tmp
	output = _piano4_toggle_tmp
[copy]
	input = _piano4_toggle_led_tmp * 0.25
	output = _piano4_toggle_led
[triggerdelay]
	input = _piano4_toggle_tmp
	delay = 0.3
	output = _piano4_toggle
[switch]
	reset = _menu2_reset
	input1 = 0
	input2 = 1
	forward = _piano4_toggle
	output = _piano4_on
[copy]
	input = _piano4_on
	inverted = _piano4_off

# channel4 switch between the lower and upper parts of the piano roll
[button]
	button = B2.8
	select = _menu2 * _piano4_on
	output = _piano4_CtoF
[copy]
	input = _piano4_CtoF
	inverted = _piano4_GtoC
[copy]
	input = _menu2 * _piano4_on
	output = _menu2_piano4_on

# channel3 button to set the octave: 3V +/-1V
[button]
	button = B2.2
	select = _menu2_piano4_on * _piano4_CtoF
	preset = _preset
	loadpreset = _load
	savepreset = _save
	states = 3
	value1 = 0.2
	value2 = 0.3
	value3 = 0.4
	output = _piano4_octave

# channel4 buttons for piano roll
[buttongroup]
	select = _menu2_piano4_on * _piano4_CtoF
	preset = _preset
	loadpreset = _load
	savepreset = _save
	minactive = _piano4_CtoF_off
	button1 = B2.1
	button2 = B2.4
	button3 = B2.3
	button4 = B2.6
	button5 = B2.5
	button6 = B2.7
	led1 = _piano4_CtoF_led1
	led2 = _piano4_CtoF_led2
	led3 = _piano4_CtoF_led3
	led4 = _piano4_CtoF_led4
	led5 = _piano4_CtoF_led5
	led6 = _piano4_CtoF_led6
	value1 = _piano4_octave
	value2 = 0.1 / 12 + _piano4_octave
	value3 = 0.2 / 12 + _piano4_octave
	value4 = 0.3 / 12 + _piano4_octave
	value5 = 0.4 / 12 + _piano4_octave
	value6 = 0.5 / 12 + _piano4_octave
	output = _pitch4_CtoF
	buttonpress = _piano4_CtoF_press
[buttongroup]
	select = _menu2_piano4_on * _piano4_GtoC
	preset = _preset
	loadpreset = _load
	savepreset = _save
	minactive = _piano4_CtoF_on
	button1 = B2.2
	button2 = B2.1
	button3 = B2.4
	button4 = B2.3
	button5 = B2.6
	button6 = B2.5
	button7 = B2.7
	led1 = _piano4_GtoC_led1
	led2 = _piano4_GtoC_led2
	led3 = _piano4_GtoC_led3
	led4 = _piano4_GtoC_led4
	led5 = _piano4_GtoC_led5
	led6 = _piano4_GtoC_led6
	led7 = _piano4_GtoC_led7
	value1 = 0.6 / 12 + _piano4_octave
	value2 = 0.7 / 12 + _piano4_octave
	value3 = 0.8 / 12 + _piano4_octave
	value4 = 0.9 / 12 + _piano4_octave
	value5 = 1.0 / 12 + _piano4_octave
	value6 = 1.1 / 12 + _piano4_octave
	value7 = 1.2 / 12 + _piano4_octave
	output = _pitch4_GtoC
	buttonpress = _piano4_GtoC_press
[mixer]
	input1 = _piano4_CtoF_press * _piano4_CtoF_off
	input2 = _piano4_GtoC_press * _piano4_CtoF_on
	output = _piano4_buttonpress
[button]
	button = _piano4_buttonpress
	preset = _preset
	loadpreset = _load
	savepreset = _save
	led = _piano4_CtoF_on
[copy]
	input = _piano4_CtoF_on
	inverted = _piano4_CtoF_off
[mixer]
	# route the latest note selection to the channel pitch
	input1 = _pitch4_CtoF * _piano4_CtoF_on
	input2 = _pitch4_GtoC * _piano4_CtoF_off
	output = _channel4_pitch
[compare]
	input = _channel4_pitch
	compare = 0
	ifequal = 0
	else = 1
	output = _channel4_active
[copy]
	input = _channel4_active
	inverted = _channel4_inactive
[copy]
	input = _channel4_inactive * 0.05
	output = _channel4_inactive_dim

[superjust]
	bypass = 1
	input1 = _piano4_GtoC_led1 * _piano4_CtoF_off + 0.1
	output1 = _piano4_GtoC_L22_tmp
	input2 = _piano4_GtoC_L22_tmp * _piano4_GtoC
	output2 = _piano4_L22_tmp
	input3 = _piano4_L22_tmp * _menu2_piano4_on
	output3 = _piano4_L22
	input4 = _piano4_CtoF_led1 * _piano4_CtoF_on + 0.1
	output4 = _piano4_CtoF_L21_tmp
	input5 = _piano4_GtoC_led2 * _piano4_CtoF_off + 0.1
	output5 = _piano4_GtoC_L21_tmp
	input6 = _piano4_CtoF_led3 * _piano4_CtoF_on + 0.1
	output6 = _piano4_CtoF_L23_tmp
	input7 = _piano4_GtoC_led4 * _piano4_CtoF_off + 0.1
	output7 = _piano4_GtoC_L23_tmp
[superjust]
	bypass = 1
	input1 = _piano4_CtoF_led2 * _piano4_CtoF_on + 0.1
	output1 = _piano4_CtoF_L24_tmp
	input2 = _piano4_GtoC_led3 * _piano4_CtoF_off + 0.1
	output2 = _piano4_GtoC_L24_tmp
	input3 = _piano4_CtoF_led5 * _piano4_CtoF_on + 0.1
	output3 = _piano4_CtoF_L25_tmp
	input4 = _piano4_GtoC_led6 * _piano4_CtoF_off + 0.1
	output4 = _piano4_GtoC_L25_tmp
	input5 = _piano4_CtoF_led4 * _piano4_CtoF_on + 0.1
	output5 = _piano4_CtoF_L26_tmp
	input6 = _piano4_GtoC_led5 * _piano4_CtoF_off + 0.1
	output6 = _piano4_GtoC_L26_tmp
	input7 = _piano4_CtoF_led6 * _piano4_CtoF_on + 0.1
	output7 = _piano4_CtoF_L27_tmp
	input8 = _piano4_GtoC_led7 * _piano4_CtoF_off + 0.1
	output8 = _piano4_GtoC_L27_tmp
[mixer]
	input1 = _piano4_CtoF_L21_tmp * _piano4_CtoF
	input2 = _piano4_GtoC_L21_tmp * _piano4_GtoC
	maximum = _piano4_L21_tmp
[mixer]
	input1 = _piano4_CtoF_L23_tmp * _piano4_CtoF
	input2 = _piano4_GtoC_L23_tmp * _piano4_GtoC
	maximum = _piano4_L23_tmp
[mixer]
	input1 = _piano4_CtoF_L24_tmp * _piano4_CtoF
	input2 = _piano4_GtoC_L24_tmp * _piano4_GtoC
	maximum = _piano4_L24_tmp
[mixer]
	input1 = _piano4_CtoF_L25_tmp * _piano4_CtoF
	input2 = _piano4_GtoC_L25_tmp * _piano4_GtoC
	maximum = _piano4_L25_tmp
[mixer]
	input1 = _piano4_CtoF_L26_tmp * _piano4_CtoF
	input2 = _piano4_GtoC_L26_tmp * _piano4_GtoC
	maximum = _piano4_L26_tmp
[mixer]
	input1 = _piano4_CtoF_L27_tmp * _piano4_CtoF
	input2 = _piano4_GtoC_L27_tmp * _piano4_GtoC
	maximum = _piano4_L27_tmp
[superjust]
	bypass = 1
	input1 = _piano4_L21_tmp * _menu2_piano4_on
	output1 = _piano4_L21
	input2 = _piano4_L23_tmp * _menu2_piano4_on
	output2 = _piano4_L23
	input3 = _piano4_L24_tmp * _menu2_piano4_on
	output3 = _piano4_L24
	input4 = _piano4_L25_tmp * _menu2_piano4_on
	output4 = _piano4_L25
[superjust]
	bypass = 1
	input1 = _piano4_L26_tmp * _menu2_piano4_on
	output1 = _piano4_L26
	input2 = _piano4_L27_tmp * _menu2_piano4_on
	output2 = _piano4_L27

### leds for setting the octave (L2.2) and changing the piano view between 1st and 2nd parts (L2.8) for all channels plus animation
[superjust]
	bypass = 1
	input1 = _menu2_piano1_on * _piano1_CtoF
	input2 = _menu2_piano2_on * _piano2_CtoF
	input3 = _menu2_piano3_on * _piano3_CtoF
	input4 = _menu2_piano4_on * _piano4_CtoF
	output1 = _menu2_piano1_on_CtoF
	output2 = _menu2_piano2_on_CtoF
	output3 = _menu2_piano3_on_CtoF
	output4 = _menu2_piano4_on_CtoF
[mixer]
	input1 = _menu2_piano1_on_CtoF * 0
	input2 = _menu2_piano2_on_CtoF * 1
	input3 = _menu2_piano3_on_CtoF * 2
	input4 = _menu2_piano4_on_CtoF * 3
	output = _piano_octave_anim_switch
[switch]
	input1 = _piano1_octave
	input2 = _piano2_octave
	input3 = _piano3_octave
	input4 = _piano4_octave
	offset = _piano_octave_anim_switch
	output = _piano_octave_anim
[math]
	input = _piano_octave_anim - 0.3 # center octave around 0 to get symmetric +/- values
	amount = _piano_octave_eval

[compare] # lfo for animation
	input = _piano_octave_eval
	compare = 0.2
	precision = 0.01
	ifequal = 4
	output = _piano_hz_fast
[compare]
	input = _piano_octave_eval
	compare = 0.1
	precision = 0.01
	ifequal = 1.5
	output = _piano_hz_slow
[compare]
	input = _piano_octave_anim
	compare = 0.3
	precision = 0.01
	ifgreater = 0.15
	else = 0.8
	output = _piano_square_pulsewidth
[compare]
	input = _piano_octave_anim
	compare = 0.3
	precision = 0.01
	ifequal = 0
	else = 1
	output = _piano_noncenter
[lfo]
	hz = _piano_hz_slow + _piano_hz_fast
	square = _piano_lfo_oct
	level = 0.25 * _piano_noncenter # The factor noncenter also works when applied to pulsewidth, but it is required here. Otherwise (bug?), when octave 0.3 is chosen and you reboot the system, the output of the lfo is constant 0.25 (level=0.25, pulsewidth=0) and thus L2.2 is lit (dimmed at 0.25). To maintain the dark led for octave 0.3 also after reboot, the level has to be set to 0, rather than the pulsewidth. 
	pulsewidth = _piano_square_pulsewidth

[logic]
	input1 = _menu2 * _piano1_off
	input2 = _menu2 * _piano2_off
	input3 = _menu2 * _piano3_off
	input4 = _menu2 * _piano4_off
	and = _menu2_piano_off
[superjust]
	bypass = 1
	input1 = _menu2_piano1_on * _piano1_CtoF
	input2 = _menu2_piano2_on * _piano2_CtoF
	input3 = _menu2_piano3_on * _piano3_CtoF
	input4 = _menu2_piano4_on * _piano4_CtoF
	output1 = _menu2_piano1_CtoF_on
	output2 = _menu2_piano2_CtoF_on
	output3 = _menu2_piano3_CtoF_on
	output4 = _menu2_piano4_CtoF_on
[mixer]
	input1 = _menu2_piano1_CtoF_on * _piano_lfo_oct
	input2 = _menu2_piano2_CtoF_on * _piano_lfo_oct
	input3 = _menu2_piano3_CtoF_on * _piano_lfo_oct
	input4 = _menu2_piano4_CtoF_on * _piano_lfo_oct
	output = _menu2_L22
[mixer]
	input1 = _menu2_piano1_on * _piano1_GtoC
	input2 = _menu2_piano2_on * _piano2_GtoC
	input3 = _menu2_piano3_on * _piano3_GtoC
	input4 = _menu2_piano4_on * _piano4_GtoC
	output = _menu2_L28

### buttons for the length of the trigger patterns
# algo length
[buttongroup]
	button = B2.1
	select = _menu3_semitrans_off
	buttonpress = _algo_down
	longpress = _algo_reset8
[buttongroup]
	button = B2.2
	select = _menu3_semitrans_off
	buttonpress = _algo_up
	longpress = _algo_reset16
[buttongroup]
	preset = _preset
	loadpreset = _load
	savepreset = _save
	button1 = _algo_reset8
	button2 = _algo_reset16
	led1 = _algo_minus8_on
	led2 = _algo_minus8_off
	buttonpress = _algo_reset16_reset8

[superjust]
	bypass = 1
	# make left/right leds lit to represent the two stepping ranges [1 to 8]/[9 to 16]
	input1 = _algo_minus8_on * L1.3
	output1 = _menu3_L21
	input2 = _algo_minus8_off * L1.3
	output2 = _menu3_L22
	# change the length of the trigger pattern and send it to the length parameter of individual algos
	input3 = _algo_up + _algo_down
	output3 = _algo_up_down
	# add saved value (by pot) to startvalue of nudge, making it non-zero only when loading a preset
	input4 = _algo_length_pot_out * _load_delayed
	output4 = _algo_length_load
[nudge]
	reset = _algo_reset16_reset8 + _load_delayed
	startvalue = _algo_reset16_reset8 * 7 + _algo_length_load
	amount = 1
	minimum = 0
	maximum = 7
	wrap = 1 # could also be set to 0 to avoid accidental flipping from 8 steps to 1 step.
	buttondown = _algo_down #+ _algo_dummy
	buttonup = _algo_up #+ _algo_dummy
	output = _algo_length_pot

# in nudge, the output cv that ist saved to memory (and thus loaded after reboot) is always the last that was set by using buttondown/buttonup. When reset is triggered, the output cv is correct but this cv is not being saved to memory. As a workaround, whenever I trigger reset with a long press (to jump to 16 or 8), I imply a dummy usage of 1x buttondown and 1x buttonup to get the reset cv saved to memory.
#[copy]
#	input = _algo_reset16_reset8
#	output = _algo_dummy # dummy now causes problems with the pot output, introduced for saving the nudge state. could work again if the dummy triggers got delayed a bit, allowing the reset process of the pot be savely completed.

# save pattern length (state of nudge) by a virtual pot
[pot]
	pot = P1.2
	select = 0
	ledgauge = 0
	discrete = 8
	preset = _preset
	loadpreset = _load
	savepreset = _save
	resetvalue = _algo_length_pot
	reset = _algo_up_down + _algo_reset16_reset8
	output = _algo_length_pot_out
[copy]
	input = _algo_length_pot_out + 1
	output = _algo_length_pot_corr
[copy]
	input = _algo_minus8_off * 8 + _algo_length_pot_corr
	output = _algo_length

# make algo length range indicators flashing when values other than 8 or 16 are chosen
[lfo]
	hz = 5
#	level = 0.8 # use level to weaken the contrast of the flashing
	triangle = _state_lfo

[compare]
	input = _algo_length
	compare = 8
	ifequal = 0
	else = 1
	output = _algo_state8
[copy]
	input = _algo_state8 * _state_lfo
	inverted = _algo_state8_blink
[copy]
	input = _menu3_L21 * _algo_state8_blink
	output = _menu3_L21_blink
[compare]
	input = _algo_length
	compare = 16
	ifequal = 0
	else = 1
	output = _algo_state16
[copy]
	input = _algo_state16 * _state_lfo
	inverted = _algo_state16_blink
[copy]
	input = _menu3_L22 * _algo_state16_blink
	output = _menu3_L22_blink

### buttons for pattern rotate
[button]
	button = B2.7
	select = _menu3_semitrans_off
	states = 1
	output = _rotate_backward_tmp
[button]
	button = B2.8
	select = _menu3_semitrans_off
	states = 1
	output = _rotate_forward_tmp
[contour]
	trigger = _rotate_backward_tmp + _rotate_forward_tmp
	attack = 0
	release = 0
	hold = 0.01
	output = _rotate_trigger
[nudge]
	# send rotation triggers only in between clock ticks to make the rotation more stable. For feedback, send a led flash when a rotation trigger got successfully fired.
	amount = 1
	minimum = 0
	maximum = 1
	wrap = 0
	buttondown = _rotate_trigger_sync
	buttonup = _rotate_trigger
	output = _rotate_trigger_pass
#[clocktool]
#	clock = I1
#	delay = 0.5 # delay by fraction of input clock duty cycle
#	output = _clock2
[triggerdelay]
	# clocktool circuit is buggy. use triggerdelay instead.
	clock = I1
	input = I1
	delay = 0.5
	output = _clock2
[copy]
	input = _rotate_trigger_pass * _clock2
	output = _rotate_trigger_sync
[copy]
	input = _rotate_backward_tmp * _rotate_trigger_sync
	output = _rotate_backward
[copy]
	input = _rotate_forward_tmp * _rotate_trigger_sync
	output = _rotate_forward
	
# the forward/backward triggers themselves are not able to reliably flash the button leds (why not?), so I increase their sustain time
[contour]
	trigger = _rotate_backward
	attack = 0
	release = 0
	hold = 0.2
	output = _rotate_backward_led
[contour]
	trigger = _rotate_forward
	attack = 0
	release = 0
	hold = 0.2
	output = _rotate_forward_led

[nudge]
	# rotation of channel 1
	reset = _load_delayed
	startvalue = _rotate1_triggerdelay
	amount = 1
	minimum = 0
	maximum = 15
	buttondown = _rotate_backward * _channel1_rotate #+ _rotate_dummy
	buttonup = _rotate_forward * _channel1_rotate #+ _rotate_dummy
	output = _rotate1_pot
[copy]
	input = _rotate_backward * _channel1_rotate
	output = _rotate_backward_channel1
[copy]
	input = _rotate_forward * _channel1_rotate
	output = _rotate_forward_channel1
[pot]
	# save rotation of channel 1 (state of nudge) to a virtual pot
	pot = P1.1
	select = 0
	ledgauge = 0
	discrete = 16
	preset = _preset
	loadpreset = _load
	savepreset = _save
	resetvalue = _rotate1_pot
	reset = _rotate_backward_channel1 + _rotate_forward_channel1
	output = _rotate1_triggerdelay

[nudge]
	# rotation of channel 2
	reset = _load_delayed
	startvalue = _rotate2_triggerdelay
	amount = 1
	minimum = 0
	maximum = 15
	buttondown = _rotate_backward * _channel2_rotate #+ _rotate_dummy
	buttonup = _rotate_forward * _channel2_rotate #+ _rotate_dummy
	output = _rotate2_pot
[copy]
	input = _rotate_backward * _channel2_rotate
	output = _rotate_backward_channel2
[copy]
	input = _rotate_forward * _channel2_rotate
	output = _rotate_forward_channel2
[pot]
	# save rotation of channel 2 (state of nudge) to a virtual pot
	pot = P1.1
	select = 0
	ledgauge = 0
	discrete = 16
	preset = _preset
	loadpreset = _load
	savepreset = _save
	resetvalue = _rotate2_pot
	reset = _rotate_backward_channel2 + _rotate_forward_channel2
	output = _rotate2_triggerdelay

[nudge]
	# rotation of channel 3
	reset = _load_delayed
	startvalue = _rotate3_triggerdelay
	amount = 1
	minimum = 0
	maximum = 15
	buttondown = _rotate_backward * _channel3_rotate #+ _rotate_dummy
	buttonup = _rotate_forward * _channel3_rotate #+ _rotate_dummy
	output = _rotate3_pot
[copy]
	input = _rotate_backward * _channel3_rotate
	output = _rotate_backward_channel3
[copy]
	input = _rotate_forward * _channel3_rotate
	output = _rotate_forward_channel3
[pot]
	# save rotation of channel 3 (state of nudge) to a virtual pot
	pot = P1.2
	select = 0
	ledgauge = 0
	discrete = 16
	preset = _preset
	loadpreset = _load
	savepreset = _save
	resetvalue = _rotate3_pot
	reset = _rotate_backward_channel3 + _rotate_forward_channel3
	output = _rotate3_triggerdelay

[nudge]
	# rotation of channel 4
	reset = _load_delayed
	startvalue = _rotate3_triggerdelay
	amount = 1
	minimum = 0
	maximum = 15
	buttondown = _rotate_backward * _channel4_rotate #+ _rotate_dummy
	buttonup = _rotate_forward * _channel4_rotate #+ _rotate_dummy
	output = _rotate4_pot
[copy]
	input = _rotate_backward * _channel4_rotate
	output = _rotate_backward_channel4
[copy]
	input = _rotate_forward * _channel4_rotate
	output = _rotate_forward_channel4
[pot]
	# save rotation of channel 4 (state of nudge) to a virtual pot
	pot = P1.2
	select = 0
	ledgauge = 0
	discrete = 16
	preset = _preset
	loadpreset = _load
	savepreset = _save
	resetvalue = _rotate4_pot
	reset = _rotate_backward_channel4 + _rotate_forward_channel4
	output = _rotate4_triggerdelay

[triggerdelay]
	# send a delayed signal to reset the nudge circuits, so that their resetvalues have been loaded by the pots presets
	input = _load
	delay = 0.3
	output = _load_delayed

### transpose by octaves
[button]
	button = B2.3
	select = _menu3_semitrans_off
	states = 1
	output = _octave_down
[button]
	button = B2.4
	select = _menu3_semitrans_off
	states = 1
	output = _octave_up
[nudge]
	reset = _load_delayed
	startvalue = _octave_transpose_tmp - 0.2 # -0.2 as for pot saving, values are shifted to be positive
	amount = 0.1
	minimum = -0.2
	maximum = 0.2
	wrap = 0
	buttondown = _octave_down
	buttonup = _octave_up
	output = _octave_transpose_pot
[pot]
	# save octave transposition (state of nudge) to a virtual pot
	pot = P1.2
	select = 0
	ledgauge = 0
	preset = _preset
	loadpreset = _load
	savepreset = _save
	resetvalue = _octave_transpose_pot + 0.2 # +0.2 as negative values are not accepted by pot
	reset = _octave_down + _octave_up
	output = _octave_transpose_tmp
[superjust]
	bypass = 1
	input1 = _octave_transpose_tmp - 0.2
	output1 = _octave_transpose
	input2 = _octave_transpose * -7 - 0.4 # dim state 2 led further down to 0.3
	output2 = _menu3_L23
	input3 = _octave_transpose * 7 - 0.4
	output3 = _menu3_L24

### transpose by semitones
[button]
	button = B1.3
	select = L1.3
	states = 1
	output = _menu3_reset

# ... transpose downward
[button]
	button = B2.5
	select = _menu3_semitrans_off
	states = 1
	led = _semitrans_down_toggle_led_tmp
	output = _semitrans_down_toggle_tmp
[copy]
	input = _semitrans_down_toggle_led_tmp * 0.25
	output = _semitrans_down_toggle_led
[triggerdelay]
	# button B2.5 activates a sub menu for selecting semitones. The activation is delayed here, however, as otherwise the button press will also be immediately applied in the sub menu.
	input = _semitrans_down_toggle_tmp
	delay = 0.3
	output = _semitrans_down_toggle
[switch]
	reset = _menu3_reset
	input1 = 0
	input2 = 1
	forward = _semitrans_down_toggle
	output = _semitrans_down_on
[copy]
	input = _semitrans_down_on
	inverted = _semitrans_down_off
[buttongroup]
	select = L1.3 * _semitrans_down_on
	preset = _preset
	loadpreset = _load
	savepreset = _save
	minactive = 0
	button1 = B2.1
	button2 = B2.2
	button3 = B2.3
	button4 = B2.4
	button5 = B2.5
	button6 = B2.6
	button7 = B2.7
	button8 = B2.8
	led1 = _semitrans_down_led21
	led2 = _semitrans_down_led22
	led3 = _semitrans_down_led23
	led4 = _semitrans_down_led24
	led5 = _semitrans_down_led25
	led6 = _semitrans_down_led26
	led7 = _semitrans_down_led27
	led8 = _semitrans_down_led28
	value1 = 0.1 / 12
	value2 = 0.2 / 12
	value3 = 0.3 / 12
	value4 = 0.4 / 12
	value5 = 0.5 / 12
	value6 = 0.6 / 12
	value7 = 0.7 / 12
	value8 = 0.8 / 12
	output = _semitrans_down
[superjust]
	bypass = 1
	input1 = _semitrans_down_led21 + 0.1
	input2 = _semitrans_down_led22 + 0.1
	input3 = _semitrans_down_led23 + 0.1
	input4 = _semitrans_down_led24 + 0.1
	input5 = _semitrans_down_led25 + 0.1
	input6 = _semitrans_down_led26 + 0.1
	input7 = _semitrans_down_led27 + 0.1
	input8 = _semitrans_down_led28 + 0.1
	output1 = _semitrans_down_led21_dim
	output2 = _semitrans_down_led22_dim
	output3 = _semitrans_down_led23_dim
	output4 = _semitrans_down_led24_dim
	output5 = _semitrans_down_led25_dim
	output6 = _semitrans_down_led26_dim
	output7 = _semitrans_down_led27_dim
	output8 = _semitrans_down_led28_dim
[copy]
	input = L1.3 * _semitrans_down_on
	output = _menu3_semitrans_down

# ... transpose upward
[button]
	button = B2.6
	select = _menu3_semitrans_off
	states = 1
	led = _semitrans_up_toggle_led_tmp
	output = _semitrans_up_toggle_tmp
[copy]
	input = _semitrans_up_toggle_led_tmp * 0.25
	output = _semitrans_up_toggle_led
[triggerdelay]
	# button B2.6 activates a sub menu for selecting semitones. The activation is delayed here, however, as otherwise the button press will also be immediately applied in the sub menu.
	input = _semitrans_up_toggle_tmp
	delay = 0.3
	output = _semitrans_up_toggle
[switch]
	reset = _menu3_reset
	input1 = 0
	input2 = 1
	forward = _semitrans_up_toggle
	output = _semitrans_up_on
[copy]
	input = _semitrans_up_on
	inverted = _semitrans_up_off
[buttongroup]
	select = L1.3 * _semitrans_up_on
	preset = _preset
	loadpreset = _load
	savepreset = _save
	minactive = 0
	button1 = B2.1
	button2 = B2.2
	button3 = B2.3
	button4 = B2.4
	button5 = B2.5
	button6 = B2.6
	button7 = B2.7
	button8 = B2.8
	led1 = _semitrans_up_led21
	led2 = _semitrans_up_led22
	led3 = _semitrans_up_led23
	led4 = _semitrans_up_led24
	led5 = _semitrans_up_led25
	led6 = _semitrans_up_led26
	led7 = _semitrans_up_led27
	led8 = _semitrans_up_led28
	value1 = 0.1 / 12
	value2 = 0.2 / 12
	value3 = 0.3 / 12
	value4 = 0.4 / 12
	value5 = 0.5 / 12
	value6 = 0.6 / 12
	value7 = 0.7 / 12
	value8 = 0.8 / 12
	output = _semitrans_up
[superjust]
	bypass = 1
	input1 = _semitrans_up_led21 + 0.1
	input2 = _semitrans_up_led22 + 0.1
	input3 = _semitrans_up_led23 + 0.1
	input4 = _semitrans_up_led24 + 0.1
	input5 = _semitrans_up_led25 + 0.1
	input6 = _semitrans_up_led26 + 0.1
	input7 = _semitrans_up_led27 + 0.1
	input8 = _semitrans_up_led28 + 0.1
	output1 = _semitrans_up_led21_dim
	output2 = _semitrans_up_led22_dim
	output3 = _semitrans_up_led23_dim
	output4 = _semitrans_up_led24_dim
	output5 = _semitrans_up_led25_dim
	output6 = _semitrans_up_led26_dim
	output7 = _semitrans_up_led27_dim
	output8 = _semitrans_up_led28_dim
[copy]
	input = L1.3 * _semitrans_up_on
	output = _menu3_semitrans_up

### menu3 conditional for primary functions
[logic]
	input1 = L1.3 * _semitrans_down_off
	input2 = L1.3 * _semitrans_up_off
	and = _menu3_semitrans_off

### animation for semitone transposition
[lfo]
	hz = 3
	bipolar = 1
	level = 0.35 * L1.3
	offset = -0.25 * L1.3 # lfo output range [-0.5, 0.1]
	square = _semitrans_lfo
[compare]
	input = _semitrans_down * _semitrans_down_off
	compare = 0
	ifgreater = _semitrans_lfo
	output = _semitrans_down_blink
[compare]
	input = _semitrans_up * _semitrans_up_off
	compare = 0
	ifgreater = _semitrans_lfo
	output = _semitrans_up_blink

### buttons to reroll internal random sequences used to trigger channel pulses
[button]
	button = B2.1
	select = _menu4
	states = 1
	led = _menu4_L21
	output = _algo1_reroll
[button]
	button = B2.3
	select = _menu4
	states = 1
	led = _menu4_L23
	output = _algo2_reroll
[button]
	button = B2.5
	select = _menu4
	states = 1
	led = _menu4_L25
	output = _algo3_reroll
[button]
	button = B2.7
	select = _menu4
	states = 1
	led = _menu4_L27
	output = _algo4_reroll

### buttons to reroll internal random sequences used for variations of gate lengths and accents
[buttongroup]
	button = B2.2
	select = _menu4
	buttonpress = _gatelength_reroll
	longpress = _gatelength_algolength_toggle # use long press to make the gate length algo being affected by the pattern length
[button]
	button = _gatelength_algolength_toggle
	preset = _preset
	loadpreset = _load
	savepreset = _save
	output = _gatelength_algolength_on
[copy]
	input = _gatelength_algolength_on * _menu4
	output = _menu4_gatelength_algolength_on
[copy]
	input = _menu4_gatelength_algolength_on * 0.1
	output = _menu4_gatelength_dim
[copy]
	input = _gatelength_algolength_on * -16 + 16
	output = _length16_g

[buttongroup]
	button = B2.4
	select = _menu4
	buttonpress = _accent_reroll
	longpress = _accent_algolength_toggle # use long press to make the accent algo being affected by the pattern length
[button]
	button = _accent_algolength_toggle
	preset = _preset
	loadpreset = _load
	savepreset = _save
	output = _accent_algolength_on
[copy]
	input = _accent_algolength_on * _menu4
	output = _menu4_accent_algolength_on
[copy]
	input = _menu4_accent_algolength_on * 0.1
	output = _menu4_accent_dim
[copy]
	input = _accent_algolength_on * -16 + 16
	output = _length16_a

[button]
	button = B2.6
	select = _menu4
	states = 2
	led = _menu4_L26
[copy]
	input = _menu4_L26 * _menu4_L26
	output = _menu4_L26_dim

### button to randomize channel priorities in a performance mode
[button]
	button = B2.8
	select = _menu4
	preset = _preset
	loadpreset = _load
	savepreset = _save
	states = 3 # state=0 manually set priorities, state=1 randomize every bar, state=2 randomize every 2nd beat (1/8th note)
	led = _random_prio_led
	output = _random_prio_state_tmp # for states=3, output is 0,1,2
[copy]
	input = _random_prio_led * _random_prio_led
	output = _menu4_L28
[sample]
	# change the priority performance mode only at the end of a bar
	input = _random_prio_state_tmp
	sample = _step16 * _clock2
	output = _random_prio_state
[compare]
	input = _random_prio_state
	compare = 0
	ifgreater = 1
	output = _random_prio_on
[copy]
	input = _random_prio_on
	inverted = _random_prio_off
[compare]
	input = _random_prio_state
	compare = 2
	output = _random_prio_beat
[clocktool]
	# changes in priority affect the audible pitch, so better do such changes in sync with the clock
	clock = I1
	divide = 2
	output = _clock_div2
[mixer]
	input1 = _step1
	input2 = _clock_div2 * _random_prio_beat
	maximum = _random_prio_trigger

### buttons for including/excluding channels in fills variations and changes in pattern rotation
[button]
	button = B2.1
	select = L1.5
	preset = _preset
	loadpreset = _load
	savepreset = _save
	states = 2
	led = _menu5_L21
	output = _algo1_fills
[button]
	button = B2.2
	select = L1.5
	states = 2
	led = _menu5_L22
	output = _channel1_rotate
	longpress = _channel1_rotate_show # long presses activates X1 register to indicate the rotation state of the channel. A flashing led indicates the channel currently showing channel. Note that if no rotation has been applied to the channel, the rotaion value is 0 and thus nothing is shown by X1. Aa quick check whether any of the channels is currently rotated, button B2.7 is lit by a dimmed led if all rotation values are 0 (i.e. all algoquencers run in sync with their original 16-step sequences). 
[button]
	button = B2.3
	select = L1.5
	preset = _preset
	loadpreset = _load
	savepreset = _save
	states = 2
	led = _menu5_L23
	output = _algo2_fills
[button]
	button = B2.4
	select = L1.5
	states = 2
	led = _menu5_L24
	output = _channel2_rotate
	longpress = _channel2_rotate_show
[button]
	button = B2.5
	select = L1.5
	preset = _preset
	loadpreset = _load
	savepreset = _save
	states = 2
	led = _menu5_L25
	output = _algo3_fills
[button]
	button = B2.6
	select = L1.5
	states = 2
	led = _menu5_L26
	output = _channel3_rotate
	longpress = _channel3_rotate_show
[button]
	button = B2.7
	select = L1.5
	preset = _preset
	loadpreset = _load
	savepreset = _save
	states = 2
	led = _menu5_L27
	output = _algo4_fills
[button]
	button = B2.8
	select = L1.5
	states = 2
	led = _menu5_L28
	output = _channel4_rotate
	longpress = _channel4_rotate_show

# show rotation by X1 register
[buttongroup]
	select = L1.5
	minactive = 0
	button1 = _channel1_rotate_show
	button2 = _channel2_rotate_show
	button3 = _channel3_rotate_show
	button4 = _channel4_rotate_show
	led1 = _channel1_show_tmp
	led2 = _channel2_show_tmp
	led3 = _channel3_show_tmp
	led4 = _channel4_show_tmp
[superjust]
	bypass = 1
	input1 = _channel1_show_tmp / 10
	input2 = _channel2_show_tmp / 10
	input3 = _channel3_show_tmp / 10
	input4 = _channel4_show_tmp / 10
	output1 = _channel1_show
	output2 = _channel2_show
	output3 = _channel3_show
	output4 = _channel4_show
	input5 = _channel1_show_tmp * _lfo_channel_show
	input6 = _channel2_show_tmp * _lfo_channel_show
	input7 = _channel3_show_tmp * _lfo_channel_show
	input8 = _channel4_show_tmp * _lfo_channel_show
	output5 = _channel1_show_blink
	output6 = _channel2_show_blink
	output7 = _channel3_show_blink
	output8 = _channel4_show_blink
[lfo]
	# flashing led to indicate which channel is shown by X1 register
	# level and offset are set to additionally distinguish between the button states on/off, that enable or disable pattern rotation for each channel
	hz = 3
	bipolar = 1
	level = 0.35 * L1.5
	offset = -0.25 * L1.5 # lfo output range [-0.5, 0.1]
	square = _lfo_channel_show
[mixer]
	input1 = _rotate1_triggerdelay * _channel1_show
	input2 = _rotate2_triggerdelay * _channel2_show
	input3 = _rotate3_triggerdelay * _channel3_show
	input4 = _rotate4_triggerdelay * _channel4_show
	output = X1

### buttons for saving and loading presets
[buttongroup]
	select = _menu8
	button1 = B2.1
	button2 = B2.2
	button3 = B2.3
	button4 = B2.4
	button5 = B2.5
	button6 = B2.6
	button7 = B2.7
	button8 = B2.8
	led1 = _menu8_L21
	led2 = _menu8_L22
	led3 = _menu8_L23
	led4 = _menu8_L24
	led5 = _menu8_L25
	led6 = _menu8_L26
	led7 = _menu8_L27
	led8 = _menu8_L28
	value1 = _bank2 * 8 + 0
	value2 = _bank2 * 8 + 1
	value3 = _bank2 * 8 + 2
	value4 = _bank2 * 8 + 3
	value5 = _bank2 * 8 + 4
	value6 = _bank2 * 8 + 5
	value7 = _bank2 * 8 + 6
	value8 = _bank2 * 8 + 7
	output = _preset
	buttonpress = _load_ini
	longpress = _save
[superjust]
	bypass = 1
	input1 = _load_ini * _bank1
	output1 = _load_bank1
	input2 = _load_ini * _bank2
	output2 = _load_bank2
	input3 = _save * _bank1
	output3 = _save_bank1
	input4 = _save * _bank2
	output4 = _save_bank2
[nudge]
	amount = 1
	minimum = 0
	maximum = 1
	wrap = 0
	buttondown = _load_bank2 + _save_bank2
	buttonup = _load_bank1 + _save_bank1
	output = _bank1_on
[copy]
	input = _bank1_on
	inverted = _bank2_on
[copy]
	input = _load_pass * -0.9
	output = _load_queue
[mixer]
	input1 = _bank1 * _bank1_on + _load_queue
	input2 = _bank2 * _bank2_on + _load_queue
	maximum = _menu8_led

[contour] # animation for saving presets in menu8
	trigger = _save
	attack = 0
	release = 0
	hold = 2
	output = _save_on
[switch]
	input1 = _menu8_L21
	input2 = _menu8_L22
	input3 = _menu8_L23
	input4 = _menu8_L24
	input5 = _menu8_L25
	input6 = _menu8_L26
	input7 = _menu8_L27
	input8 = _menu8_L28
	offset = _preset
	output = _buttonhold
[copy]
	input = -2 * _buttonhold + 1
	output = _amplitude
[copy]
	input = _lfo * _amplitude
	output = _lfo_scaled
[switch]
	input = _save_on * _lfo_scaled
	offset = _preset
	output1 = _save_blink0
	output2 = _save_blink7
	output3 = _save_blink6
	output4 = _save_blink5
	output5 = _save_blink4
	output6 = _save_blink3
	output7 = _save_blink2
	output8 = _save_blink1

### buttons to enable/disable slides for individual channels (sub-menu 6)
[nudge]
	amount = 1
	minimum = 1
	maximum = 2
	wrap = 1
	buttonup = _menu6 * _menus_longpress
	output = _submenu6
[buttongroup]
	select = _menu6 * _submenu6
	selectat = 2
	preset = _preset
	loadpreset = _load
	savepreset = _save
	minactive = 0
	maxactive = 4
	button1 = B2.1
	button2 = B2.3
	button3 = B2.5
	button4 = B2.7
	led1 = _slide1
	led2 = _slide2
	led3 = _slide3
	led4 = _slide4
[copy]
	input = _submenu6 - 1
	output = _submenu6_on_tmp
	inverted = _submenu6_off_tmp
[copy]
	input = _menu6 * _submenu6_on_tmp
	output = _submenu6_on
[copy]
	input = _menu6 * _submenu6_off_tmp
	output = _submenu6_off

### buttons to set global fillorder
[buttongroup]
	select = _menu6 * _submenu6
	selectat = 1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	button1 = B2.1
	button2 = B2.3
	button3 = B2.5
	button4 = B2.7
	led1 = _menu6_L21
	led2 = _menu6_L23
	led3 = _menu6_L25
	led4 = _menu6_L27
	value1 = 0
	value2 = 1
	value3 = 2
	value4 = 3
	output = _fillorder

### buttons to set global value of branches
[buttongroup]
	select = _menu6 * _submenu6
	selectat = 1
	preset = _preset
	loadpreset = _load
	savepreset = _save
	button1 = B2.2
	button2 = B2.4
	button3 = B2.6
	button4 = B2.8
	led1 = _menu6_L22
	led2 = _menu6_L24
	led3 = _menu6_L26
	led4 = _menu6_L28
	value1 = 0
	value2 = 1
	value3 = 2
	value4 = 3
	output = _branches

### Here follow the algoquencers:
### algoquencer to provide stable 16-setp leds and 4 barleds
# If I shorten the length of the channel algoquencers, their barleds are changing speed,
# and also the step leds that are cut due to the shorter sequence are not sending step leds.
[algoquencer]
	select = 1
	clock = I1
	reset = _reset
	barled1 = _barled1
	barled2 = _barled2
	barled3 = _barled3
	barled4 = _barled4
	led1 = _step1_tmp
	led16 = _step16_tmp
# led outputs of pure random sequences are 1 when not triggered and 0.5 when triggered -> invert them manually
[copy]
	input = _step1_tmp * -1 + 1
	output = _step1
[copy]
	input = _step16_tmp * -1 + 1
	output = _step16

### algoquencer to generate pulses for channel 1
# load presets only at the end of a bar
[nudge]
	amount = 1
	minimum = 0
	maximum = 1
	wrap = 0
	buttondown = _load
	buttonup = _load_ini
	output = _load_pass
[copy]
	input = _load_pass * _step16 # _step16 seems to be too early for loading presets, as the loaded sequences are then ahead of time by 1/16th. -> using _clock2 (delayed by half duty cycle)
	output = _load_tmp
[copy]
	input = _load_tmp * _clock2
	output = _load
[triggerdelay]
	# delay clock to account for pattern rotation. Be aware that if you load a pattern that includes rotated channels, these channels will start playing according to their clock delay, safed by the rotation value. 
	clock = I1
	input = I1
	delay = _rotate1_triggerdelay
	output = _clock1_delayed
[algoquencer]
	select = 1
 	clock = _clock1_delayed
	reset = _reset + _load
	preset = _preset
	loadpreset = _load
	savepreset = _save
	reroll = _algo1_reroll + _clear
	length = _algo_length
	gate = _algo1_gate
	muteled = _menu1_L21
	unmuteled = _menu1_L22
	mutebutton = _algo1_mute_toggle
	unmutebutton = _algo1_unmute
	activity = _algo1_activity + _global_activity
	branches = _branches
	fills = _global_fills * _algo1_fills
	fillorder = _fillorder
	dejavu = _algo1_dejavu
	morphs = _algo1_morph
	offbeats = _global_offbeats
	distribution = _global_distribution
[copy]
	# inverted muteled; needed to automatically set global mute state to 'on' when all channels are manually muted.
	input = _menu1_L21
	inverted = _menu1_L21_inv

### algoquencer to generate pulses for channel 2
[triggerdelay]
	clock = I1
	input = I1
	delay = _rotate2_triggerdelay
	output = _clock2_delayed
[algoquencer]
	select = 1
 	clock = _clock2_delayed
	reset = _reset
	preset = _preset
	loadpreset = _load
	savepreset = _save
	reroll = _algo2_reroll + _clear
	length = _algo_length
	gate = _algo2_gate
	muteled = _menu1_L23
	unmuteled = _menu1_L24
	mutebutton = _algo2_mute_toggle
	unmutebutton = _algo2_unmute
	activity = _algo2_activity + _global_activity
	branches = _branches
	fills = _global_fills * _algo2_fills
	fillorder = _fillorder
	dejavu = _algo2_dejavu
	morphs = _algo2_morph
	offbeats = _global_offbeats
	distribution = _global_distribution
[copy]
	input = _menu1_L23
	inverted = _menu1_L23_inv

### algoquencer to generate pulses for channel 3
[triggerdelay]
	clock = I1
	input = I1
	delay = _rotate3_triggerdelay
	output = _clock3_delayed
[algoquencer]
	select = 1
 	clock = _clock3_delayed
	reset = _reset
	preset = _preset
	loadpreset = _load
	savepreset = _save
	reroll = _algo3_reroll + _clear
	length = _algo_length
	gate = _algo3_gate
	muteled = _menu1_L25
	unmuteled = _menu1_L26
	mutebutton = _algo3_mute_toggle
	unmutebutton = _algo3_unmute
	activity = _algo3_activity + _global_activity
	branches = _branches
	fills = _global_fills * _algo3_fills
	fillorder = _fillorder
	dejavu = _algo3_dejavu
	morphs = _algo3_morph
	offbeats = _global_offbeats
	distribution = _global_distribution
[copy]
	input = _menu1_L25
	inverted = _menu1_L25_inv

### algoquencer to generate pulses for channel 4
[triggerdelay]
	clock = I1
	input = I1
	delay = _rotate4_triggerdelay
	output = _clock4_delayed
[algoquencer]
	select = 1
	clock = _clock4_delayed
	reset = _reset
	preset = _preset
	loadpreset = _load
	savepreset = _save
	reroll = _algo4_reroll + _clear
	length = _algo_length
	gate = _algo4_gate
	muteled = _menu1_L27
	unmuteled = _menu1_L28
	mutebutton = _algo4_mute_toggle
	unmutebutton = _algo4_unmute
	activity = _algo4_activity + _global_activity
	branches = _branches
	fills = _global_fills * _algo4_fills
	fillorder = _fillorder
	dejavu = _algo4_dejavu
	morphs = _algo4_morph
	offbeats = _global_offbeats
	distribution = _global_distribution
[copy]
	input = _menu1_L27
	inverted = _menu1_L27_inv

### algoquencer for variation of gate lengths
# a long press determines whether this algoquencer is affected by changes of the length of the pitch sequences (_algo_length)
[algoquencer]
	select = 1
	clock = I1
	reset = _reset
	preset = _preset
	loadpreset = _load
	savepreset = _save
	reroll = _gatelength_reroll + _clear
	activity = _gate_activity
	length = _algo_length * _gatelength_algolength_on + _length16_g
	gate = _gatelength_gate

### scale the gate length to min/max and use the gate length sequence to also generate slides. Here, a slide is activated for a step if the gate length reaches a value of 1. This behavior has to be adjusted to the requirements of your synthesizer voice. For example, I run the Roland TB-03, which enables slide status control by midi cc. So I send the _slide sequence to midiout via the X7.
[compare]
	input = _gatelength_gate
	compare = 1.0
	precision = 0.05
	ifequal = 1.0
	else = _gatelength_low # adjust the lower gate length (at the top of the patch) to your taste and to the requirements of your snthesizer vioce.
	output = _gatelength_scaled
[sample]
	input = _gatelength_scaled
	sample = _gate
	output = _gatelength
[sample]
	input = _gatelength_gate
	sample = _gate
	output = _slide

### algoquencer for variation of accents
[algoquencer]
	select = 1
 	clock = I1
	reset = _reset
	preset = _preset
	loadpreset = _load
	savepreset = _save
	activity = _accent_activity
	reroll = _accent_reroll + _clear
	length = _algo_length * _accent_algolength_on + _length16_a
	gate = _accent_gate
[compare]
	input = _accent_gate
	compare = 1.0
	precision = 0.05
	ifequal = 0.7 # 1.0
	else = _acc_level_low # adjust the lower accent level (at the top of the patch) and the upper level (here) to your taste and to the requirements of your snthesizer vioce.
	output = _accent_scaled
[sample]
	input = _accent_scaled
	sample = _gate
	output = _accent

### check whether global rotation state is 0 (= no rotation). This will create a led signal (menu3, L2.7) when no rotation is applied.
[mixer]
	input1 = _rotate1_triggerdelay
	input2 = _rotate2_triggerdelay
	input3 = _rotate3_triggerdelay
	input4 = _rotate4_triggerdelay
	maximum = _rotate_max_triggerdelay
[compare]
	input = _rotate_max_triggerdelay
	compare = 0
	ifequal = 0.1
	output = _rotate_triggerdelay0 # dimmed led routed to L2.7

### finally create the joined sequences, resulting from all active and unmuted channels
# gate output [0, 1]
[superjust]
	input1 = _algo1_gate * _channel1_active
	input2 = _algo2_gate * _channel2_active
	input3 = _algo3_gate * _channel3_active
	input4 = _algo4_gate * _channel4_active
	output1 = _algo1_gate_active
	output2 = _algo2_gate_active
	output3 = _algo3_gate_active
	output4 = _algo4_gate_active
[mixer]
	input1 = _algo1_gate_active
	input2 = _algo2_gate_active
	input3 = _algo3_gate_active
	input4 = _algo4_gate_active
	maximum = _gate

# assign variable gate lengths (generated by the gate length algoquencer), scale them with pot P1.2, and modify their distribution with pot P2.2.
[contour]
	gate = _gate
	attack = 0
	decay = 0 # try to also modify decay or release time, e.g. by the gate length variation!
	release = 0
	hold = _gatelength_P12 * _gatelength
	output = _gate_variable

# make channel with highest priority audible
[mixer]
	input1 = _algo1_gate_active * _channel1_prio
	input2 = _algo2_gate_active * _channel2_prio
	input3 = _algo3_gate_active * _channel3_prio
	input4 = _algo4_gate_active * _channel4_prio
	maximum = _gate_scaled
[superjust]
	bypass = 1
	input1 = _algo1_gate_active * _channel1_pitch 
	input2 = _algo2_gate_active * _channel2_pitch
	input3 = _algo3_gate_active * _channel3_pitch
	input4 = _algo4_gate_active * _channel4_pitch
	output1 = _pitch1_gated
	output2 = _pitch2_gated
	output3 = _pitch3_gated
	output4 = _pitch4_gated
[mixer]
	input1 = _algo1_gate_active * _channel1_prio + _pitch1_gated
	input2 = _algo2_gate_active * _channel2_prio + _pitch2_gated
	input3 = _algo3_gate_active * _channel3_prio + _pitch3_gated
	input4 = _algo4_gate_active * _channel4_prio + _pitch4_gated
	maximum = _pitch_scaled
[copy]
	input = _pitch_scaled - _gate_scaled
	output = _pitch_inczero

# evaluate slides according to the same priorities to asure that slides for slide-activated channels can only occur where the respective channels are audible
[superjust]
	input1 = _pitch1_gated * _slide1
	input2 = _pitch2_gated * _slide2
	input3 = _pitch3_gated * _slide3
	input4 = _pitch4_gated * _slide4
	output1 = _slide1_on
	output2 = _slide2_on
	output3 = _slide3_on
	output4 = _slide4_on
[mixer]
	input1 = _algo1_gate_active * _channel1_prio + _slide1_on
	input2 = _algo2_gate_active * _channel2_prio + _slide2_on
	input3 = _algo3_gate_active * _channel3_prio + _slide3_on
	input4 = _algo4_gate_active * _channel4_prio + _slide4_on
	maximum = _slide_scaled
[copy]
	input = _slide_scaled - _gate_scaled
	output = _slide_channel

[sample]
	input = _pitch_inczero
	sample = _gate # use _gate or _gate_variable
	output = _pitch_sampled
[sample]
	input = _slide_channel * _slide
	sample = _gate # use _gate or _gate_variable
	output = _slew_channel_sampled
[compare]
	input = _slew_channel_sampled
	compare = 0
	ifgreater = 1
	output = _slew_channel
#[slew]
#	input = _pitch_sampled
#	slew = P3.10
##	gate = _slide * _slew_channel
#	gate = _slew_channel
##	exponential = _pitch_slewed
#	linear = _pitch_slewed
[mixer]
	# apply transposition to the pich
	input1 = _pitch_sampled
#	input1 = _pitch_slewed
	input2 = _octave_transpose
	input3 = _semitrans_down * -1
	input4 = _semitrans_up
	output = _pitch_transposed

### final output of the modified sequences
# example for cv output
[superjust]
	input1 = _gate_variable
	output1 = O1
	input2 = _pitch_transposed
	output2 = O2
	input3 = _accent
	output3 = O3
	input4 = _slew_channel
	output4 = O4

# example for midi output
# Roland SH-01A
#[midiout]
#	channel = 15
#	pitch1 = _pitch_transposed
#	gate1 = _gate_variable
#	ccnumber1 = 24 # vcf env depth
#	cc1 = _accent
#	ccnumber2 = 65 # portamento
#	cc2 = _slew_channel
#	ccnumber3 = 75 # env decay
#	cc3 = _gate_variable * 0.5

	