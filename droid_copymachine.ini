[droid]
    ledbrightness = 0.5

[p2b8]
[p2b8]
[p10]

### Connections
# Patch external clock to I1. 
# Patch 4 external trigger sequences to I5-I8.
# Use the same clock for the external trigger sequences. 
# You may also use the same reset for this patch and the external sequences. Here I use midi.

# Modified trigger sequences are sent to O1-O4.
# Accent cv sequences are sent to O5-O8.

### start all internal sequencers per midi controller
[midiin]
	start = _reset

### create a 16-step master sequence of distinct cv values for each step to identify step position in the [compare] circuits
[sequencer] # 1. 16 steps (1-8)
	clock = I1
	reset = _reset
	cvoutput = _step
	cv1 = 0.1V
	cv2 = 0.2V
	cv3 = 0.3V
	cv4 = 0.4V
	cv5 = 0.5V
	cv6 = 0.6V
	cv7 = 0.7V
	cv8 = 0.8V
	chaintonext = 1
[sequencer] # (9-16)
	cv1 = 0.9V
	cv2 = 1.0V
	cv3 = 1.1V
	cv4 = 1.2V
	cv5 = 1.3V
	cv6 = 1.4V
	cv7 = 1.5V
	cv8 = 1.6V

### create identifiers for every step of the 16-step master sequence
[compare]
	input = _step
	compare = 0.1V
	precision = 0.01V
	ifequal = 1 # else = 0 (default)
	output = _trigger_sh1
[compare]
	input = _step
	compare = 0.2V
	precision = 0.01V
	ifequal = 1
	output = _trigger_sh2
[compare]
	input = _step
	compare = 0.3V
	precision = 0.01V
	ifequal = 1
	output = _trigger_sh3
[compare]
	input = _step
	compare = 0.4V
	precision = 0.01V
	ifequal = 1
	output = _trigger_sh4
[compare]
	input = _step
	compare = 0.5V
	precision = 0.01V
	ifequal = 1
	output = _trigger_sh5
[compare]
	input = _step
	compare = 0.6V
	precision = 0.01V
	ifequal = 1
	output = _trigger_sh6
[compare]
	input = _step
	compare = 0.7V
	precision = 0.01V
	ifequal = 1
	output = _trigger_sh7
[compare]
	input = _step
	compare = 0.8V
	precision = 0.01V
	ifequal = 1
	output = _trigger_sh8
[compare]
	input = _step
	compare = 0.9V
	precision = 0.01V
	ifequal = 1
	output = _trigger_sh9
[compare]
	input = _step
	compare = 1.0V
	precision = 0.01V
	ifequal = 1
	output = _trigger_sh10
[compare]
	input = _step
	compare = 1.1V
	precision = 0.01V
	ifequal = 1
	output = _trigger_sh11
[compare]
	input = _step
	compare = 1.2V
	precision = 0.01V
	ifequal = 1
	output = _trigger_sh12
[compare]
	input = _step
	compare = 1.3V
	precision = 0.01V
	ifequal = 1
	output = _trigger_sh13
[compare]
	input = _step
	compare = 1.4V
	precision = 0.01V
	ifequal = 1
	output = _trigger_sh14
[compare]
	input = _step
	compare = 1.5V
	precision = 0.01V
	ifequal = 1
	output = _trigger_sh15
[compare]
	input = _step
	compare = 1.6V
	precision = 0.01V
	ifequal = 1
	output = _trigger_sh16
	
### Convert trigger inputs from external device into triangular AR spikes. The same is done for the algoquencers that are listening to the trigger inputs. This is necessary to identify on/off mismatches between the trigger steps of the current algo and the external sequence, allowing to automatically adjust the algos to any changes applied to the external sequence. The slopes of the spikes asure that imperfect timing of the internal/external trigger signals to be compared lead to only small cv differences. As large cv differences are used to identify real changes in the exteranl sequence. Be also aware that as of now the external sequence canÂ´t be directly fed to the algoquencer step button inputs, as these are toggle buttons. The algo step buttons would therefore be permanently turned on/off each repeating cycle.
[contour]
	trigger = I5 # 1st incoming trigger signal sent by external drum sequencer
	attack = 0.6 # AR values work also for higher bpm (checked up to 150, if I remember correctly)
	release = 0.6 * 0.05
	output = _external1
[contour]
	trigger = I6 # 2nd incoming trigger signal sent by external drum sequencer
	attack = 0.6
	release = 0.6 * 0.05
	output = _external2
[contour]
	trigger = I7 # 3rd incoming trigger signal sent by external drum sequencer
	attack = 0.6
	release = 0.6 * 0.05
	output = _external3
[contour]
	trigger = I8 # 4th incoming trigger signal sent by external drum sequencer
	attack = 0.6
	release = 0.6 * 0.05
	output = _external4

### compare algo step triggers with the external signals and create a sequence of toggle signals to be sent to the algo step buttons in case of mismatches
[compare]
	input = _algo1_gates
	compare = _external1
	precision = 0.8
	ifequal = 0
	else = 1
	output = _all1_button_toggle
[compare]
	input = _algo2_gates
	compare = _external2
	precision = 0.8
	ifequal = 0
	else = 1
	output = _all2_button_toggle
[compare]
	input = _algo3_gates
	compare = _external3
	precision = 0.8
	ifequal = 0
	else = 1
	output = _all3_button_toggle
[compare]
	input = _algo4_gates
	compare = _external4
	precision = 0.8
	ifequal = 0
	else = 1
	output = _all4_button_toggle

### create unique triggers to toggle the algo step buttons, thus always adjusting these to the external drum sequences
[superjust]
	bypass = 1
	input1 = _all1_button_toggle * _trigger_sh1
	input2 = _all1_button_toggle * _trigger_sh2
	input3 = _all1_button_toggle * _trigger_sh3
	input4 = _all1_button_toggle * _trigger_sh4
	input5 = _all1_button_toggle * _trigger_sh5
	input6 = _all1_button_toggle * _trigger_sh6
	input7 = _all1_button_toggle * _trigger_sh7
	input8 = _all1_button_toggle * _trigger_sh8
	output1 = _algo1_button1_toggle
	output2 = _algo1_button2_toggle
	output3 = _algo1_button3_toggle
	output4 = _algo1_button4_toggle
	output5 = _algo1_button5_toggle
	output6 = _algo1_button6_toggle
	output7 = _algo1_button7_toggle
	output8 = _algo1_button8_toggle
[superjust]
	bypass = 1
	input1 = _all1_button_toggle * _trigger_sh9
	input2 = _all1_button_toggle * _trigger_sh10
	input3 = _all1_button_toggle * _trigger_sh11
	input4 = _all1_button_toggle * _trigger_sh12
	input5 = _all1_button_toggle * _trigger_sh13
	input6 = _all1_button_toggle * _trigger_sh14
	input7 = _all1_button_toggle * _trigger_sh15
	input8 = _all1_button_toggle * _trigger_sh16
	output1 = _algo1_button9_toggle
	output2 = _algo1_button10_toggle
	output3 = _algo1_button11_toggle
	output4 = _algo1_button12_toggle
	output5 = _algo1_button13_toggle
	output6 = _algo1_button14_toggle
	output7 = _algo1_button15_toggle
	output8 = _algo1_button16_toggle
[superjust]
	bypass = 1
	input1 = _all2_button_toggle * _trigger_sh1
	input2 = _all2_button_toggle * _trigger_sh2
	input3 = _all2_button_toggle * _trigger_sh3
	input4 = _all2_button_toggle * _trigger_sh4
	input5 = _all2_button_toggle * _trigger_sh5
	input6 = _all2_button_toggle * _trigger_sh6
	input7 = _all2_button_toggle * _trigger_sh7
	input8 = _all2_button_toggle * _trigger_sh8
	output1 = _algo2_button1_toggle
	output2 = _algo2_button2_toggle
	output3 = _algo2_button3_toggle
	output4 = _algo2_button4_toggle
	output5 = _algo2_button5_toggle
	output6 = _algo2_button6_toggle
	output7 = _algo2_button7_toggle
	output8 = _algo2_button8_toggle
[superjust]
	bypass = 1
	input1 = _all2_button_toggle * _trigger_sh9
	input2 = _all2_button_toggle * _trigger_sh10
	input3 = _all2_button_toggle * _trigger_sh11
	input4 = _all2_button_toggle * _trigger_sh12
	input5 = _all2_button_toggle * _trigger_sh13
	input6 = _all2_button_toggle * _trigger_sh14
	input7 = _all2_button_toggle * _trigger_sh15
	input8 = _all2_button_toggle * _trigger_sh16
	output1 = _algo2_button9_toggle
	output2 = _algo2_button10_toggle
	output3 = _algo2_button11_toggle
	output4 = _algo2_button12_toggle
	output5 = _algo2_button13_toggle
	output6 = _algo2_button14_toggle
	output7 = _algo2_button15_toggle
	output8 = _algo2_button16_toggle
[superjust]
	bypass = 1
	input1 = _all3_button_toggle * _trigger_sh1
	input2 = _all3_button_toggle * _trigger_sh2
	input3 = _all3_button_toggle * _trigger_sh3
	input4 = _all3_button_toggle * _trigger_sh4
	input5 = _all3_button_toggle * _trigger_sh5
	input6 = _all3_button_toggle * _trigger_sh6
	input7 = _all3_button_toggle * _trigger_sh7
	input8 = _all3_button_toggle * _trigger_sh8
	output1 = _algo3_button1_toggle
	output2 = _algo3_button2_toggle
	output3 = _algo3_button3_toggle
	output4 = _algo3_button4_toggle
	output5 = _algo3_button5_toggle
	output6 = _algo3_button6_toggle
	output7 = _algo3_button7_toggle
	output8 = _algo3_button8_toggle
[superjust]
	bypass = 1
	input1 = _all3_button_toggle * _trigger_sh9
	input2 = _all3_button_toggle * _trigger_sh10
	input3 = _all3_button_toggle * _trigger_sh11
	input4 = _all3_button_toggle * _trigger_sh12
	input5 = _all3_button_toggle * _trigger_sh13
	input6 = _all3_button_toggle * _trigger_sh14
	input7 = _all3_button_toggle * _trigger_sh15
	input8 = _all3_button_toggle * _trigger_sh16
	output1 = _algo3_button9_toggle
	output2 = _algo3_button10_toggle
	output3 = _algo3_button11_toggle
	output4 = _algo3_button12_toggle
	output5 = _algo3_button13_toggle
	output6 = _algo3_button14_toggle
	output7 = _algo3_button15_toggle
	output8 = _algo3_button16_toggle
[superjust]
	bypass = 1
	input1 = _all4_button_toggle * _trigger_sh1
	input2 = _all4_button_toggle * _trigger_sh2
	input3 = _all4_button_toggle * _trigger_sh3
	input4 = _all4_button_toggle * _trigger_sh4
	input5 = _all4_button_toggle * _trigger_sh5
	input6 = _all4_button_toggle * _trigger_sh6
	input7 = _all4_button_toggle * _trigger_sh7
	input8 = _all4_button_toggle * _trigger_sh8
	output1 = _algo4_button1_toggle
	output2 = _algo4_button2_toggle
	output3 = _algo4_button3_toggle
	output4 = _algo4_button4_toggle
	output5 = _algo4_button5_toggle
	output6 = _algo4_button6_toggle
	output7 = _algo4_button7_toggle
	output8 = _algo4_button8_toggle
[superjust]
	bypass = 1
	input1 = _all4_button_toggle * _trigger_sh9
	input2 = _all4_button_toggle * _trigger_sh10
	input3 = _all4_button_toggle * _trigger_sh11
	input4 = _all4_button_toggle * _trigger_sh12
	input5 = _all4_button_toggle * _trigger_sh13
	input6 = _all4_button_toggle * _trigger_sh14
	input7 = _all4_button_toggle * _trigger_sh15
	input8 = _all4_button_toggle * _trigger_sh16
	output1 = _algo4_button9_toggle
	output2 = _algo4_button10_toggle
	output3 = _algo4_button11_toggle
	output4 = _algo4_button12_toggle
	output5 = _algo4_button13_toggle
	output6 = _algo4_button14_toggle
	output7 = _algo4_button15_toggle
	output8 = _algo4_button16_toggle

### declare pots and buttons
[pot]
	pot = P1.1 # global activity parameter
	notch = 0.1
	output = _global_activity_tmp
[copy]
	input = _global_activity_tmp - 0.5
	output = _global_activity
[pot]
	pot = P1.2 # global variation parameter
	outputscale = 0.5
	output = _global_variation
[pot]
	pot = P2.1 # global fills parameter
	outputscale = 0.5
	output = _global_fills
[pot]
	pot = P2.2 # global rolls parameter
	outputscale = 0.5
	output = _global_rolls
[pot]
	pot = P3.1 # global offbeats parameter
	notch = 0.1
	output = _global_offbeats
[pot]
	pot = P3.2 # global distribution parameter
	notch = 0.1
	output = _global_distribution
[pot]
	pot = P3.3 # channel 1 activity
	notch = 0.1
	output = _algo1_activity
[pot]
	pot = P3.4 # channel 1 dejavu/morph parameters
	notch = 0.1
	lefthalfinv = _algo1_dejavu
	righthalf = _algo1_morph
[pot]
	pot = P3.5 # channel 2 activity
	notch = 0.1
	output = _algo2_activity
[pot]
	pot = P3.6 # channel 2 dejavu/morph parameters
	notch = 0.1
	lefthalfinv = _algo2_dejavu
	righthalf = _algo2_morph
[pot]
	pot = P3.7 # channel 3 activity
	notch = 0.1
	output = _algo3_activity
[pot]
	pot = P3.8 # channel 3 dejavu/morph parameters
	notch = 0.1
	lefthalfinv = _algo3_dejavu
	righthalf = _algo3_morph
[pot]
	pot = P3.9 # channel 4 activity
	notch = 0.1
	output = _algo4_activity
[pot]
	pot = P3.10 # channel 4 dejavu/morph parameters
	notch = 0.1
	lefthalfinv = _algo4_dejavu
	righthalf = _algo4_morph

### make leds for adjusting individual parameters (2nd p2b8) follow the 7 menus (1st p2b8)
[mixer]
	input1 = _menu1_L21 * _buttongroup_L11
	input2 = _menu2_L21 * L1.2
	input3 = _menu3_L21_blink * L1.3
	input4 = _menu4_L21_blink * _menu4_L14
	input5 = _menu5_L21 * L1.5
	input6 = _menu6_L21 * _menu6_L16
	input8 = _menu8_L21 * _menu8_L18
	maximum = L2.1
[mixer]
	input1 = _menu1_L22 * _buttongroup_L11
	input2 = _menu2_L22 * L1.2
	input3 = _menu3_L22_blink * L1.3
	input4 = _menu4_L22_blink * _menu4_L14
	input5 = _menu5_L22 * L1.5
	input6 = _menu6_L22_inv * _menu6_L16
	input8 = _menu8_L22 * _menu8_L18
	maximum = L2.2
[mixer]
	input1 = _menu1_L23 * _buttongroup_L11
	input2 = _menu2_L23 * L1.2
	input3 = _menu3_L23_blink * L1.3
	input4 = _menu4_L23_blink * _menu4_L14
	input5 = _menu5_L23 * L1.5
	input6 = _menu6_L23 * _menu6_L16
	input8 = _menu8_L23 * _menu8_L18
	maximum = L2.3
[mixer]
	input1 = _menu1_L24 * _buttongroup_L11
	input2 = _menu2_L24 * L1.2
	input3 = _menu3_L24_blink * L1.3
	input4 = _menu4_L24_blink * _menu4_L14
	input5 = _menu5_L24 * L1.5
	input6 = _menu6_L24_inv * _menu6_L16
	input8 = _menu8_L24 * _menu8_L18
	maximum = L2.4
[mixer]
	input1 = _menu1_L25 * _buttongroup_L11
	input2 = _menu2_L25 * L1.2
	input3 = _menu3_L25_blink * L1.3
	input4 = _menu4_L25_blink * _menu4_L14
	input5 = _menu5_L25 * L1.5
	input6 = _menu6_L25 * _menu6_L16
	input8 = _menu8_L25 * _menu8_L18
	maximum = L2.5
[mixer]
	input1 = _menu1_L26 * _buttongroup_L11
	input2 = _menu2_L26 * L1.2
	input3 = _menu3_L26_blink * L1.3
	input4 = _menu4_L26_blink * _menu4_L14
	input5 = _menu5_L26 * L1.5
	input6 = _menu6_L26_inv * _menu6_L16
	input8 = _menu8_L26 * _menu8_L18
	maximum = L2.6
[mixer]
	input1 = _menu1_L27 * _buttongroup_L11
	input2 = _menu2_L27 * L1.2
	input3 = _menu3_L27_blink * L1.3
	input4 = _menu4_L27_blink * _menu4_L14
	input5 = _menu5_L27 * L1.5
	input6 = _menu6_L27 * _menu6_L16
	input8 = _menu8_L27 * _menu8_L18
	maximum = L2.7
[mixer]
	input1 = _menu1_L28 * _buttongroup_L11
	input2 = _menu2_L28 * L1.2
	input3 = _menu3_L28_blink * L1.3
	input4 = _menu4_L28_blink * _menu4_L14
	input5 = _menu5_L28 * L1.5
	input6 = _menu6_L28_inv * _menu6_L16
	input8 = _menu8_L28 * _menu8_L18
	maximum = L2.8

### button group for the 7 menus
[buttongroup]
	button1 = B1.1
	button2 = B1.2
	button3 = B1.3
	button4 = B1.4
	button5 = B1.5
	button6 = B1.6
	button8 = B1.8
	led1 = _buttongroup_L11
	led2 = _buttongroup_L12
	led3 = L1.3
	led4 = _buttongroup_L14
	led5 = L1.5
	led6 = _buttongroup_L16
	led8 = _buttongroup_L18
#	longpress = _clear_all # alternative global clear button to save RAM (this eventually induces a cosmetic delay in the response of the short button presses though)

### Long press of B1.1 triggers a global clear of all algo sequences and random seeds. Useful after initialization of the patch, as the algoquencers will automatically load some random sequences. After initialization though, the entire state of the patch is saved to the droid memory and loaded after reboot. 
[button]
	button = B1.1
	longpress = _clear_all
[copy]
	input = _clear_all * _buttongroup_L11
	output = _clear
[contour]
	trigger = _clear_all
	attack = 0
	release = 0
	hold = 2
	output = _clear_on
[lfo]
	hz = 8
	square = _lfo
[copy]
	input = _clear_on * _lfo
	inverted = _clear_blink
[copy]
	input = _buttongroup_L11 * _clear_blink
	output = L1.1

### in menu1, also show 4 progressing barleds
[copy]
	input = _buttongroup_L11
	inverted = _buttongroup_L11_inv
[mixer]
	input1 = _buttongroup_L12
	input2 = _barled1 * _buttongroup_L11
	maximum = L1.2
[mixer]
	input1 = _buttongroup_L14
	input2 = _barled2 * _buttongroup_L11
	output = L1.4
[copy]
	input = _buttongroup_L14 * _buttongroup_L11_inv
	output = _menu4_L14
[mixer]
	input1 = _buttongroup_L16
	input2 = _barled3 * _buttongroup_L11
	output = L1.6
[copy]
	input = _buttongroup_L16 * _buttongroup_L11_inv
	output = _menu6_L16
[mixer]
	input1 = _buttongroup_L18
	input2 = _barled4 * _buttongroup_L11
	output = L1.8
[copy]
	input = _buttongroup_L18 * _buttongroup_L11_inv
	output = _menu8_L18

### global mute button
[button]
	button = B1.7
	states = 1
	output = _global_mute

# defining the global mute states on/off
[switch]
	input1 = 1
	input2 = 0
	forward = _global_mute + _global_mute_switch
	output = _global_mute_state_on
[copy]
	input = _global_mute_state_on
	inverted = _global_mute_state_off

# global mute trigger to switch individual channels on/off
[copy]
	input = _global_mute * _global_mute_state_on
	output = _global_mute_trigger_on

# global mute trigger to switch individual channels on/off
[copy]
	input = _global_mute * _global_mute_state_off
	output = _global_mute_trigger_off

# automatical adjustment of global mute led when all channels get manually unmuted
[mixer]
	input1 = _menu1_L21 * _global_mute_state_on
 	input2 = _menu1_L23 * _global_mute_state_on
	input3 = _menu1_L25 * _global_mute_state_on
	input4 = _menu1_L27 * _global_mute_state_on
	maximum = L1.7

# ... then sending a trigger to also inform the global mute state
[compare]
	input = L1.7
	compare = _global_mute_state_off
	output = _global_mute_switch_off

# automatical adjustment of global mute led when all channels get manually muted
[mixer]
	input1 = _menu1_L21_inv * _global_mute_state_off
 	input2 = _menu1_L23_inv * _global_mute_state_off
	input3 = _menu1_L25_inv * _global_mute_state_off
	input4 = _menu1_L27_inv * _global_mute_state_off
	maximum = _all_channels_muted
[copy]
	input = _all_channels_muted
	inverted = L1.7

# ... then sending a trigger to also inform the global mute state
[compare]
	input = L1.7
	compare = _global_mute_state_off
	output = _global_mute_switch_on

# combining both triggers to finally update the global mute state
[mixer]
	input1 = _global_mute_switch_on
	input2 = _global_mute_switch_off
	output = _global_mute_switch

### buttons for muting individual channels
# channel 1
[button]
	button = B2.1
	select = _buttongroup_L11
	states = 1
	output = _algo1_mute
[button]
	button = B2.2
	select = _buttongroup_L11
	states = 1
	output = _algo1_unmute

# embedding the global mute command into mute trigger for channel 1
[mixer]
	input1 = _algo1_mute
	input2 = _global_mute_trigger_on * _menu1_L21_inv
	input3 = _global_mute_trigger_off * _menu1_L21
	output = _algo1_mute_toggle

# channel 2
[button]
	button = B2.3
	select = _buttongroup_L11
	states = 1
	output = _algo2_mute
[button]
	button = B2.4
	select = _buttongroup_L11
	states = 1
	output = _algo2_unmute
[mixer]
	input1 = _algo2_mute
	input2 = _global_mute_trigger_on * _menu1_L23_inv
	input3 = _global_mute_trigger_off * _menu1_L23
	output = _algo2_mute_toggle

# channel 3
[button]
	button = B2.5
	select = _buttongroup_L11
	states = 1
	output = _algo3_mute
[button]
	button = B2.6
	select = _buttongroup_L11
	states = 1
	output = _algo3_unmute
[mixer]
	input1 = _algo3_mute
	input2 = _global_mute_trigger_on * _menu1_L25_inv
	input3 = _global_mute_trigger_off * _menu1_L25
	output = _algo3_mute_toggle

# channel 4
[button]
	button = B2.7
	select = _buttongroup_L11
	states = 1
	output = _algo4_mute
[button]
	button = B2.8
	select = _buttongroup_L11
	states = 1
	output = _algo4_unmute
[mixer]
	input1 = _algo4_mute
	input2 = _global_mute_trigger_on * _menu1_L27_inv
	input3 = _global_mute_trigger_off * _menu1_L27
	output = _algo4_mute_toggle

### buttons to reroll internal random sequences used for drum trigger variations and for accents, respectively
[button]
	button = B2.1
	select = L1.2 * _buttongroup_L11_inv
	states = 1
	led = _menu2_L21
	output = _algo1_reroll
[button]
	button = B2.2
	select = L1.2 * _buttongroup_L11_inv
	states = 1
	led = _menu2_L22
	output = _accent1_reroll
[button]
	button = B2.3
	select = L1.2 * _buttongroup_L11_inv
	states = 1
	led = _menu2_L23
	output = _algo2_reroll
[button]
	button = B2.4
	select = L1.2 * _buttongroup_L11_inv
	states = 1
	led = _menu2_L24
	output = _accent2_reroll
[button]
	button = B2.5
	select = L1.2 * _buttongroup_L11_inv
	states = 1
	led = _menu2_L25
	output = _algo3_reroll
[button]
	button = B2.6
	select = L1.2 * _buttongroup_L11_inv
	states = 1
	led = _menu2_L26
	output = _accent3_reroll
[button]
	button = B2.7
	select = L1.2 * _buttongroup_L11_inv
	states = 1
	led = _menu2_L27
	output = _algo4_reroll
[button]
	button = B2.8
	select = L1.2 * _buttongroup_L11_inv
	states = 1
	led = _menu2_L28
	output = _accent4_reroll

### buttons for the length of the algo trigger patterns
# algo1 length
[button]
	button = B2.1
	select = L1.3
	states = 1
	output = _algo1_down
	longpress = _algo1_reset8
[button]
	button = B2.2
	select = L1.3
	states = 1
	output = _algo1_up
	longpress = _algo1_reset16

# use button long press to decide for stepping through range [1, 8] or [9, 16] of pattern length
[nudge]
	amount = 1
	minimum = 0 # 'minimum' is taken as initial value. Thus, 'startvalue' is not necessary here.
	maximum = 1
	wrap = 0
	buttondown = _algo1_reset16
	buttonup = _algo1_reset8
	output = _algo1_minus8_on

# make left/right leds lit to represent the two stepping ranges
[superjust]
	bypass = 1
	input1 = _algo1_minus8_on * L1.3
	output1 = _menu3_L21
	input2 = _algo1_minus8_on * -1 + 1
	output2 = _algo1_minus8_off
	input3 = _algo1_minus8_off * L1.3
	output3 = _menu3_L22

# change the length of the trigger pattern and send it to the length parameter of individual algos
[nudge]
	reset = _algo1_reset16 + _algo1_reset8
	startvalue = 16
	amount = 1
	minimum = 9
	maximum = 16
	wrap = 1
	offset = _algo1_minus8_on * -8
	buttondown = _algo1_down + _algo1_dummy
	buttonup = _algo1_up + _algo1_dummy
	output = _algo1_length

# due to a bug in nudge, the output cv that is saved to memory (and thus loaded after reboot) is always the last that was set by using buttondown/buttonup. When reset is triggered, the output cv is correct but this cv is not being saved to memory. As a workaround, whenever I trigger reset with a long press (to jump to length 16 or 8), I imply a dummy usage of 1x buttondown and 1x buttonup to get the reset cv saved to memory.
[copy]
	input = _algo1_reset16 + _algo1_reset8
	output = _algo1_dummy

# make algo1 length range indicators flashing when values 8 or 16 are chosen
[lfo]
	hz = 5
#	level = 0.8 # use level to weaken the contrast of the flashing
	triangle = _state_lfo
[compare]
	input = _algo1_length
	compare = 8
	ifequal = 0
	else = 1
	output = _algo1_state8
[copy]
	input = _algo1_state8 * _state_lfo
	inverted = _algo1_state8_blink
[copy]
	input = _menu3_L21 * _algo1_state8_blink
	output = _menu3_L21_blink
[compare]
	input = _algo1_length
	compare = 16
	ifequal = 0
	else = 1
	output = _algo1_state16
[copy]
	input = _algo1_state16 * _state_lfo
	inverted = _algo1_state16_blink
[copy]
	input = _menu3_L22 * _algo1_state16_blink
	output = _menu3_L22_blink

# algo2 length
[button]
	button = B2.3
	select = L1.3
	states = 1
	output = _algo2_down
	longpress = _algo2_reset8
[button]
	button = B2.4
	select = L1.3
	states = 1
	output = _algo2_up
	longpress = _algo2_reset16
[nudge]
	amount = 1
	minimum = 0
	maximum = 1
	wrap = 0
	buttondown = _algo2_reset16
	buttonup = _algo2_reset8
	output = _algo2_minus8_on
[superjust]
	bypass = 1
	input1 = _algo2_minus8_on * L1.3
	output1 = _menu3_L23
	input2 = _algo2_minus8_on * -1 + 1
	output2 = _algo2_minus8_off
	input3 = _algo2_minus8_off * L1.3
	output3 = _menu3_L24
[nudge]
	reset = _algo2_reset16 + _algo2_reset8
	startvalue = 16
	amount = 1
	minimum = 9
	maximum = 16
	wrap = 1
	offset = _algo2_minus8_on * -8
	buttondown = _algo2_down + _algo2_dummy
	buttonup = _algo2_up + _algo2_dummy
	output = _algo2_length

# for nudge (bug), send dummy usage of 1x buttondown and 1x buttonup to get the reset cv saved to memory.
[copy]
	input = _algo2_reset16 + _algo2_reset8
	output = _algo2_dummy

# make algo2 length range indicators flashing when values 8 or 16 are chosen
[compare]
	input = _algo2_length
	compare = 8
	ifequal = 0
	else = 1
	output = _algo2_state8
[copy]
	input = _algo2_state8 * _state_lfo # _state_lfo is declared for the previous algo1
	inverted = _algo2_state8_blink
[copy]
	input = _menu3_L23 * _algo2_state8_blink
	output = _menu3_L23_blink
[compare]
	input = _algo2_length
	compare = 16
	ifequal = 0
	else = 1
	output = _algo2_state16
[copy]
	input = _algo2_state16 * _state_lfo # _state_lfo is declared for the previous algo1
	inverted = _algo2_state16_blink
[copy]
	input = _menu3_L24 * _algo2_state16_blink
	output = _menu3_L24_blink

# algo3 length
[button]
	button = B2.5
	select = L1.3
	states = 1
	output = _algo3_down
	longpress = _algo3_reset8
[button]
	button = B2.6
	select = L1.3
	states = 1
	output = _algo3_up
	longpress = _algo3_reset16
[nudge]
	amount = 1
	minimum = 0
	maximum = 1
	wrap = 0
	buttondown = _algo3_reset16
	buttonup = _algo3_reset8
	output = _algo3_minus8_on
[superjust]
	bypass = 1
	input1 = _algo3_minus8_on * L1.3
	output1 = _menu3_L25
	input2 = _algo3_minus8_on * -1 + 1
	output2 = _algo3_minus8_off
	input3 = _algo3_minus8_off * L1.3
	output3 = _menu3_L26
[nudge]
	reset = _algo3_reset16 + _algo3_reset8
	startvalue = 16
	amount = 1
	minimum = 9
	maximum = 16
	wrap = 1
	offset = _algo3_minus8_on * -8
	buttondown = _algo3_down + _algo3_dummy
	buttonup = _algo3_up + _algo3_dummy
	output = _algo3_length

# for nudge (bug), send dummy usage of 1x buttondown and 1x buttonup to get the reset cv saved to memory.
[copy]
	input = _algo3_reset16 + _algo3_reset8
	output = _algo3_dummy

# make algo3 length range indicators flashing when values 8 or 16 are chosen
[compare]
	input = _algo3_length
	compare = 8
	ifequal = 0
	else = 1
	output = _algo3_state8
[copy]
	input = _algo3_state8 * _state_lfo # _state_lfo is declared for the previous algo1
	inverted = _algo3_state8_blink
[copy]
	input = _menu3_L25 * _algo3_state8_blink
	output = _menu3_L25_blink
[compare]
	input = _algo3_length
	compare = 16
	ifequal = 0
	else = 1
	output = _algo3_state16
[copy]
	input = _algo3_state16 * _state_lfo # _state_lfo is declared for the previous algo1
	inverted = _algo3_state16_blink
[copy]
	input = _menu3_L26 * _algo3_state16_blink
	output = _menu3_L26_blink

# algo4 length
[button]
	button = B2.7
	select = L1.3
	states = 1
	output = _algo4_down
	longpress = _algo4_reset8
[button]
	button = B2.8
	select = L1.3
	states = 1
	output = _algo4_up
	longpress = _algo4_reset16
[nudge]
	amount = 1
	minimum = 0
	maximum = 1
	wrap = 0
	buttondown = _algo4_reset16
	buttonup = _algo4_reset8
	output = _algo4_minus8_on
[superjust]
	bypass = 1
	input1 = _algo4_minus8_on * L1.3
	output1 = _menu3_L27
	input2 = _algo4_minus8_on * -1 + 1
	output2 = _algo4_minus8_off
	input3 = _algo4_minus8_off * L1.3
	output3 = _menu3_L28
[nudge]
	reset = _algo4_reset16 + _algo4_reset8
	startvalue = 16
	amount = 1
	minimum = 9
	maximum = 16
	wrap = 1
	offset = _algo4_minus8_on * -8
	buttondown = _algo4_down + _algo4_dummy
	buttonup = _algo4_up + _algo4_dummy
	output = _algo4_length

# for nudge (bug), send dummy usage of 1x buttondown and 1x buttonup to get the reset cv saved to memory.
[copy]
	input = _algo4_reset16 + _algo4_reset8
	output = _algo4_dummy
[copy]
	input = _algo4_length * 0.01
	output = O2

# make algo4 length range indicators flashing when values 8 or 16 are chosen
[compare]
	input = _algo4_length
	compare = 8
	ifequal = 0
	else = 1
	output = _algo4_state8
[copy]
	input = _algo4_state8 * _state_lfo # _state_lfo is declared for the previous algo1
	inverted = _algo4_state8_blink
[copy]
	input = _menu3_L27 * _algo4_state8_blink
	output = _menu3_L27_blink
[compare]
	input = _algo4_length
	compare = 16
	ifequal = 0
	else = 1
	output = _algo4_state16
[copy]
	input = _algo4_state16 * _state_lfo # _state_lfo is declared for the previous algo1
	inverted = _algo4_state16_blink
[copy]
	input = _menu3_L28 * _algo4_state16_blink
	output = _menu3_L28_blink

### buttons for adjusting the level of the drum accents. The stepping ranges [1, 8] and [9, 16] follow the same logic as for the pattern length treated above. A level of 16 means that accents and non-accents have the same level (= ignoring accents). Lower level numbers subsequently increase the velocity contrast between accents and non-accents.
# algo1 accent level
[button]
	button = B2.1
	select = L1.4 * _buttongroup_L11_inv
	states = 1
	output = _algo1_acc_down
	longpress = _algo1_acc_reset8
[button]
	button = B2.2
	select = L1.4 * _buttongroup_L11_inv
	states = 1
	output = _algo1_acc_up
	longpress = _algo1_acc_reset16
[nudge]
	amount = 1
	minimum = 0
	maximum = 1
	wrap = 0
	buttondown = _algo1_acc_reset16
	buttonup = _algo1_acc_reset8
	output = _algo1_acc_minus8_on
[superjust]
	bypass = 1
	input1 = _algo1_acc_minus8_on * L1.4
	output1 = _menu4_L21
	input2 = _algo1_acc_minus8_on * -1 + 1
	output2 = _algo1_acc_minus8_off
	input3 = _algo1_acc_minus8_off * L1.4
	output3 = _menu4_L22
[nudge]
	reset = _algo1_acc_reset16 + _algo1_acc_reset8
	startvalue = 16
	amount = 1
	minimum = 9
	maximum = 16
	wrap = 1
	offset = _algo1_acc_minus8_on * -8
	buttondown = _algo1_acc_down + _algo1_acc_dummy
	buttonup = _algo1_acc_up + _algo1_acc_dummy
	output = _algo1_acc

# for nudge (bug), send dummy usage of 1x buttondown and 1x buttonup to get the reset cv saved to memory.
[copy]
	input = _algo1_acc_reset16 + _algo1_acc_reset8
	output = _algo1_acc_dummy
[copy]
	input = _algo1_acc * 0.0625 # set accent resolution. 0.0625 is 1/16, thus distributing the available 16 accent levels essentially to the whole velocity range [0, 1].
	output = _algo1_acc_level

# make algo1 accent range indicators flashing when values 8 or 16 are chosen
[compare]
	input = _algo1_acc
	compare = 8
	ifequal = 0
	else = 1
	output = _algo1_acc_state8
[copy]
	input = _algo1_acc_state8 * _state_lfo # _state_lfo is declared above, where the length parameter of algo1 is set up
	inverted = _algo1_acc_state8_blink
[copy]
	input = _menu4_L21 * _algo1_acc_state8_blink
	output = _menu4_L21_blink
[compare]
	input = _algo1_acc
	compare = 16
	ifequal = 0
	else = 1
	output = _algo1_acc_state16
[copy]
	input = _algo1_acc_state16 * _state_lfo # _state_lfo is declared above, where the length parameter of algo1 is set up
	inverted = _algo1_acc_state16_blink
[copy]
	input = _menu4_L22 * _algo1_acc_state16_blink
	output = _menu4_L22_blink

# algo2 accent level
[button]
	button = B2.3
	select = L1.4 * _buttongroup_L11_inv
	states = 1
	output = _algo2_acc_down
	longpress = _algo2_acc_reset8
[button]
	button = B2.4
	select = L1.4 * _buttongroup_L11_inv
	states = 1
	output = _algo2_acc_up
	longpress = _algo2_acc_reset16
[nudge]
	amount = 1
	minimum = 0
	maximum = 1
	wrap = 0
	buttondown = _algo2_acc_reset16
	buttonup = _algo2_acc_reset8
	output = _algo2_acc_minus8_on
[superjust]
	bypass = 1
	input1 = _algo2_acc_minus8_on * L1.4
	output1 = _menu4_L23
	input2 = _algo2_acc_minus8_on * -1 + 1
	output2 = _algo2_acc_minus8_off
	input3 = _algo2_acc_minus8_off * L1.4
	output3 = _menu4_L24
[nudge]
	reset = _algo2_acc_reset16 + _algo2_acc_reset8
	startvalue = 16
	amount = 1
	minimum = 9
	maximum = 16
	wrap = 1
	offset = _algo2_acc_minus8_on * -8
	buttondown = _algo2_acc_down + _algo2_acc_dummy
	buttonup = _algo2_acc_up + _algo2_acc_dummy
	output = _algo2_acc

# for nudge (bug), send dummy usage of 1x buttondown and 1x buttonup to get the reset cv saved to memory.
[copy]
	input = _algo2_acc_reset16 + _algo2_acc_reset8
	output = _algo2_acc_dummy
[copy]
	input = _algo2_acc * 0.0625 # set accent resolution
	output = _algo2_acc_level

# make algo2 accent range indicators flashing when values 8 or 16 are chosen
[compare]
	input = _algo2_acc
	compare = 8
	ifequal = 0
	else = 1
	output = _algo2_acc_state8
[copy]
	input = _algo2_acc_state8 * _state_lfo # _state_lfo is declared above, where the length parameter of algo1 is set up
	inverted = _algo2_acc_state8_blink
[copy]
	input = _menu4_L23 * _algo2_acc_state8_blink
	output = _menu4_L23_blink
[compare]
	input = _algo2_acc
	compare = 16
	ifequal = 0
	else = 1
	output = _algo2_acc_state16
[copy]
	input = _algo2_acc_state16 * _state_lfo # _state_lfo is declared above, where the length parameter of algo1 is set up
	inverted = _algo2_acc_state16_blink
[copy]
	input = _menu4_L24 * _algo2_acc_state16_blink
	output = _menu4_L24_blink

# algo3 accent level
[button]
	button = B2.5
	select = L1.4 * _buttongroup_L11_inv
	states = 1
	output = _algo3_acc_down
	longpress = _algo3_acc_reset8
[button]
	button = B2.6
	select = L1.4 * _buttongroup_L11_inv
	states = 1
	output = _algo3_acc_up
	longpress = _algo3_acc_reset16
[nudge]
	amount = 1
	minimum = 0
	maximum = 1
	wrap = 0
	buttondown = _algo3_acc_reset16
	buttonup = _algo3_acc_reset8
	output = _algo3_acc_minus8_on
[superjust]
	bypass = 1
	input1 = _algo3_acc_minus8_on * L1.4
	output1 = _menu4_L25
	input2 = _algo3_acc_minus8_on * -1 + 1
	output2 = _algo3_acc_minus8_off
	input3 = _algo3_acc_minus8_off * L1.4
	output3 = _menu4_L26
[nudge]
	reset = _algo3_acc_reset16 + _algo3_acc_reset8
	startvalue = 16
	amount = 1
	minimum = 9
	maximum = 16
	wrap = 1
	offset = _algo3_acc_minus8_on * -8
	buttondown = _algo3_acc_down + _algo3_acc_dummy
	buttonup = _algo3_acc_up + _algo3_acc_dummy
	output = _algo3_acc

# for nudge (bug), send dummy usage of 1x buttondown and 1x buttonup to get the reset cv saved to memory.
[copy]
	input = _algo3_acc_reset16 + _algo3_acc_reset8
	output = _algo3_acc_dummy
[copy]
	input = _algo3_acc * 0.0625 # set accent resolution
	output = _algo3_acc_level

# make algo3 accent range indicators flashing when values 8 or 16 are chosen
[compare]
	input = _algo3_acc
	compare = 8
	ifequal = 0
	else = 1
	output = _algo3_acc_state8
[copy]
	input = _algo3_acc_state8 * _state_lfo # _state_lfo is declared above, where the length parameter of algo1 is set up
	inverted = _algo3_acc_state8_blink
[copy]
	input = _menu4_L25 * _algo3_acc_state8_blink
	output = _menu4_L25_blink
[compare]
	input = _algo3_acc
	compare = 16
	ifequal = 0
	else = 1
	output = _algo3_acc_state16
[copy]
	input = _algo3_acc_state16 * _state_lfo # _state_lfo is declared above, where the length parameter of algo1 is set up
	inverted = _algo3_acc_state16_blink
[copy]
	input = _menu4_L26 * _algo3_acc_state16_blink
	output = _menu4_L26_blink

# algo4 accent level
[button]
	button = B2.7
	select = L1.4 * _buttongroup_L11_inv
	states = 1
	output = _algo4_acc_down
	longpress = _algo4_acc_reset8
[button]
	button = B2.8
	select = L1.4 * _buttongroup_L11_inv
	states = 1
	output = _algo4_acc_up
	longpress = _algo4_acc_reset16
[nudge]
	amount = 1
	minimum = 0
	maximum = 1
	wrap = 0
	buttondown = _algo4_acc_reset16
	buttonup = _algo4_acc_reset8
	output = _algo4_acc_minus8_on
[superjust]
	bypass = 1
	input1 = _algo4_acc_minus8_on * L1.4
	output1 = _menu4_L27
	input2 = _algo4_acc_minus8_on * -1 + 1
	output2 = _algo4_acc_minus8_off
	input3 = _algo4_acc_minus8_off * L1.4
	output3 = _menu4_L28
[nudge]
	reset = _algo4_acc_reset16 + _algo4_acc_reset8
	startvalue = 16
	amount = 1
	minimum = 9
	maximum = 16
	wrap = 1
	offset = _algo4_acc_minus8_on * -8
	buttondown = _algo4_acc_down + _algo4_acc_dummy
	buttonup = _algo4_acc_up + _algo4_acc_dummy
	output = _algo4_acc

# for nudge (bug), send dummy usage of 1x buttondown and 1x buttonup to get the reset cv saved to memory.
[copy]
	input = _algo4_acc_reset16 + _algo4_acc_reset8
	output = _algo4_acc_dummy
[copy]
	input = _algo4_acc * 0.0625 # set accent resolution
	output = _algo4_acc_level

# make algo4 accent range indicators flashing when values 8 or 16 are chosen
[compare]
	input = _algo4_acc
	compare = 8
	ifequal = 0
	else = 1
	output = _algo4_acc_state8
[copy]
	input = _algo4_acc_state8 * _state_lfo # _state_lfo is declared above, where the length parameter of algo1 is set up
	inverted = _algo4_acc_state8_blink
[copy]
	input = _menu4_L27 * _algo4_acc_state8_blink
	output = _menu4_L27_blink
[compare]
	input = _algo4_acc
	compare = 16
	ifequal = 0
	else = 1
	output = _algo4_acc_state16
[copy]
	input = _algo4_acc_state16 * _state_lfo # _state_lfo is declared above, where the length parameter of algo1 is set up
	inverted = _algo4_acc_state16_blink
[copy]
	input = _menu4_L28 * _algo4_acc_state16_blink
	output = _menu4_L28_blink

### buttons for including/excluding channels in fills and rolls
[button]
	button = B2.1
	select = L1.5
	states = 2
	led = _menu5_L21
	output = _algo1_fills
[button]
	button = B2.2
	select = L1.5
	states = 2
	led = _menu5_L22
	output = _algo1_rolls
[button]
	button = B2.3
	select = L1.5
	states = 2
	led = _menu5_L23
	output = _algo2_fills
[button]
	button = B2.4
	select = L1.5
	states = 2
	led = _menu5_L24
	output = _algo2_rolls
[button]
	button = B2.5
	select = L1.5
	states = 2
	led = _menu5_L25
	output = _algo3_fills
[button]
	button = B2.6
	select = L1.5
	states = 2
	led = _menu5_L26
	output = _algo3_rolls
[button]
	button = B2.7
	select = L1.5
	states = 2
	led = _menu5_L27
	output = _algo4_fills
[button]
	button = B2.8
	select = L1.5
	states = 2
	led = _menu5_L28
	output = _algo4_rolls

### buttons for incl/excl channels in variations and for attanuation of variation intensity
[button]
	button = B2.1
	select = L1.6 * _buttongroup_L11_inv
	led = _menu6_L21
	states = 2
	output = _algo1_variation
[button]
	button = B2.2
	select = L1.6 * _buttongroup_L11_inv
	led = _menu6_L22
	states = 4
	value1 = 1
	value2 = 0.75
	value3 = 0.5
	value4 = 0.25
	output = _algo1_variation_factor
[copy]
	input = _menu6_L22
	inverted = _menu6_L22_inv
[button]
	button = B2.3
	select = L1.6 * _buttongroup_L11_inv
	led = _menu6_L23
	states = 2
	output = _algo2_variation
[button]
	button = B2.4
	select = L1.6 * _buttongroup_L11_inv
	led = _menu6_L24
	states = 4
	value1 = 1
	value2 = 0.75
	value3 = 0.5
	value4 = 0.25
	output = _algo2_variation_factor
[copy]
	input = _menu6_L24
	inverted = _menu6_L24_inv
[button]
	button = B2.5
	select = L1.6 * _buttongroup_L11_inv
	led = _menu6_L25
	states = 2
	output = _algo3_variation
[button]
	button = B2.6
	select = L1.6 * _buttongroup_L11_inv
	led = _menu6_L26
	states = 4
	value1 = 1
	value2 = 0.75
	value3 = 0.5
	value4 = 0.25
	output = _algo3_variation_factor
[copy]
	input = _menu6_L26
	inverted = _menu6_L26_inv
[button]
	button = B2.7
	select = L1.6 * _buttongroup_L11_inv
	led = _menu6_L27
	states = 2
	output = _algo4_variation
[button]
	button = B2.8
	select = L1.6 * _buttongroup_L11_inv
	led = _menu6_L28
	states = 4
	value1 = 1
	value2 = 0.75
	value3 = 0.5
	value4 = 0.25
	output = _algo4_variation_factor
[copy]
	input = _menu6_L28
	inverted = _menu6_L28_inv
[superjust]
	bypass = 1
	input1 = _algo1_variation * _algo1_variation_factor
	input2 = _algo2_variation * _algo2_variation_factor
	input3 = _algo3_variation * _algo3_variation_factor
	input4 = _algo4_variation * _algo4_variation_factor
	output1 = _algo1_vars
	output2 = _algo2_vars
	output3 = _algo3_vars
	output4 = _algo4_vars

### buttons to set global fillorder
[buttongroup]
	select = L1.8 * _buttongroup_L11_inv
	button1 = B2.1
	button2 = B2.3
	button3 = B2.5
	button4 = B2.7
	led1 = _menu8_L21
	led2 = _menu8_L23
	led3 = _menu8_L25
	led4 = _menu8_L27
	value1 = 0
	value2 = 1
	value3 = 2
	value4 = 3
	output = _fillorder

### buttons to set global value of branches
[buttongroup]
	select = L1.8 * _buttongroup_L11_inv
	button1 = B2.2
	button2 = B2.4
	button3 = B2.6
	button4 = B2.8
	led1 = _menu8_L22
	led2 = _menu8_L24
	led3 = _menu8_L26
	led4 = _menu8_L28
	value1 = 0
	value2 = 1
	value3 = 2
	value4 = 3
	output = _branches

# Here follow the algoquencers. For each vioce there is the original algo which is permanently listening to an external trigger sequence, a second algo which is a copy of the original but applies all kind of modulations and is used as the outgoing trigger sequence, and a third one which uses independent random seeds to generate accents. Note that changes in the external sequences arrive at the modulation algoquencers with a delay of one bar (16 steps). Alternatively, you can delay the clock for the modulation algos a bit to enable tighter mapping of the external sequence (almost in time). However, in this patch this only works for a minimum delay of 50 ms, which already would require adjustments of the master clock for the remaining system. Also visually you clearly spot a 50 ms delay between the input and output leds, which I find disturbing as the leds keep me informed about the current settings of the patch. Thus I rather prefer to have everything in sync with the master clock and be one bar late regarding the external trigger sequences. In a perfomance, this can even be advantageous, allowing me to change the external sequences first and then having hands free to do other stuff when the changes finally arrive at the modulation algoquencers.
#[triggerdelay]
#	input = I1
#	delay = 0.05 # seconds
#	output = _clock_delayed

### This is the 1st algoquencer that is listening and automatically adjusting to an external drum sequence. Be aware that algoquencer buttons are toggle buttons.
[algoquencer]
	select = 1
 	clock = I1
	reset = _reset
	clear = _clear
	gate = _algo1_gateout
#	trigger = _algo1_triggerout
	barled1 = _barled1
	barled2 = _barled2
	barled3 = _barled3
	barled4 = _barled4
 	button1 = _algo1_button1_toggle
	button2 = _algo1_button2_toggle
	button3 = _algo1_button3_toggle
	button4 = _algo1_button4_toggle
	button5 = _algo1_button5_toggle
	button6 = _algo1_button6_toggle
	button7 = _algo1_button7_toggle
	button8 = _algo1_button8_toggle
	button9 = _algo1_button9_toggle
	button10 = _algo1_button10_toggle
	button11 = _algo1_button11_toggle
	button12 = _algo1_button12_toggle
	button13 = _algo1_button13_toggle
	button14 = _algo1_button14_toggle
	button15 = _algo1_button15_toggle
	button16 = _algo1_button16_toggle

### This is the copy of the 1st algoquencer where all kind of modulations and variations can be applied without disturbing the original listening algoquencer. The trigger outputs here are finally sent to droid outputs, intended to trigger a drum voice. In this example I use the X7 to run a midi drum sampler. See [midiout] at the end of the patch, 'notegatevelocity' is used for sending accents.
[algoquencer]
	select = 1
 	clock = I1
#	clock = _clock_delayed
	reset = _reset
	clear = _clear
	reroll = _algo1_reroll + _clear
	length = _algo1_length
	trigger = _drum_kick # output to trigger drum voice
	muteled = _menu1_L21
	unmuteled = _menu1_L22
	mutebutton = _algo1_mute_toggle
	unmutebutton = _algo1_unmute
	activity = _algo1_activity + _global_activity
	variation = _global_variation * _algo1_vars
	branches = _branches
	fills = _global_fills * _algo1_fills
	fillorder = _fillorder
	rolls = _global_rolls * _algo1_rolls
	dejavu = _algo1_dejavu
	morphs = _algo1_morph
	offbeats = _global_offbeats
	distribution = _global_distribution
 	button1 = _algo1_button1_toggle
	button2 = _algo1_button2_toggle
	button3 = _algo1_button3_toggle
	button4 = _algo1_button4_toggle
	button5 = _algo1_button5_toggle
	button6 = _algo1_button6_toggle
	button7 = _algo1_button7_toggle
	button8 = _algo1_button8_toggle
	button9 = _algo1_button9_toggle
	button10 = _algo1_button10_toggle
	button11 = _algo1_button11_toggle
	button12 = _algo1_button12_toggle
	button13 = _algo1_button13_toggle
	button14 = _algo1_button14_toggle
	button15 = _algo1_button15_toggle
	button16 = _algo1_button16_toggle

# inverted muteled; needed to automatically set global mute state to 'on' when all channels are manually muted.
[copy]
	input = _menu1_L21
	inverted = _menu1_L21_inv

### independent algoquencer used for accents of 1st channel. The accent algos only run internal random sequences and can be rerolled in menu 2. I use these additional algos (instead of the internal accent function) as I wish to be able to reroll their random sequences (= accents) without at the same time rerolling the random sequences used for the rythm variations in the corresponding trigger algos.
[algoquencer]
	select = 1
 	clock = I1
#	clock = _clock_delayed
	reset = _reset
	pitchlow = _algo1_acc_level
	pitchhigh = 1.0
	pitchresolution = 2
	reroll = _accent1_reroll + _clear
	pitch = _accent_kick

### 2nd original algoquencer, permanently listening and adjusting to an external trigger sequence
[algoquencer]
	select = 1
 	clock = I1
	reset = _reset
	clear = _clear
	gate = _algo2_gateout
#	trigger = _algo2_triggerout
 	button1 = _algo2_button1_toggle
	button2 = _algo2_button2_toggle
	button3 = _algo2_button3_toggle
	button4 = _algo2_button4_toggle
	button5 = _algo2_button5_toggle
	button6 = _algo2_button6_toggle
	button7 = _algo2_button7_toggle
	button8 = _algo2_button8_toggle
	button9 = _algo2_button9_toggle
	button10 = _algo2_button10_toggle
	button11 = _algo2_button11_toggle
	button12 = _algo2_button12_toggle
	button13 = _algo2_button13_toggle
	button14 = _algo2_button14_toggle
	button15 = _algo2_button15_toggle
	button16 = _algo2_button16_toggle

### copied 2nd algo to apply all modifications without messing up the original algo2 sequence
[algoquencer]
	select = 1
 	clock = I1
#	clock = _clock_delayed
	reset = _reset
	clear = _clear
	reroll = _algo2_reroll + _clear
	length = _algo2_length
	trigger = _drum_snare
	muteled = _menu1_L23
	unmuteled = _menu1_L24
	mutebutton = _algo2_mute_toggle
	unmutebutton = _algo2_unmute
	activity = _algo2_activity + _global_activity
	variation = _global_variation * _algo2_vars
	branches = _branches
	fills = _global_fills * _algo2_fills
	fillorder = _fillorder
	rolls = _global_rolls * _algo2_rolls
	dejavu = _algo2_dejavu
	morphs = _algo2_morph
	offbeats = _global_offbeats
	distribution = _global_distribution
 	button1 = _algo2_button1_toggle
	button2 = _algo2_button2_toggle
	button3 = _algo2_button3_toggle
	button4 = _algo2_button4_toggle
	button5 = _algo2_button5_toggle
	button6 = _algo2_button6_toggle
	button7 = _algo2_button7_toggle
	button8 = _algo2_button8_toggle
	button9 = _algo2_button9_toggle
	button10 = _algo2_button10_toggle
	button11 = _algo2_button11_toggle
	button12 = _algo2_button12_toggle
	button13 = _algo2_button13_toggle
	button14 = _algo2_button14_toggle
	button15 = _algo2_button15_toggle
	button16 = _algo2_button16_toggle
[copy]
	input = _menu1_L23
	inverted = _menu1_L23_inv

# accents for 2nd algoquencer
[algoquencer]
	select = 1
 	clock = I1
	reset = _reset
	pitchlow = _algo2_acc_level
	pitchhigh = 1.0
	pitchresolution = 2
	reroll = _accent2_reroll + _clear
	pitch = _accent_snare

### 3rd original algoquencer, permanently listening and adjusting to an external trigger sequence
[algoquencer]
	select = 1
 	clock = I1
	reset = _reset
	clear = _clear
	gate = _algo3_gateout
#	trigger = _algo3_triggerout
 	button1 = _algo3_button1_toggle
	button2 = _algo3_button2_toggle
	button3 = _algo3_button3_toggle
	button4 = _algo3_button4_toggle
	button5 = _algo3_button5_toggle
	button6 = _algo3_button6_toggle
	button7 = _algo3_button7_toggle
	button8 = _algo3_button8_toggle
	button9 = _algo3_button9_toggle
	button10 = _algo3_button10_toggle
	button11 = _algo3_button11_toggle
	button12 = _algo3_button12_toggle
	button13 = _algo3_button13_toggle
	button14 = _algo3_button14_toggle
	button15 = _algo3_button15_toggle
	button16 = _algo3_button16_toggle

### copied 3rd algo to apply all modifications without messing up the original algo3 sequence
[algoquencer]
	select = 1
 	clock = I1
#	clock = _clock_delayed
	reset = _reset
	clear = _clear
	reroll = _algo3_reroll + _clear
	length = _algo3_length
	trigger = _drum_hat
	muteled = _menu1_L25
	unmuteled = _menu1_L26
	mutebutton = _algo3_mute_toggle
	unmutebutton = _algo3_unmute
	activity = _algo3_activity + _global_activity
	variation = _global_variation * _algo3_vars
	branches = _branches
	fills = _global_fills * _algo3_fills
	fillorder = _fillorder
	rolls = _global_rolls * _algo3_rolls
	dejavu = _algo3_dejavu
	morphs = _algo3_morph
	offbeats = _global_offbeats
	distribution = _global_distribution
 	button1 = _algo3_button1_toggle
	button2 = _algo3_button2_toggle
	button3 = _algo3_button3_toggle
	button4 = _algo3_button4_toggle
	button5 = _algo3_button5_toggle
	button6 = _algo3_button6_toggle
	button7 = _algo3_button7_toggle
	button8 = _algo3_button8_toggle
	button9 = _algo3_button9_toggle
	button10 = _algo3_button10_toggle
	button11 = _algo3_button11_toggle
	button12 = _algo3_button12_toggle
	button13 = _algo3_button13_toggle
	button14 = _algo3_button14_toggle
	button15 = _algo3_button15_toggle
	button16 = _algo3_button16_toggle
[copy]
	input = _menu1_L25
	inverted = _menu1_L25_inv

# accents for 3rd algoquencer
[algoquencer]
	select = 1
 	clock = I1
	reset = _reset
	pitchlow = _algo3_acc_level
	pitchhigh = 1.0
	pitchresolution = 2
	reroll = _accent3_reroll + _clear
	pitch = _accent_hat

### 4th original algoquencer, permanently listening and adjusting to an external trigger sequence
[algoquencer]
	select = 1
 	clock = I1
	reset = _reset
	clear = _clear
	gate = _algo4_gateout
#	trigger = _algo4_triggerout
 	button1 = _algo4_button1_toggle
	button2 = _algo4_button2_toggle
	button3 = _algo4_button3_toggle
	button4 = _algo4_button4_toggle
	button5 = _algo4_button5_toggle
	button6 = _algo4_button6_toggle
	button7 = _algo4_button7_toggle
	button8 = _algo4_button8_toggle
	button9 = _algo4_button9_toggle
	button10 = _algo4_button10_toggle
	button11 = _algo4_button11_toggle
	button12 = _algo4_button12_toggle
	button13 = _algo4_button13_toggle
	button14 = _algo4_button14_toggle
	button15 = _algo4_button15_toggle
	button16 = _algo4_button16_toggle

### copied 3rd algo to apply all modifications without messing up the original algo4 sequence
[algoquencer]
	select = 1
 	clock = I1
#	clock = _clock_delayed
	reset = _reset
	clear = _clear
	reroll = _algo4_reroll + _clear
	length = _algo4_length
	trigger = _drum_clap
	muteled = _menu1_L27
	unmuteled = _menu1_L28
	mutebutton = _algo4_mute_toggle
	unmutebutton = _algo4_unmute
	activity = _algo4_activity + _global_activity
	variation = _global_variation * _algo4_vars
	branches = _branches
	fills = _global_fills * _algo4_fills
	fillorder = _fillorder
	rolls = _global_rolls * _algo4_rolls
	dejavu = _algo4_dejavu
	morphs = _algo4_morph
	offbeats = _global_offbeats
	distribution = _global_distribution
 	button1 = _algo4_button1_toggle
	button2 = _algo4_button2_toggle
	button3 = _algo4_button3_toggle
	button4 = _algo4_button4_toggle
	button5 = _algo4_button5_toggle
	button6 = _algo4_button6_toggle
	button7 = _algo4_button7_toggle
	button8 = _algo4_button8_toggle
	button9 = _algo4_button9_toggle
	button10 = _algo4_button10_toggle
	button11 = _algo4_button11_toggle
	button12 = _algo4_button12_toggle
	button13 = _algo4_button13_toggle
	button14 = _algo4_button14_toggle
	button15 = _algo4_button15_toggle
	button16 = _algo4_button16_toggle
[copy]
	input = _menu1_L27
	inverted = _menu1_L27_inv

# accents for 4th algoquencer
[algoquencer]
	select = 1
 	clock = I1
	reset = _reset
	pitchlow = _algo4_acc_level
	pitchhigh = 1.0
	pitchresolution = 2
	reroll = _accent4_reroll + _clear
	pitch = _accent_clap

### control leds for visual feedback of outgoing drum sequences
[superjust]
	bypass = 1
	input1 = _drum_kick
	output1 = R18
	input2 = _drum_snare
	output2 = R20
	input3 = _drum_hat
	output3 = R22
	input4 = _drum_clap
	output4 = R24

### transformation of algo gates output into AR spikes to avoid timing problems during the comparison with the incoming trigger sequences
[contour]
	trigger = _algo1_gateout
	attack = 0.6
	release = 0.6 * 0.05
	output = _algo1_gates
[contour]
	trigger = _algo2_gateout
	attack = 0.6
	release = 0.6 * 0.05
	output = _algo2_gates
[contour]
	trigger = _algo3_gateout
	attack = 0.6
	release = 0.6 * 0.05
	output = _algo3_gates
[contour]
	trigger = _algo4_gateout
	attack = 0.6
	release = 0.6 * 0.05
	output = _algo4_gates

### final output of the modified algo sequences to be sent to drum voices
[superjust]
	bypass = 1
	input1 = _drum_kick
	input2 = _drum_snare
	input3 = _drum_hat
	input4 = _drum_clap
	output1 = O1
	output2 = O2
	output3 = O3
	output4 = O4
	input5 = _accent_kick
	input6 = _accent_snare
	input7 = _accent_hat
	input8 = _accent_clap
	output5 = O5
	output6 = O6
	output7 = O7
	output8 = O8

# example for midi out
#[midiout]
#	channel = 16
#	note1 = 65
#	notegate1 = _drum_kick
#	notegatevelocity1 = _accent_kick
#	note2 = 62
#	notegate2 = _drum_snare
#	notegatevelocity2 = _accent_snare
#	note3 = 59
#	notegate3 = _drum_hat
#	notegatevelocity3 = _accent_hat
#	note4 = 57
#	notegate4 = _drum_clap
#	notegatevelocity4 = _accent_clap
	
