[droid]
    ledbrightness = 0.5

[p2b8]
[p2b8]
[p10]

### start all internal sequencers per trigger in or midi controller
[copy]
	input = I2
	output = _reset
#[midiin]
#	start = _reset

### send reset also to the external sequencer module, which I use to create the original drum patterns to be modified with algoquencers in this patch
#[copy]
#	input = _reset
#	output = G9

### create a 16-step master sequence for identifyers of the step position in the [compare] circuits
[algoquencer]
	clock = I1
	reset = _reset
	clearpage = _reset # Deselect all step buttons. This is necessary to get initial/default led outputs as 0V.
	length = 16
	led1 = _trigger1
	led2 = _trigger2
	led3 = _trigger3
	led4 = _trigger4
	led5 = _trigger5
	led6 = _trigger6
	led7 = _trigger7
	led8 = _trigger8
	led9 = _trigger9
	led10 = _trigger10
	led11 = _trigger11
	led12 = _trigger12
	led13 = _trigger13
	led14 = _trigger14
	led15 = _trigger15
	led16 = _trigger16
	
### Convert trigger inputs from external device into triangular AR spikes. The same is done for the listening algoquencers. This is necessary to identify differences in the trigger steps between the current algo and the external sequence, allowing to adjust the algos to changes in the external sequence. The slopes of the spikes asure that imperfect timing of the two trigger signals to be compared lead to only small cv differences. Large differences are used to identify real changes in the exteranl sequence. Be also aware that the external sequence can´t be directly fed to the algoquencer buttons as these are toggle buttons. The algo buttons would therefore be permanently turned on/off each repeating cycle.
[contour]
	trigger = I5 # 1st incoming trigger signal sent by external drum sequencer
#	trigger = G1
	attack = 0.6 # AR values work also for higher bpm (checked up to 150, if I remember correctly)
	release = 0.6 * 0.05
	output = _external1
[contour]
	trigger = I6 # 2nd incoming trigger signal sent by external drum sequencer
#	trigger = G3
	attack = 0.6
	release = 0.6 * 0.05
	output = _external2
[contour]
	trigger = I7 # 3rd incoming trigger signal sent by external drum sequencer
#	trigger = G5
	attack = 0.6
	release = 0.6 * 0.05
	output = _external3
[contour]
	trigger = I8 # 4th incoming trigger signal sent by external drum sequencer
#	trigger = G7
	attack = 0.6
	release = 0.6 * 0.05
	output = _external4

### compare algo triggers with external signals and create a sequence of toggle signals for step buttons in case of deviation
[compare]
	input = _algo1_gates
	compare = _external1
	precision = 0.8
	ifequal = 0
	else = 1
	output = _all1_button_toggle_tmp
[compare]
	input = _algo2_gates
	compare = _external2
	precision = 0.8
	ifequal = 0
	else = 1
	output = _all2_button_toggle_tmp
[compare]
	input = _algo3_gates
	compare = _external3
	precision = 0.8
	ifequal = 0
	else = 1
	output = _all3_button_toggle_tmp
[compare]
	input = _algo4_gates
	compare = _external4
	precision = 0.8
	ifequal = 0
	else = 1
	output = _all4_button_toggle_tmp
[superjust]
	bypass = 1
	input1 = _all1_button_toggle_tmp * _submenu8_L28_inv
	output1 = _all1_button_toggle
	input2 = _all2_button_toggle_tmp * _submenu8_L28_inv
	output2 = _all2_button_toggle
	input3 = _all3_button_toggle_tmp * _submenu8_L28_inv
	output3 = _all3_button_toggle
	input4 = _all4_button_toggle_tmp * _submenu8_L28_inv
	output4 = _all4_button_toggle

### create unique triggers to toggle step buttons of the algoquencers, thus always adjusting them to the external drum sequences
[superjust]
	bypass = 1
	input1 = _all1_button_toggle * _trigger1
	input2 = _all1_button_toggle * _trigger2
	input3 = _all1_button_toggle * _trigger3
	input4 = _all1_button_toggle * _trigger4
	input5 = _all1_button_toggle * _trigger5
	input6 = _all1_button_toggle * _trigger6
	input7 = _all1_button_toggle * _trigger7
	input8 = _all1_button_toggle * _trigger8
	output1 = _algo1_button1_toggle
	output2 = _algo1_button2_toggle
	output3 = _algo1_button3_toggle
	output4 = _algo1_button4_toggle
	output5 = _algo1_button5_toggle
	output6 = _algo1_button6_toggle
	output7 = _algo1_button7_toggle
	output8 = _algo1_button8_toggle
[superjust]
	bypass = 1
	input1 = _all1_button_toggle * _trigger9
	input2 = _all1_button_toggle * _trigger10
	input3 = _all1_button_toggle * _trigger11
	input4 = _all1_button_toggle * _trigger12
	input5 = _all1_button_toggle * _trigger13
	input6 = _all1_button_toggle * _trigger14
	input7 = _all1_button_toggle * _trigger15
	input8 = _all1_button_toggle * _trigger16
	output1 = _algo1_button9_toggle
	output2 = _algo1_button10_toggle
	output3 = _algo1_button11_toggle
	output4 = _algo1_button12_toggle
	output5 = _algo1_button13_toggle
	output6 = _algo1_button14_toggle
	output7 = _algo1_button15_toggle
	output8 = _algo1_button16_toggle
[superjust]
	bypass = 1
	input1 = _all2_button_toggle * _trigger1
	input2 = _all2_button_toggle * _trigger2
	input3 = _all2_button_toggle * _trigger3
	input4 = _all2_button_toggle * _trigger4
	input5 = _all2_button_toggle * _trigger5
	input6 = _all2_button_toggle * _trigger6
	input7 = _all2_button_toggle * _trigger7
	input8 = _all2_button_toggle * _trigger8
	output1 = _algo2_button1_toggle
	output2 = _algo2_button2_toggle
	output3 = _algo2_button3_toggle
	output4 = _algo2_button4_toggle
	output5 = _algo2_button5_toggle
	output6 = _algo2_button6_toggle
	output7 = _algo2_button7_toggle
	output8 = _algo2_button8_toggle
[superjust]
	bypass = 1
	input1 = _all2_button_toggle * _trigger9
	input2 = _all2_button_toggle * _trigger10
	input3 = _all2_button_toggle * _trigger11
	input4 = _all2_button_toggle * _trigger12
	input5 = _all2_button_toggle * _trigger13
	input6 = _all2_button_toggle * _trigger14
	input7 = _all2_button_toggle * _trigger15
	input8 = _all2_button_toggle * _trigger16
	output1 = _algo2_button9_toggle
	output2 = _algo2_button10_toggle
	output3 = _algo2_button11_toggle
	output4 = _algo2_button12_toggle
	output5 = _algo2_button13_toggle
	output6 = _algo2_button14_toggle
	output7 = _algo2_button15_toggle
	output8 = _algo2_button16_toggle
[superjust]
	bypass = 1
	input1 = _all3_button_toggle * _trigger1
	input2 = _all3_button_toggle * _trigger2
	input3 = _all3_button_toggle * _trigger3
	input4 = _all3_button_toggle * _trigger4
	input5 = _all3_button_toggle * _trigger5
	input6 = _all3_button_toggle * _trigger6
	input7 = _all3_button_toggle * _trigger7
	input8 = _all3_button_toggle * _trigger8
	output1 = _algo3_button1_toggle
	output2 = _algo3_button2_toggle
	output3 = _algo3_button3_toggle
	output4 = _algo3_button4_toggle
	output5 = _algo3_button5_toggle
	output6 = _algo3_button6_toggle
	output7 = _algo3_button7_toggle
	output8 = _algo3_button8_toggle
[superjust]
	bypass = 1
	input1 = _all3_button_toggle * _trigger9
	input2 = _all3_button_toggle * _trigger10
	input3 = _all3_button_toggle * _trigger11
	input4 = _all3_button_toggle * _trigger12
	input5 = _all3_button_toggle * _trigger13
	input6 = _all3_button_toggle * _trigger14
	input7 = _all3_button_toggle * _trigger15
	input8 = _all3_button_toggle * _trigger16
	output1 = _algo3_button9_toggle
	output2 = _algo3_button10_toggle
	output3 = _algo3_button11_toggle
	output4 = _algo3_button12_toggle
	output5 = _algo3_button13_toggle
	output6 = _algo3_button14_toggle
	output7 = _algo3_button15_toggle
	output8 = _algo3_button16_toggle
[superjust]
	bypass = 1
	input1 = _all4_button_toggle * _trigger1
	input2 = _all4_button_toggle * _trigger2
	input3 = _all4_button_toggle * _trigger3
	input4 = _all4_button_toggle * _trigger4
	input5 = _all4_button_toggle * _trigger5
	input6 = _all4_button_toggle * _trigger6
	input7 = _all4_button_toggle * _trigger7
	input8 = _all4_button_toggle * _trigger8
	output1 = _algo4_button1_toggle
	output2 = _algo4_button2_toggle
	output3 = _algo4_button3_toggle
	output4 = _algo4_button4_toggle
	output5 = _algo4_button5_toggle
	output6 = _algo4_button6_toggle
	output7 = _algo4_button7_toggle
	output8 = _algo4_button8_toggle
[superjust]
	bypass = 1
	input1 = _all4_button_toggle * _trigger9
	input2 = _all4_button_toggle * _trigger10
	input3 = _all4_button_toggle * _trigger11
	input4 = _all4_button_toggle * _trigger12
	input5 = _all4_button_toggle * _trigger13
	input6 = _all4_button_toggle * _trigger14
	input7 = _all4_button_toggle * _trigger15
	input8 = _all4_button_toggle * _trigger16
	output1 = _algo4_button9_toggle
	output2 = _algo4_button10_toggle
	output3 = _algo4_button11_toggle
	output4 = _algo4_button12_toggle
	output5 = _algo4_button13_toggle
	output6 = _algo4_button14_toggle
	output7 = _algo4_button15_toggle
	output8 = _algo4_button16_toggle

### declare pots and buttons
[pot]
	pot = P1.1 # global activity parameter
	preset = _preset
	loadpreset = _load
	savepreset = _save
	notch = 0.1
	ledgauge = on
	output = _global_activity_tmp
[copy]
	input = _global_activity_tmp - 0.5
	output = _global_activity
[pot]
	pot = P1.2 # global variation parameter
	preset = _preset
	loadpreset = _load
	savepreset = _save
	outputscale = 0.5
	ledgauge = on
	output = _global_variation
[pot]
	pot = P2.1 # global fills parameter
	preset = _preset
	loadpreset = _load
	savepreset = _save
	outputscale = 0.5
	ledgauge = on
	output = _global_fills
[pot]
	pot = P2.2 # global rolls parameter
	preset = _preset
	loadpreset = _load
	savepreset = _save
	outputscale = 0.5
	ledgauge = on
	output = _global_rolls
[pot]
	pot = P3.1 # global offbeats parameter
	preset = _preset
	loadpreset = _load
	savepreset = _save
	notch = 0.1
	ledgauge = on
	output = _global_offbeats
[pot]
	pot = P3.2 # global distribution parameter
	preset = _preset
	loadpreset = _load
	savepreset = _save
	notch = 0.1
	ledgauge = on
	output = _global_distribution
[pot]
	pot = P3.3 # channel 1 activity
	preset = _preset
	loadpreset = _load
	savepreset = _save
	notch = 0.1
	ledgauge = on
	output = _algo1_activity
[pot]
	pot = P3.4 # channel 1 dejavu/morph parameters
	preset = _preset
	loadpreset = _load
	savepreset = _save
	notch = 0.1
	ledgauge = on
	lefthalfinv = _algo1_dejavu
	righthalf = _algo1_morph
[pot]
	pot = P3.5 # channel 2 activity
	preset = _preset
	loadpreset = _load
	savepreset = _save
	notch = 0.1
	ledgauge = on
	output = _algo2_activity
[pot]
	pot = P3.6 # channel 2 dejavu/morph parameters
	preset = _preset
	loadpreset = _load
	savepreset = _save
	notch = 0.1
	ledgauge = on
	lefthalfinv = _algo2_dejavu
	righthalf = _algo2_morph
[pot]
	pot = P3.7 # channel 3 activity
	preset = _preset
	loadpreset = _load
	savepreset = _save
	notch = 0.1
	ledgauge = on
	output = _algo3_activity
[pot]
	pot = P3.8 # channel 3 dejavu/morph parameters
	preset = _preset
	loadpreset = _load
	savepreset = _save
	notch = 0.1
	ledgauge = on
	lefthalfinv = _algo3_dejavu
	righthalf = _algo3_morph
[pot]
	pot = P3.9 # channel 3 activity
	preset = _preset
	loadpreset = _load
	savepreset = _save
	notch = 0.1
	ledgauge = on
	output = _algo4_activity
[pot]
	pot = P3.10 # channel 3 dejavu/morph parameters
	preset = _preset
	loadpreset = _load
	savepreset = _save
	notch = 0.1
	ledgauge = on
	lefthalfinv = _algo4_dejavu
	righthalf = _algo4_morph

### leds of individual parameters (2nd p2b8) follow the 6 menus (1st p2b8)
[mixer]
	input1 = _menu1_L21 * _buttongroup_L11
	input2 = _menu2_L21 * L1.2
	input3 = _menu3_L21_blink * L1.3
	input4 = _menu4_L21_blink * _menu4_L14
	input5 = _menu5_L21 * L1.5
	input6 = _menu6_L21 * _menu6_L16
	input7 = _submenu8_L21 * _load_queue_dim + _save_blink0
	input8 = _menu8_L21 * _menu8
	maximum = L2.1
[mixer]
	input1 = _menu1_L22 * _buttongroup_L11
	input2 = _menu2_L22 * L1.2
	input3 = _menu3_L22_blink * L1.3
	input4 = _menu4_L22_blink * _menu4_L14
	input5 = _menu5_L22 * L1.5
	input6 = _menu6_L22_inv * _menu6_L16
	input7 = _submenu8_L22 * _load_queue_dim + _save_blink1
	input8 = _menu8_L22 * _menu8
	maximum = L2.2
[mixer]
	input1 = _menu1_L23 * _buttongroup_L11
	input2 = _menu2_L23 * L1.2
	input3 = _menu3_L23_blink * L1.3
	input4 = _menu4_L23_blink * _menu4_L14
	input5 = _menu5_L23 * L1.5
	input6 = _menu6_L23 * _menu6_L16
	input7 = _submenu8_L23 * _load_queue_dim + _save_blink2
	input8 = _menu8_L23 * _menu8
	maximum = L2.3
[mixer]
	input1 = _menu1_L24 * _buttongroup_L11
	input2 = _menu2_L24 * L1.2
	input3 = _menu3_L24_blink * L1.3
	input4 = _menu4_L24_blink * _menu4_L14
	input5 = _menu5_L24 * L1.5
	input6 = _menu6_L24_inv * _menu6_L16
	input7 = _submenu8_L24 * _load_queue_dim + _save_blink3
	input8 = _menu8_L24 * _menu8
	maximum = L2.4
[mixer]
	input1 = _menu1_L25 * _buttongroup_L11
	input2 = _menu2_L25 * L1.2
	input3 = _menu3_L25_blink * L1.3
	input4 = _menu4_L25_blink * _menu4_L14
	input5 = _menu5_L25 * L1.5
	input6 = _menu6_L25 * _menu6_L16
	input7 = _submenu8_L25 * _load_queue_dim + _save_blink4
	input8 = _menu8_L25 * _menu8
	maximum = L2.5
[mixer]
	input1 = _menu1_L26 * _buttongroup_L11
	input2 = _menu2_L26 * L1.2
	input3 = _menu3_L26_blink * L1.3
	input4 = _menu4_L26_blink * _menu4_L14
	input5 = _menu5_L26 * L1.5
	input6 = _menu6_L26_inv * _menu6_L16
	input7 = _submenu8_L26 * _load_queue_dim + _save_blink5
	input8 = _menu8_L26 * _menu8
	maximum = L2.6
[mixer]
	input1 = _menu1_L27 * _buttongroup_L11
	input2 = _menu2_L27 * L1.2
	input3 = _menu3_L27_blink * L1.3
	input4 = _menu4_L27_blink * _menu4_L14
	input5 = _menu5_L27 * L1.5
	input6 = _menu6_L27 * _menu6_L16
	input7 = _submenu8_L27 * _load_queue_dim + _save_blink6
	input8 = _menu8_L27 * _menu8
	maximum = L2.7
[mixer]
	input1 = _menu1_L28 * _buttongroup_L11
	input2 = _menu2_L28 * L1.2
	input3 = _menu3_L28_blink * L1.3
	input4 = _menu4_L28_blink * _menu4_L14
	input5 = _menu5_L28 * L1.5
	input6 = _menu6_L28_inv * _menu6_L16
	input7 = _submenu8 * _submenu8_L28
	input8 = _menu8_L28 * _menu8
	maximum = L2.8

### button group for menus 1-6
[buttongroup]
	button1 = B1.1
	button2 = B1.2
	button3 = B1.3
	button4 = B1.4
	button5 = B1.5
	button6 = B1.6
	button8 = B1.8
	led1 = _buttongroup_L11
	led2 = _buttongroup_L12
	led3 = L1.3
	led4 = _buttongroup_L14
	led5 = L1.5
	led6 = _buttongroup_L16
	buttonoutput8 = _buttongroup_L18
#	longpress = _clear_all # alternative global clear button to save RAM (eventually induces a cosmetic delay in the response of the short button presses though)

### Long press of B1.1 triggers a global clear of all algo sequences and random seeds. Useful after initialization of the patch, as the algoquencers will automatically load some random sequences. After initialization though, the entire state of the patch is saved to the droid memory and loaded after reboot. 
[button]
	button = B1.1
	longpress = _clear_all
[copy]
	input = _clear_all * _buttongroup_L11
	output = _clear
[contour]
	trigger = _clear_all
	attack = 0
	release = 0
	hold = 2
	output = _clear_on
[lfo]
	hz = 8
	square = _lfo
[copy]
	input = _clear_on * _lfo
	output = _clear_blink_tmp
[copy]
	input = 1 - _clear_blink_tmp
	output = _clear_blink
[copy]
	input = _buttongroup_L11 * _clear_blink
	output = L1.1

### in menu1 also show progressing barleds
[copy]
	input = 1 - _buttongroup_L11
	output = _buttongroup_L11_inv
[mixer]
	input1 = _buttongroup_L12
	input2 = _barled1 * _buttongroup_L11
	maximum = L1.2
[mixer]
	input1 = _buttongroup_L14
	input2 = _barled2 * _buttongroup_L11
	output = L1.4
[copy]
	input = _buttongroup_L14 * _buttongroup_L11_inv
	output = _menu4_L14
[mixer]
	input1 = _buttongroup_L16
	input2 = _barled3 * _buttongroup_L11
	output = L1.6
[copy]
	input = _buttongroup_L16 * _buttongroup_L11_inv
	output = _menu6_L16
[mixer]
	input1 = _menu8
	input2 = _barled4 * _buttongroup_L11
	input3 = _submenu8 * _state_lfo_slow
	output = L1.8
[copy]
	input = _buttongroup_L18 * _buttongroup_L11_inv
	output = _menu8_L18

### global mute button
[button]
	button = B1.7
	states = 1
	output = _global_mute
# defining the global mute states on/off
[switch]
	input1 = 1
	input2 = 0
	forward = _global_mute + _global_mute_switch
	output = _global_mute_state_on
[copy]
	input = 1 - _global_mute_state_on
	output = _global_mute_state_off
# global mute trigger to switch individual channels on/off
[copy]
	input = _global_mute * _global_mute_state_on
	output = _global_mute_trigger_on
# global mute trigger to switch individual channels on/off
[copy]
	input = _global_mute * _global_mute_state_off
	output = _global_mute_trigger_off
# automatic adjustment of global mute led when all channels get manually unmuted
[mixer]
	input1 = _menu1_L21 * _global_mute_state_on
 	input2 = _menu1_L23 * _global_mute_state_on
	input3 = _menu1_L25 * _global_mute_state_on
	input4 = _menu1_L27 * _global_mute_state_on
	maximum = L1.7
# ... then sending a trigger to also adjust the global mute state
[compare]
	input = L1.7
	compare = _global_mute_state_off
	output = _global_mute_switch_off
# automatic adjustment of global mute led when all channels get manually muted
[mixer]
	input1 = _menu1_L21_inv * _global_mute_state_off
 	input2 = _menu1_L23_inv * _global_mute_state_off
	input3 = _menu1_L25_inv * _global_mute_state_off
	input4 = _menu1_L27_inv * _global_mute_state_off
	maximum = _all_channels_muted
[copy]
	input = 1 - _all_channels_muted
	output = L1.7
# ... then sending a trigger to also adjust the global mute state
[compare]
	input = L1.7
	compare = _global_mute_state_off
	output = _global_mute_switch_on
# combining both triggers to finally adjust the global mute state
[mixer]
	input1 = _global_mute_switch_on
	input2 = _global_mute_switch_off
	output = _global_mute_switch

### buttons for muting individual channels
# channel 1
[button]
	button = B2.1
	select = _buttongroup_L11
	states = 1
	output = _algo1_mute
[button]
	button = B2.2
	select = _buttongroup_L11
	states = 1
	output = _algo1_unmute
# embedding the global mute command into mute trigger for channel 1
[mixer]
	input1 = _algo1_mute + _algo1_mute_load
	input2 = _global_mute_trigger_on * _menu1_L21_inv
	input3 = _global_mute_trigger_off * _menu1_L21
	output = _algo1_mute_toggle
# channel 2
[button]
	button = B2.3
	select = _buttongroup_L11
	states = 1
	output = _algo2_mute
[button]
	button = B2.4
	select = _buttongroup_L11
	states = 1
	output = _algo2_unmute
[mixer]
	input1 = _algo2_mute + _algo2_mute_load
	input2 = _global_mute_trigger_on * _menu1_L23_inv
	input3 = _global_mute_trigger_off * _menu1_L23
	output = _algo2_mute_toggle
# channel 3
[button]
	button = B2.5
	select = _buttongroup_L11
	states = 1
	output = _algo3_mute
[button]
	button = B2.6
	select = _buttongroup_L11
	states = 1
	output = _algo3_unmute
[mixer]
	input1 = _algo3_mute + _algo3_mute_load
	input2 = _global_mute_trigger_on * _menu1_L25_inv
	input3 = _global_mute_trigger_off * _menu1_L25
	output = _algo3_mute_toggle
# channel 4
[button]
	button = B2.7
	select = _buttongroup_L11
	states = 1
	output = _algo4_mute
[button]
	button = B2.8
	select = _buttongroup_L11
	states = 1
	output = _algo4_unmute
[mixer]
	input1 = _algo4_mute + _algo4_mute_load
	input2 = _global_mute_trigger_on * _menu1_L27_inv
	input3 = _global_mute_trigger_off * _menu1_L27
	output = _algo4_mute_toggle

### buttons to reroll internal random sequences used for drum trigger variations and for accents, respectively
[button]
	button = B2.1
	select = L1.2 * _buttongroup_L11_inv
	states = 1
	led = _menu2_L21
	output = _algo1_reroll
[button]
	button = B2.2
	select = L1.2 * _buttongroup_L11_inv
	states = 1
	led = _menu2_L22
	output = _accent1_reroll
[button]
	button = B2.3
	select = L1.2 * _buttongroup_L11_inv
	states = 1
	led = _menu2_L23
	output = _algo2_reroll
[button]
	button = B2.4
	select = L1.2 * _buttongroup_L11_inv
	states = 1
	led = _menu2_L24
	output = _accent2_reroll
[button]
	button = B2.5
	select = L1.2 * _buttongroup_L11_inv
	states = 1
	led = _menu2_L25
	output = _algo3_reroll
[button]
	button = B2.6
	select = L1.2 * _buttongroup_L11_inv
	states = 1
	led = _menu2_L26
	output = _accent3_reroll
[button]
	button = B2.7
	select = L1.2 * _buttongroup_L11_inv
	states = 1
	led = _menu2_L27
	output = _algo4_reroll
[button]
	button = B2.8
	select = L1.2 * _buttongroup_L11_inv
	states = 1
	led = _menu2_L28
	output = _accent4_reroll

### buttons for the length of the trigger patterns
# algo1 length
[button]
	button = B2.1
	select = L1.3
	shortpress = _algo1_down
	longpress = _algo1_reset8
[button]
	button = B2.2
	select = L1.3
	shortpress = _algo1_up
	longpress = _algo1_reset16
# use button long press to decide for stepping through range [1, 8] or [9, 16] of pattern length
[nudge]
	preset = _preset
	loadpreset = _load
	savepreset = _save
	amount = 1
	minimum = 0 # 'minimum' is taken as initial value. Thus, 'startvalue' is not necessary here.
	maximum = 1
	wrap = 0
	buttondown = _algo1_reset16
	buttonup = _algo1_reset8
	output = _algo1_minus8_on
# make left/right leds lit to represent the two stepping ranges
[superjust]
	bypass = 1
	input1 = _algo1_minus8_on * L1.3
	output1 = _menu3_L21
	input2 = _algo1_minus8_on * -1 + 1
	output2 = _algo1_minus8_off
	input3 = _algo1_minus8_off * L1.3
	output3 = _menu3_L22

# change the length of the trigger pattern and send it to the length parameter of individual algos
[nudge]
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _algo1_reset16 + _algo1_reset8
	startvalue = 16
	amount = 1
	minimum = 9
	maximum = 16
	wrap = 1
	offset = _algo1_minus8_on * -8
	buttondown = _algo1_down
	buttonup = _algo1_up
	output = _algo1_length

# make algo1 length range indicators flashing when values 8 or 16 are chosen
[lfo]
	hz = 5
#	level = 0.8 # use level to weaken the contrast of the flashing
	triangle = _state_lfo
[lfo]
	hz = 1.5
	triangle = _state_lfo_slow

[compare]
	input = _algo1_length
	compare = 8
	ifequal = 0
	else = 1
	output = _algo1_state8
[copy]
	input = _algo1_state8 * _state_lfo
	output = _algo1_state8_blink_tmp
[copy]
	input = 1 - _algo1_state8_blink_tmp
	output = _algo1_state8_blink
[copy]
	input = _menu3_L21 * _algo1_state8_blink
	output = _menu3_L21_blink
[compare]
	input = _algo1_length
	compare = 16
	ifequal = 0
	else = 1
	output = _algo1_state16
[copy]
	input = _algo1_state16 * _state_lfo
	output = _algo1_state16_blink_tmp
[copy]
	input = 1 - _algo1_state16_blink_tmp
	output = _algo1_state16_blink
[copy]
	input = _menu3_L22 * _algo1_state16_blink
	output = _menu3_L22_blink

# algo2 length
[button]
	button = B2.3
	select = L1.3
	shortpress = _algo2_down
	longpress = _algo2_reset8
[button]
	button = B2.4
	select = L1.3
	shortpress = _algo2_up
	longpress = _algo2_reset16
[nudge]
	preset = _preset
	loadpreset = _load
	savepreset = _save
	amount = 1
	minimum = 0
	maximum = 1
	wrap = 0
	buttondown = _algo2_reset16
	buttonup = _algo2_reset8
	output = _algo2_minus8_on
[superjust]
	bypass = 1
	input1 = _algo2_minus8_on * L1.3
	output1 = _menu3_L23
	input2 = _algo2_minus8_on * -1 + 1
	output2 = _algo2_minus8_off
	input3 = _algo2_minus8_off * L1.3
	output3 = _menu3_L24
[nudge]
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _algo2_reset16 + _algo2_reset8
	startvalue = 16
	amount = 1
	minimum = 9
	maximum = 16
	wrap = 1
	offset = _algo2_minus8_on * -8
	buttondown = _algo2_down
	buttonup = _algo2_up
	output = _algo2_length

# make algo2 length range indicators flashing when values 8 or 16 are chosen
[compare]
	input = _algo2_length
	compare = 8
	ifequal = 0
	else = 1
	output = _algo2_state8
[copy]
	input = _algo2_state8 * _state_lfo
	output = _algo2_state8_blink_tmp
[copy]
	input = 1 - _algo2_state8_blink_tmp
	output = _algo2_state8_blink
[copy]
	input = _menu3_L23 * _algo2_state8_blink
	output = _menu3_L23_blink
[compare]
	input = _algo2_length
	compare = 16
	ifequal = 0
	else = 1
	output = _algo2_state16
[copy]
	input = _algo2_state16 * _state_lfo
	output = _algo2_state16_blink_tmp
[copy]
	input = 1 - _algo2_state16_blink_tmp
	output = _algo2_state16_blink
[copy]
	input = _menu3_L24 * _algo2_state16_blink
	output = _menu3_L24_blink

# algo3 length
[button]
	button = B2.5
	select = L1.3
	shortpress = _algo3_down
	longpress = _algo3_reset8
[button]
	button = B2.6
	select = L1.3
	shortpress = _algo3_up
	longpress = _algo3_reset16
[nudge]
	preset = _preset
	loadpreset = _load
	savepreset = _save
	amount = 1
	minimum = 0
	maximum = 1
	wrap = 0
	buttondown = _algo3_reset16
	buttonup = _algo3_reset8
	output = _algo3_minus8_on
[superjust]
	bypass = 1
	input1 = _algo3_minus8_on * L1.3
	output1 = _menu3_L25
	input2 = _algo3_minus8_on * -1 + 1
	output2 = _algo3_minus8_off
	input3 = _algo3_minus8_off * L1.3
	output3 = _menu3_L26
[nudge]
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _algo3_reset16 + _algo3_reset8
	startvalue = 16
	amount = 1
	minimum = 9
	maximum = 16
	wrap = 1
	offset = _algo3_minus8_on * -8
	buttondown = _algo3_down
	buttonup = _algo3_up
	output = _algo3_length

# make algo3 length range indicators flashing when values 8 or 16 are chosen
[compare]
	input = _algo3_length
	compare = 8
	ifequal = 0
	else = 1
	output = _algo3_state8
[copy]
	input = _algo3_state8 * _state_lfo
	output = _algo3_state8_blink_tmp
[copy]
	input = 1 - _algo3_state8_blink_tmp
	output = _algo3_state8_blink
[copy]
	input = _menu3_L25 * _algo3_state8_blink
	output = _menu3_L25_blink
[compare]
	input = _algo3_length
	compare = 16
	ifequal = 0
	else = 1
	output = _algo3_state16
[copy]
	input = _algo3_state16 * _state_lfo
	output = _algo3_state16_blink_tmp
[copy]
	input = 1 - _algo3_state16_blink_tmp
	output = _algo3_state16_blink
[copy]
	input = _menu3_L26 * _algo3_state16_blink
	output = _menu3_L26_blink

# algo4 length
[button]
	button = B2.7
	select = L1.3
	shortpress = _algo4_down
	longpress = _algo4_reset8
[button]
	button = B2.8
	select = L1.3
	shortpress = _algo4_up
	longpress = _algo4_reset16
[nudge]
	preset = _preset
	loadpreset = _load
	savepreset = _save
	amount = 1
	minimum = 0
	maximum = 1
	wrap = 0
	buttondown = _algo4_reset16
	buttonup = _algo4_reset8
	output = _algo4_minus8_on
[superjust]
	bypass = 1
	input1 = _algo4_minus8_on * L1.3
	output1 = _menu3_L27
	input2 = _algo4_minus8_on * -1 + 1
	output2 = _algo4_minus8_off
	input3 = _algo4_minus8_off * L1.3
	output3 = _menu3_L28
[nudge]
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _algo4_reset16 + _algo4_reset8
	startvalue = 16
	amount = 1
	minimum = 9
	maximum = 16
	wrap = 1
	offset = _algo4_minus8_on * -8
	buttondown = _algo4_down
	buttonup = _algo4_up
	output = _algo4_length

# make algo4 length range indicators flashing when values 8 or 16 are chosen
[compare]
	input = _algo4_length
	compare = 8
	ifequal = 0
	else = 1
	output = _algo4_state8
[copy]
	input = _algo4_state8 * _state_lfo
	output = _algo4_state8_blink_tmp
[copy]
	input = 1 - _algo4_state8_blink_tmp
	output = _algo4_state8_blink
[copy]
	input = _menu3_L27 * _algo4_state8_blink
	output = _menu3_L27_blink
[compare]
	input = _algo4_length
	compare = 16
	ifequal = 0
	else = 1
	output = _algo4_state16
[copy]
	input = _algo4_state16 * _state_lfo
	output = _algo4_state16_blink_tmp
[copy]
	input = 1 - _algo4_state16_blink_tmp
	output = _algo4_state16_blink
[copy]
	input = _menu3_L28 * _algo4_state16_blink
	output = _menu3_L28_blink

### buttons for adjusting the level of the drum accents. The stepping ranges [1, 8] and [9, 16] follow the same logic as for the pattern length above. A level of 16 means that accents and non-accents have the same level (= ignoring accents). Lower level numbers subsequently reduce the accent level, thus increasing the velocity contrast between accents and non-accents.
# algo1 accent level
[button]
	button = B2.1
	select = L1.4 * _buttongroup_L11_inv
	shortpress = _algo1_acc_down
	longpress = _algo1_acc_reset8
[button]
	button = B2.2
	select = L1.4 * _buttongroup_L11_inv
	shortpress = _algo1_acc_up
	longpress = _algo1_acc_reset16
[nudge]
	preset = _preset
	loadpreset = _load
	savepreset = _save
	amount = 1
	minimum = 0
	maximum = 1
	wrap = 0
	buttondown = _algo1_acc_reset16
	buttonup = _algo1_acc_reset8
	output = _algo1_acc_minus8_on
[superjust]
	bypass = 1
	input1 = _algo1_acc_minus8_on * L1.4
	output1 = _menu4_L21
	input2 = _algo1_acc_minus8_on * -1 + 1
	output2 = _algo1_acc_minus8_off
	input3 = _algo1_acc_minus8_off * L1.4
	output3 = _menu4_L22
[nudge]
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _algo1_acc_reset16 + _algo1_acc_reset8
	startvalue = 16
	amount = 1
	minimum = 9
	maximum = 16
	wrap = 1
	offset = _algo1_acc_minus8_on * -8
	buttondown = _algo1_acc_down
	buttonup = _algo1_acc_up
	output = _algo1_acc
[copy]
	input = _algo1_acc * 0.0625 # set accent resolution. 0.0625 is 1/16, thus distributing the available 16 accent levels essentially to the whole velocity range [0, 1].
	output = _algo1_acc_level

# make algo1 accent range indicators flashing when values 8 or 16 are chosen
[compare]
	input = _algo1_acc
	compare = 8
	ifequal = 0
	else = 1
	output = _algo1_acc_state8
[copy]
	input = _algo1_acc_state8 * _state_lfo
	output = _algo1_acc_state8_blink_tmp
[copy]
	input = 1 - _algo1_acc_state8_blink_tmp
	output = _algo1_acc_state8_blink
[copy]
	input = _menu4_L21 * _algo1_acc_state8_blink
	output = _menu4_L21_blink
[compare]
	input = _algo1_acc
	compare = 16
	ifequal = 0
	else = 1
	output = _algo1_acc_state16
[copy]
	input = _algo1_acc_state16 * _state_lfo
	output = _algo1_acc_state16_blink_tmp
[copy]
	input = 1 - _algo1_acc_state16_blink_tmp
	output = _algo1_acc_state16_blink
[copy]
	input = _menu4_L22 * _algo1_acc_state16_blink
	output = _menu4_L22_blink

# algo2 accent level
[button]
	button = B2.3
	select = L1.4 * _buttongroup_L11_inv
	shortpress = _algo2_acc_down
	longpress = _algo2_acc_reset8
[button]
	button = B2.4
	select = L1.4 * _buttongroup_L11_inv
	shortpress = _algo2_acc_up
	longpress = _algo2_acc_reset16
[nudge]
	preset = _preset
	loadpreset = _load
	savepreset = _save
	amount = 1
	minimum = 0
	maximum = 1
	wrap = 0
	buttondown = _algo2_acc_reset16
	buttonup = _algo2_acc_reset8
	output = _algo2_acc_minus8_on
[superjust]
	bypass = 1
	input1 = _algo2_acc_minus8_on * L1.4
	output1 = _menu4_L23
	input2 = _algo2_acc_minus8_on * -1 + 1
	output2 = _algo2_acc_minus8_off
	input3 = _algo2_acc_minus8_off * L1.4
	output3 = _menu4_L24
[nudge]
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _algo2_acc_reset16 + _algo2_acc_reset8
	startvalue = 16
	amount = 1
	minimum = 9
	maximum = 16
	wrap = 1
	offset = _algo2_acc_minus8_on * -8
	buttondown = _algo2_acc_down
	buttonup = _algo2_acc_up
	output = _algo2_acc
[copy]
	input = _algo2_acc * 0.0625 # set accent resolution
	output = _algo2_acc_level

# make algo2 accent range indicators flashing when values 8 or 16 are chosen
[compare]
	input = _algo2_acc
	compare = 8
	ifequal = 0
	else = 1
	output = _algo2_acc_state8
[copy]
	input = _algo2_acc_state8 * _state_lfo
	output = _algo2_acc_state8_blink_tmp
[copy]
	input = 1 - _algo2_acc_state8_blink_tmp
	output = _algo2_acc_state8_blink
[copy]
	input = _menu4_L23 * _algo2_acc_state8_blink
	output = _menu4_L23_blink
[compare]
	input = _algo2_acc
	compare = 16
	ifequal = 0
	else = 1
	output = _algo2_acc_state16
[copy]
	input = _algo2_acc_state16 * _state_lfo
	output = _algo2_acc_state16_blink_tmp
[copy]
	input = 1 - _algo2_acc_state16_blink_tmp
	output = _algo2_acc_state16_blink
[copy]
	input = _menu4_L24 * _algo2_acc_state16_blink
	output = _menu4_L24_blink

# algo3 accent level
[button]
	button = B2.5
	select = L1.4 * _buttongroup_L11_inv
	shortpress = _algo3_acc_down
	longpress = _algo3_acc_reset8
[button]
	button = B2.6
	select = L1.4 * _buttongroup_L11_inv
	shortpress = _algo3_acc_up
	longpress = _algo3_acc_reset16
[nudge]
	preset = _preset
	loadpreset = _load
	savepreset = _save
	amount = 1
	minimum = 0
	maximum = 1
	wrap = 0
	buttondown = _algo3_acc_reset16
	buttonup = _algo3_acc_reset8
	output = _algo3_acc_minus8_on
[superjust]
	bypass = 1
	input1 = _algo3_acc_minus8_on * L1.4
	output1 = _menu4_L25
	input2 = _algo3_acc_minus8_on * -1 + 1
	output2 = _algo3_acc_minus8_off
	input3 = _algo3_acc_minus8_off * L1.4
	output3 = _menu4_L26
[nudge]
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _algo3_acc_reset16 + _algo3_acc_reset8
	startvalue = 16
	amount = 1
	minimum = 9
	maximum = 16
	wrap = 1
	offset = _algo3_acc_minus8_on * -8
	buttondown = _algo3_acc_down
	buttonup = _algo3_acc_up
	output = _algo3_acc
[copy]
	input = _algo3_acc * 0.0625 # set accent resolution
	output = _algo3_acc_level

# make algo3 accent range indicators flashing when values 8 or 16 are chosen
[compare]
	input = _algo3_acc
	compare = 8
	ifequal = 0
	else = 1
	output = _algo3_acc_state8
[copy]
	input = _algo3_acc_state8 * _state_lfo
	output = _algo3_acc_state8_blink_tmp
[copy]
	input = 1 - _algo3_acc_state8_blink_tmp
	output = _algo3_acc_state8_blink
[copy]
	input = _menu4_L25 * _algo3_acc_state8_blink
	output = _menu4_L25_blink
[compare]
	input = _algo3_acc
	compare = 16
	ifequal = 0
	else = 1
	output = _algo3_acc_state16
[copy]
	input = _algo3_acc_state16 * _state_lfo
	output = _algo3_acc_state16_blink_tmp
[copy]
	input = 1 - _algo3_acc_state16_blink_tmp
	output = _algo3_acc_state16_blink
[copy]
	input = _menu4_L26 * _algo3_acc_state16_blink
	output = _menu4_L26_blink

# algo4 accent level
[button]
	button = B2.7
	select = L1.4 * _buttongroup_L11_inv
	shortpress = _algo4_acc_down
	longpress = _algo4_acc_reset8
[button]
	button = B2.8
	select = L1.4 * _buttongroup_L11_inv
	shortpress = _algo4_acc_up
	longpress = _algo4_acc_reset16
[nudge]
	preset = _preset
	loadpreset = _load
	savepreset = _save
	amount = 1
	minimum = 0
	maximum = 1
	wrap = 0
	buttondown = _algo4_acc_reset16
	buttonup = _algo4_acc_reset8
	output = _algo4_acc_minus8_on
[superjust]
	bypass = 1
	input1 = _algo4_acc_minus8_on * L1.4
	output1 = _menu4_L27
	input2 = _algo4_acc_minus8_on * -1 + 1
	output2 = _algo4_acc_minus8_off
	input3 = _algo4_acc_minus8_off * L1.4
	output3 = _menu4_L28
[nudge]
	preset = _preset
	loadpreset = _load
	savepreset = _save
	clear = _algo4_acc_reset16 + _algo4_acc_reset8
	startvalue = 16
	amount = 1
	minimum = 9
	maximum = 16
	wrap = 1
	offset = _algo4_acc_minus8_on * -8
	buttondown = _algo4_acc_down
	buttonup = _algo4_acc_up
	output = _algo4_acc
[copy]
	input = _algo4_acc * 0.0625 # set accent resolution
	output = _algo4_acc_level

# make algo4 accent range indicators flashing when values 8 or 16 are chosen
[compare]
	input = _algo4_acc
	compare = 8
	ifequal = 0
	else = 1
	output = _algo4_acc_state8
[copy]
	input = _algo4_acc_state8 * _state_lfo
	output = _algo4_acc_state8_blink_tmp
[copy]
	input = 1 - _algo4_acc_state8_blink_tmp
	output = _algo4_acc_state8_blink
[copy]
	input = _menu4_L27 * _algo4_acc_state8_blink
	output = _menu4_L27_blink
[compare]
	input = _algo4_acc
	compare = 16
	ifequal = 0
	else = 1
	output = _algo4_acc_state16
[copy]
	input = _algo4_acc_state16 * _state_lfo
	output = _algo4_acc_state16_blink_tmp
[copy]
	input = 1 - _algo4_acc_state16_blink_tmp
	output = _algo4_acc_state16_blink
[copy]
	input = _menu4_L28 * _algo4_acc_state16_blink
	output = _menu4_L28_blink

### buttons for including/excluding channels in fills and rolls
[button]
	button = B2.1
	select = L1.5
	preset = _preset
	loadpreset = _load
	savepreset = _save
	states = 2
	led = _menu5_L21
	output = _algo1_fills
[button]
	button = B2.2
	select = L1.5
	preset = _preset
	loadpreset = _load
	savepreset = _save
	states = 2
	led = _menu5_L22
	output = _algo1_rolls
[button]
	button = B2.3
	select = L1.5
	preset = _preset
	loadpreset = _load
	savepreset = _save
	states = 2
	led = _menu5_L23
	output = _algo2_fills
[button]
	button = B2.4
	select = L1.5
	preset = _preset
	loadpreset = _load
	savepreset = _save
	states = 2
	led = _menu5_L24
	output = _algo2_rolls
[button]
	button = B2.5
	select = L1.5
	preset = _preset
	loadpreset = _load
	savepreset = _save
	states = 2
	led = _menu5_L25
	output = _algo3_fills
[button]
	button = B2.6
	select = L1.5
	preset = _preset
	loadpreset = _load
	savepreset = _save
	states = 2
	led = _menu5_L26
	output = _algo3_rolls
[button]
	button = B2.7
	select = L1.5
	preset = _preset
	loadpreset = _load
	savepreset = _save
	states = 2
	led = _menu5_L27
	output = _algo4_fills
[button]
	button = B2.8
	select = L1.5
	preset = _preset
	loadpreset = _load
	savepreset = _save
	states = 2
	led = _menu5_L28
	output = _algo4_rolls

### buttons for incl/excl channels in variations and for attanuation of variation intensity
[button]
	button = B2.1
	select = L1.6 * _buttongroup_L11_inv
	preset = _preset
	loadpreset = _load
	savepreset = _save
	led = _menu6_L21
	states = 2
	output = _algo1_variation
[button]
	button = B2.2
	select = L1.6 * _buttongroup_L11_inv
	preset = _preset
	loadpreset = _load
	savepreset = _save
	led = _menu6_L22
	states = 4
	value1 = 1
	value2 = 0.75
	value3 = 0.5
	value4 = 0.25
	output = _algo1_variation_factor
[copy]
	input = 1 - _menu6_L22
	output = _menu6_L22_inv
[button]
	button = B2.3
	select = L1.6 * _buttongroup_L11_inv
	preset = _preset
	loadpreset = _load
	savepreset = _save
	led = _menu6_L23
	states = 2
	output = _algo2_variation
[button]
	button = B2.4
	select = L1.6 * _buttongroup_L11_inv
	preset = _preset
	loadpreset = _load
	savepreset = _save
	led = _menu6_L24
	states = 4
	value1 = 1
	value2 = 0.75
	value3 = 0.5
	value4 = 0.25
	output = _algo2_variation_factor
[copy]
	input = 1 - _menu6_L24
	output = _menu6_L24_inv
[button]
	button = B2.5
	select = L1.6 * _buttongroup_L11_inv
	preset = _preset
	loadpreset = _load
	savepreset = _save
	led = _menu6_L25
	states = 2
	output = _algo3_variation
[button]
	button = B2.6
	select = L1.6 * _buttongroup_L11_inv
	preset = _preset
	loadpreset = _load
	savepreset = _save
	led = _menu6_L26
	states = 4
	value1 = 1
	value2 = 0.75
	value3 = 0.5
	value4 = 0.25
	output = _algo3_variation_factor
[copy]
	input = 1 - _menu6_L26
	output = _menu6_L26_inv
[button]
	button = B2.7
	select = L1.6 * _buttongroup_L11_inv
	preset = _preset
	loadpreset = _load
	savepreset = _save
	led = _menu6_L27
	states = 2
	output = _algo4_variation
[button]
	button = B2.8
	select = L1.6 * _buttongroup_L11_inv
	preset = _preset
	loadpreset = _load
	savepreset = _save
	led = _menu6_L28
	states = 4
	value1 = 1
	value2 = 0.75
	value3 = 0.5
	value4 = 0.25
	output = _algo4_variation_factor
[copy]
	input = 1 - _menu6_L28
	output = _menu6_L28_inv
[superjust]
	bypass = 1
	input1 = _algo1_variation * _algo1_variation_factor
	input2 = _algo2_variation * _algo2_variation_factor
	input3 = _algo3_variation * _algo3_variation_factor
	input4 = _algo4_variation * _algo4_variation_factor
	output1 = _algo1_vars
	output2 = _algo2_vars
	output3 = _algo3_vars
	output4 = _algo4_vars

### button to switch between menu8 and submenu8
[button]
	button = B1.8
	longpress = _menu8_longpress
[nudge]
	amount = 1
	minimum = 0
	maximum = 1
	wrap = 1
	buttonup = _menu8_longpress
	output = _submenu8_on
[copy]
	input = 1 - _submenu8_on
	output = _submenu8_off
[copy]
	input = _menu8_L18 * _submenu8_on
	output = _submenu8
[copy]
	input = _menu8_L18 * _submenu8_off
	output = _menu8
### buttons to set global fillorder
[buttongroup]
	select = _menu8
	preset = _preset
	loadpreset = _load
	savepreset = _save
	button1 = B2.1
	button2 = B2.3
	button3 = B2.5
	button4 = B2.7
	led1 = _menu8_L21
	led2 = _menu8_L23
	led3 = _menu8_L25
	led4 = _menu8_L27
	value1 = 0
	value2 = 1
	value3 = 2
	value4 = 3
	output = _fillorder

### buttons to set global value of branches
[buttongroup]
	preset = _preset
	loadpreset = _load
	savepreset = _save
	select = _menu8
	button1 = B2.2
	button2 = B2.4
	button3 = B2.6
	button4 = B2.8
	led1 = _menu8_L22
	led2 = _menu8_L24
	led3 = _menu8_L26
	led4 = _menu8_L28
	value1 = 0
	value2 = 1
	value3 = 2
	value4 = 3
	output = _branches

### cv input to select and load presets (sub-menu 8)
[copy]
	input = I3 # cv in of 0-6V selects presets 1-7
	output = _preset_ext
[copy]
	input = I4 # trigger in to load selected preset 
	output = _load_ext
[quantizer]
	input = _preset_ext
	steps = 1
	output = _preset_ext_q
[compare]
	input = _preset_ext_q
	compare = 0
	ifless = 0
	else = _preset_ext_q
	output = _preset_ext_q_lim1
[compare]
	input = _preset_ext_q_lim1
	compare = 0.6
	ifgreater = 0.6
	else = _preset_ext_q_lim1
	output = _preset_ext_q_lim2
[switch]
	input = _load_ext
	offset = _preset_ext_q_lim2 * 10
	output1 = _load_ext0
	output2 = _load_ext6
	output3 = _load_ext5
	output4 = _load_ext4
	output5 = _load_ext3
	output6 = _load_ext2
	output7 = _load_ext1
### buttons for saving and loading presets
[buttongroup]
	select = _submenu8 + _load_ext
	button1 = B2.1 + _load_ext0
	button2 = B2.2 + _load_ext1
	button3 = B2.3 + _load_ext2
	button4 = B2.4 + _load_ext3
	button5 = B2.5 + _load_ext4
	button6 = B2.6 + _load_ext5
	button7 = B2.7 + _load_ext6
#	button8 = B2.8
	led1 = _submenu8_L21
	led2 = _submenu8_L22
	led3 = _submenu8_L23
	led4 = _submenu8_L24
	led5 = _submenu8_L25
	led6 = _submenu8_L26
	led7 = _submenu8_L27
#	led8 = _submenu8_L28
	value1 = 0
	value2 = 1
	value3 = 2
	value4 = 3
	value5 = 4
	value6 = 5
	value7 = 6
#	value8 = 7
	output = _preset
#	output = _preset_int
	buttonpress = _load_ini
	longpress = _save
[button]
	button = B2.8
	select = _submenu8
	led = _submenu8_L28
[copy]
	input = 1 - _submenu8_L28
	output = _submenu8_L28_inv

[contour] # animation for saving presets in menu8
	trigger = _save
	attack = 0
	release = 0
	hold = 2
	output = _save_on
[switch]
	input1 = _submenu8_L21
	input2 = _submenu8_L22
	input3 = _submenu8_L23
	input4 = _submenu8_L24
	input5 = _submenu8_L25
	input6 = _submenu8_L26
	input7 = _submenu8_L27
#	input8 = _submenu8_L28
	offset = _preset
	output = _buttonhold
[copy]
	input = -2 * _buttonhold + 1
	output = _amplitude
[copy]
	input = _lfo * _amplitude
	output = _lfo_scaled
[switch]
	input = _save_on * _lfo_scaled
	offset = _preset
	output1 = _save_blink0
	output2 = _save_blink6
	output3 = _save_blink5
	output4 = _save_blink4
	output5 = _save_blink3
	output6 = _save_blink2
	output7 = _save_blink1

# load presets only at the end of a bar
[nudge]
	amount = 1
	minimum = 0
	maximum = 1
	wrap = 0
	buttondown = _load
	buttonup = _load_ini
	output = _load_pass
[copy]
	input = _load_pass * _step16 # _step16 seems to be too early for loading presets, as the loaded sequences are then ahead of time by 1/16th. -> using _clock2 (delayed by half duty cycle)
	output = _load_tmp
[triggerdelay]
	# clocktool circuit is buggy. use triggerdelay instead.
	clock = I1
	input = I1
	delay = 0.5
	output = _clock2
[copy]
	input = _load_tmp * _clock2
	output = _load
[copy]
	input = _load_pass * 0.9
	output = _load_queue
[copy]
	input = _submenu8 - _load_queue
	output = _load_queue_dim

# Here follow the algoquencers. For each vioce there is the original algo which is permanently listening to an external trigger sequence, a second algo which is a copy of the original but applies all kind of modulations and is used as the outgoing trigger sequence, and a third one which uses independent random seeds to generate accents. Note that changes in the external sequences arrive at the modulation algoquencers one bar cycle later. Alternatively, you can delay the clock for the modulation algos a bit to enable tighter mapping of the external sequence (almost in time). However, in this patch this only works for a minimum delay of 50 ms, which already would require adjustments of the master clock for the remaining system. Also visually you clearly spot a 50 ms delay between the input and output leds, which I find disturbing as the leds keep me informed about the current settings of the patch. Thus I rather prefer to have everything in sync with the master clock and be one bar late regarding the external trigger sequences. In a perfomance, this can even be advantageous, allowing me to change the external sequences first and then having hands free to do other stuff when the changes finally arrive at the modulation algoquencers.
#[triggerdelay]
#	input = I1
#	delay = 0.05 # seconds
#	output = _clock_delayed

### This is the 1st algoquencer that is listening and adjusting to an external drum sequence. Be aware that algoquencer buttons are toggle buttons.
[algoquencer]
	select = 1
 	clock = I1
	reset = _reset
	clear = _clear
	preset = _preset
	loadpreset = _load * _submenu8_L28
	savepreset = _save
	gate = _algo1_gateout
#	trigger = _algo1_triggerout
	barled1 = _barled1
	barled2 = _barled2
	barled3 = _barled3
	barled4 = _barled4
 	button1 = _algo1_button1_toggle
	button2 = _algo1_button2_toggle
	button3 = _algo1_button3_toggle
	button4 = _algo1_button4_toggle
	button5 = _algo1_button5_toggle
	button6 = _algo1_button6_toggle
	button7 = _algo1_button7_toggle
	button8 = _algo1_button8_toggle
	button9 = _algo1_button9_toggle
	button10 = _algo1_button10_toggle
	button11 = _algo1_button11_toggle
	button12 = _algo1_button12_toggle
	button13 = _algo1_button13_toggle
	button14 = _algo1_button14_toggle
	button15 = _algo1_button15_toggle
	button16 = _algo1_button16_toggle
	led16 = _step16

### This is the copy of the 1st algoquencer where all kind of modulations and variations can be applied without disturbing the original listening algoquencer. The trigger ouputs here are finally sent to a drum voice. In this example I use the X7 to run a midi drum sampler. See [midiout] at the end of the patch, 'notegatevelocity' is used for sending accents.
[algoquencer]
	select = 1
 	clock = I1
#	clock = _clock_delayed
	reset = _reset
	clear = _clear
	preset = _preset
	loadpreset = _load * _submenu8_L28
	savepreset = _save
	reroll = _algo1_reroll + _clear
	length = _algo1_length
	trigger = _drum_kick # output to trigger drum voice
	muteled = _menu1_L21
	unmuteled = _menu1_L22
	mutebutton = _algo1_mute_toggle
	unmutebutton = _algo1_unmute
	activity = _algo1_activity + _global_activity
	variation = _global_variation * _algo1_vars
	branches = _branches
	fills = _global_fills * _algo1_fills
	fillorder = _fillorder
	rolls = _global_rolls * _algo1_rolls
	dejavu = _algo1_dejavu
	morphs = _algo1_morph
	offbeats = _global_offbeats
	distribution = _global_distribution
 	button1 = _algo1_button1_toggle
	button2 = _algo1_button2_toggle
	button3 = _algo1_button3_toggle
	button4 = _algo1_button4_toggle
	button5 = _algo1_button5_toggle
	button6 = _algo1_button6_toggle
	button7 = _algo1_button7_toggle
	button8 = _algo1_button8_toggle
	button9 = _algo1_button9_toggle
	button10 = _algo1_button10_toggle
	button11 = _algo1_button11_toggle
	button12 = _algo1_button12_toggle
	button13 = _algo1_button13_toggle
	button14 = _algo1_button14_toggle
	button15 = _algo1_button15_toggle
	button16 = _algo1_button16_toggle

# inverted muteled; needed to automatically set global mute state to 'on' when all channels are manually muted.
[copy]
	input = 1 - _menu1_L21
	output = _menu1_L21_inv
# save/load mute state of channel 1
[nudge]
	preset = _preset
	loadpreset = _load * _submenu8_L28_inv
	savepreset = _save
	amount = 1
	minimum = 0
	maximum = 1
	wrap = 0
	buttondown = _menu1_L21_inv
	buttonup = _menu1_L21
	output = _algo1_mute_state
[superjust]
	bypass = 1
	input1 = 1 - _algo1_mute_state
	output1 = _algo1_mute_state_inv
	input2 = _algo1_mute_state * _menu1_L21_inv
	output2 = _algo1_mute_load_1
	input3 = _algo1_mute_state_inv * _menu1_L21
	output3 = _algo1_mute_load_2
	input4 = _algo1_mute_load_1 + _algo1_mute_load_2
	output4 = _algo1_mute_load

### independent algoquencer used for accents of 1st channel. The accent algos only run internal random sequences and can be rerolled in menu 2. I use these additional algos (instead of the internal accent function) as I wish to be able to reroll their random sequences (= accents) without at the same time rerolling the random sequences used for the rythm variations in the corresponding trigger algos.
[algoquencer]
	select = 1
 	clock = I1
#	clock = _clock_delayed
	reset = _reset
	clear = _clear
	preset = _preset
	loadpreset = _load
	savepreset = _save
	pitchlow = _algo1_acc_level
	pitchhigh = 1.0
	pitchresolution = 2
	reroll = _accent1_reroll + _clear
	pitch = _accent_kick

### 2nd original algoquencer, listening and adjusting to an external trigger sequence
[algoquencer]
	select = 1
 	clock = I1
	reset = _reset
	clear = _clear
	preset = _preset
	loadpreset = _load * _submenu8_L28
	savepreset = _save
	gate = _algo2_gateout
#	trigger = _algo2_triggerout
 	button1 = _algo2_button1_toggle
	button2 = _algo2_button2_toggle
	button3 = _algo2_button3_toggle
	button4 = _algo2_button4_toggle
	button5 = _algo2_button5_toggle
	button6 = _algo2_button6_toggle
	button7 = _algo2_button7_toggle
	button8 = _algo2_button8_toggle
	button9 = _algo2_button9_toggle
	button10 = _algo2_button10_toggle
	button11 = _algo2_button11_toggle
	button12 = _algo2_button12_toggle
	button13 = _algo2_button13_toggle
	button14 = _algo2_button14_toggle
	button15 = _algo2_button15_toggle
	button16 = _algo2_button16_toggle

### copied 2nd algo to apply all modifications without messing up the original algo2 sequence
[algoquencer]
	select = 1
 	clock = I1
#	clock = _clock_delayed
	reset = _reset
	clear = _clear
	preset = _preset
	loadpreset = _load * _submenu8_L28
	savepreset = _save
	reroll = _algo2_reroll + _clear
	length = _algo2_length
	trigger = _drum_snare
	muteled = _menu1_L23
	unmuteled = _menu1_L24
	mutebutton = _algo2_mute_toggle
	unmutebutton = _algo2_unmute
	activity = _algo2_activity + _global_activity
	variation = _global_variation * _algo2_vars
	branches = _branches
	fills = _global_fills * _algo2_fills
	fillorder = _fillorder
	rolls = _global_rolls * _algo2_rolls
	dejavu = _algo2_dejavu
	morphs = _algo2_morph
	offbeats = _global_offbeats
	distribution = _global_distribution
 	button1 = _algo2_button1_toggle
	button2 = _algo2_button2_toggle
	button3 = _algo2_button3_toggle
	button4 = _algo2_button4_toggle
	button5 = _algo2_button5_toggle
	button6 = _algo2_button6_toggle
	button7 = _algo2_button7_toggle
	button8 = _algo2_button8_toggle
	button9 = _algo2_button9_toggle
	button10 = _algo2_button10_toggle
	button11 = _algo2_button11_toggle
	button12 = _algo2_button12_toggle
	button13 = _algo2_button13_toggle
	button14 = _algo2_button14_toggle
	button15 = _algo2_button15_toggle
	button16 = _algo2_button16_toggle

[copy]
	input = 1 - _menu1_L23
	output = _menu1_L23_inv
# save/load mute state of channel 2
[nudge]
	preset = _preset
	loadpreset = _load * _submenu8_L28_inv
	savepreset = _save
	amount = 1
	minimum = 0
	maximum = 1
	wrap = 0
	buttondown = _menu1_L23_inv
	buttonup = _menu1_L23
	output = _algo2_mute_state
[superjust]
	bypass = 1
	input1 = 1 - _algo2_mute_state
	output1 = _algo2_mute_state_inv
	input2 = _algo2_mute_state * _menu1_L23_inv
	output2 = _algo2_mute_load_1
	input3 = _algo2_mute_state_inv * _menu1_L23
	output3 = _algo2_mute_load_2
	input4 = _algo2_mute_load_1 + _algo2_mute_load_2
	output4 = _algo2_mute_load

# accents for 2nd algoquencer
[algoquencer]
	select = 1
 	clock = I1
	reset = _reset
	clear = _clear
	preset = _preset
	loadpreset = _load
	savepreset = _save
	pitchlow = _algo2_acc_level
	pitchhigh = 1.0
	pitchresolution = 2
	reroll = _accent2_reroll + _clear
	pitch = _accent_snare

### 3rd original algoquencer, permanently listening and adjusting to an external trigger sequence
[algoquencer]
	select = 1
 	clock = I1
	reset = _reset
	clear = _clear
	preset = _preset
	loadpreset = _load * _submenu8_L28
	savepreset = _save
	gate = _algo3_gateout
#	trigger = _algo3_triggerout
 	button1 = _algo3_button1_toggle
	button2 = _algo3_button2_toggle
	button3 = _algo3_button3_toggle
	button4 = _algo3_button4_toggle
	button5 = _algo3_button5_toggle
	button6 = _algo3_button6_toggle
	button7 = _algo3_button7_toggle
	button8 = _algo3_button8_toggle
	button9 = _algo3_button9_toggle
	button10 = _algo3_button10_toggle
	button11 = _algo3_button11_toggle
	button12 = _algo3_button12_toggle
	button13 = _algo3_button13_toggle
	button14 = _algo3_button14_toggle
	button15 = _algo3_button15_toggle
	button16 = _algo3_button16_toggle

### copied 3rd algo to apply all modifications without messing up the original algo3 sequence
[algoquencer]
	select = 1
 	clock = I1
#	clock = _clock_delayed
	reset = _reset
	clear = _clear
	preset = _preset
	loadpreset = _load * _submenu8_L28
	savepreset = _save
	reroll = _algo3_reroll + _clear
	length = _algo3_length
	trigger = _drum_hat
	muteled = _menu1_L25
	unmuteled = _menu1_L26
	mutebutton = _algo3_mute_toggle
	unmutebutton = _algo3_unmute
	activity = _algo3_activity + _global_activity
	variation = _global_variation * _algo3_vars
	branches = _branches
	fills = _global_fills * _algo3_fills
	fillorder = _fillorder
	rolls = _global_rolls * _algo3_rolls
	dejavu = _algo3_dejavu
	morphs = _algo3_morph
	offbeats = _global_offbeats
	distribution = _global_distribution
 	button1 = _algo3_button1_toggle
	button2 = _algo3_button2_toggle
	button3 = _algo3_button3_toggle
	button4 = _algo3_button4_toggle
	button5 = _algo3_button5_toggle
	button6 = _algo3_button6_toggle
	button7 = _algo3_button7_toggle
	button8 = _algo3_button8_toggle
	button9 = _algo3_button9_toggle
	button10 = _algo3_button10_toggle
	button11 = _algo3_button11_toggle
	button12 = _algo3_button12_toggle
	button13 = _algo3_button13_toggle
	button14 = _algo3_button14_toggle
	button15 = _algo3_button15_toggle
	button16 = _algo3_button16_toggle

[copy]
	input = 1 - _menu1_L25
	output = _menu1_L25_inv
# save/load mute state of channel 3
[nudge]
	preset = _preset
	loadpreset = _load * _submenu8_L28_inv
	savepreset = _save
	amount = 1
	minimum = 0
	maximum = 1
	wrap = 0
	buttondown = _menu1_L25_inv
	buttonup = _menu1_L25
	output = _algo3_mute_state
[superjust]
	bypass = 1
	input1 = 1 - _algo3_mute_state
	output1 = _algo3_mute_state_inv
	input2 = _algo3_mute_state * _menu1_L25_inv
	output2 = _algo3_mute_load_1
	input3 = _algo3_mute_state_inv * _menu1_L25
	output3 = _algo3_mute_load_2
	input4 = _algo3_mute_load_1 + _algo3_mute_load_2
	output4 = _algo3_mute_load

# accents for 3rd algoquencer
[algoquencer]
	select = 1
 	clock = I1
	reset = _reset
	clear = _clear
	preset = _preset
	loadpreset = _load
	savepreset = _save
	pitchlow = _algo3_acc_level
	pitchhigh = 1.0
	pitchresolution = 2
	reroll = _accent3_reroll + _clear
	pitch = _accent_hat

### 4th original algoquencer, permanently listening and adjusting to an external trigger sequence
[algoquencer]
	select = 1
 	clock = I1
	reset = _reset
	clear = _clear
	preset = _preset
	loadpreset = _load * _submenu8_L28
	savepreset = _save
	gate = _algo4_gateout
#	trigger = _algo4_triggerout
 	button1 = _algo4_button1_toggle
	button2 = _algo4_button2_toggle
	button3 = _algo4_button3_toggle
	button4 = _algo4_button4_toggle
	button5 = _algo4_button5_toggle
	button6 = _algo4_button6_toggle
	button7 = _algo4_button7_toggle
	button8 = _algo4_button8_toggle
	button9 = _algo4_button9_toggle
	button10 = _algo4_button10_toggle
	button11 = _algo4_button11_toggle
	button12 = _algo4_button12_toggle
	button13 = _algo4_button13_toggle
	button14 = _algo4_button14_toggle
	button15 = _algo4_button15_toggle
	button16 = _algo4_button16_toggle

### copied 4th algo to apply all modifications without messing up the original algo4 sequence
[algoquencer]
	select = 1
 	clock = I1
#	clock = _clock_delayed
	reset = _reset
	clear = _clear
	preset = _preset
	loadpreset = _load * _submenu8_L28
	savepreset = _save
	reroll = _algo4_reroll + _clear
	length = _algo4_length
	trigger = _drum_clap
	muteled = _menu1_L27
	unmuteled = _menu1_L28
	mutebutton = _algo4_mute_toggle
	unmutebutton = _algo4_unmute
	activity = _algo4_activity + _global_activity
	variation = _global_variation * _algo4_vars
	branches = _branches
	fills = _global_fills * _algo4_fills
	fillorder = _fillorder
	rolls = _global_rolls * _algo4_rolls
	dejavu = _algo4_dejavu
	morphs = _algo4_morph
	offbeats = _global_offbeats
	distribution = _global_distribution
 	button1 = _algo4_button1_toggle
	button2 = _algo4_button2_toggle
	button3 = _algo4_button3_toggle
	button4 = _algo4_button4_toggle
	button5 = _algo4_button5_toggle
	button6 = _algo4_button6_toggle
	button7 = _algo4_button7_toggle
	button8 = _algo4_button8_toggle
	button9 = _algo4_button9_toggle
	button10 = _algo4_button10_toggle
	button11 = _algo4_button11_toggle
	button12 = _algo4_button12_toggle
	button13 = _algo4_button13_toggle
	button14 = _algo4_button14_toggle
	button15 = _algo4_button15_toggle
	button16 = _algo4_button16_toggle

[copy]
	input = 1 - _menu1_L27
	output = _menu1_L27_inv
# save/load mute state of channel 4
[nudge]
	preset = _preset
	loadpreset = _load * _submenu8_L28_inv
	savepreset = _save
	amount = 1
	minimum = 0
	maximum = 1
	wrap = 0
	buttondown = _menu1_L27_inv
	buttonup = _menu1_L27
	output = _algo4_mute_state
[superjust]
	bypass = 1
	input1 = 1 - _algo4_mute_state
	output1 = _algo4_mute_state_inv
	input2 = _algo4_mute_state * _menu1_L27_inv
	output2 = _algo4_mute_load_1
	input3 = _algo4_mute_state_inv * _menu1_L27
	output3 = _algo4_mute_load_2
	input4 = _algo4_mute_load_1 + _algo4_mute_load_2
	output4 = _algo4_mute_load

# accents for 4th algoquencer
[algoquencer]
	select = 1
 	clock = I1
	reset = _reset
	clear = _clear
	preset = _preset
	loadpreset = _load
	savepreset = _save
	pitchlow = _algo4_acc_level
	pitchhigh = 1.0
	pitchresolution = 2
	reroll = _accent4_reroll + _clear
	pitch = _accent_clap

### control leds for visual feedback of outgoing drum sequences
#[superjust]
#	bypass = 1
#	input1 = _drum_kick
#	output1 = R18
#	input2 = _drum_snare
#	output2 = R20
#	input3 = _drum_hat
#	output3 = R22
#	input4 = _drum_clap
#	output4 = R24

### transformation of algo gates output into AR spikes to avoid timing problems during the comparison with the incoming trigger sequences
[contour]
	trigger = _algo1_gateout
	attack = 0.6
	release = 0.6 * 0.05
	output = _algo1_gates
[contour]
	trigger = _algo2_gateout
	attack = 0.6
	release = 0.6 * 0.05
	output = _algo2_gates
[contour]
	trigger = _algo3_gateout
	attack = 0.6
	release = 0.6 * 0.05
	output = _algo3_gates
[contour]
	trigger = _algo4_gateout
	attack = 0.6
	release = 0.6 * 0.05
	output = _algo4_gates

### final output of the modified algo sequences
[superjust]
	bypass = 1
	input1 = _drum_kick
	input2 = _drum_snare
	input3 = _drum_hat
	input4 = _drum_clap
	output1 = O1
	output2 = O2
	output3 = O3
	output4 = O4
	input5 = _accent_kick
	input6 = _accent_snare
	input7 = _accent_hat
	input8 = _accent_clap
	output5 = O5
	output6 = O6
	output7 = O7
	output8 = O8

### example for midi out to Roland TR-08
#[midiout]
#	channel = 9
#	note1 = 36 # BD
#	notegate1 = _drum_kick
##	ccnumber1 = 23 # BD decay
#	ccnumber1 = 24 # BD level
#	cc1 = _accent_kick
#	cctrigger1 = _drum_kick
#	note2 = 38 # SD
#	notegate2 = _drum_snare
#	ccnumber2 = 26 # SD snappy
#	cc2 = _accent_snare
#	cctrigger2 = _drum_snare
#	note3 = 42 # CH
##	note3 = 46 # OH
#	notegate3 = _drum_hat
#	ccnumber3 = 62 # CH decay
##	ccnumber3 = 81 # OH decay
#	cc3 = _accent_hat
#	cctrigger3 = _drum_hat
#	note4 = 39 # CP
##	note4 = 75 # Claves
##	note4 = 37 # Rim Shot
#	notegate4 = _drum_clap
#	ccnumber4 = 60 # CP level
##	ccnumber4 = 57 # RS level
#	cc4 = _accent_clap
#	cctrigger4 = _drum_clap
